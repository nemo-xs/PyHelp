# СИНТАКСИС ЯЗЫКА
# Математические операции:
# -----------------------------------------------------------------------------
#   ** возведение в степень (если значение меньше 1 - то корень)
#   >= больше или равно, <= - меньше или равно
#   != не равно
#   // Целочисленное деление. Дает челое число при делении
#   %  остаток после деления
#   x +=2 Прибавить (может быть любая операция), цифру после равно
#   == Проверяет равенство, одинаковые ли объекты
#   =  Простой оператор присваивания значений переменной
#   := Новый оператор присваивания. Используется в if и while (см ниже)
# -----------------------------------------------------------------------------


import sys     # Простой Импорт стандартного модуля sys целиком
import math as ma  # Импорт стандартного модуля математических вычислений, с
# переименованием его в модуль ma для дальнейшего использования
import re  # импорт библиотеки разбора фраз, предложений и т.п. по маске
from lib.mymodule import (max3, hello1)  # Импорт одной или нескольких
# переменных из внешенего модуля. После скобок, через оператор as можно его
# переименовать. Здесь для импорта необходимо прописывать пути. В частности
# lib - это папка расположения самого модуля относительно данного файла. Через
# точку, указывается название модуля (файла), затем в скобках или без -
# перечисляются импортируемые функции.

sys.path.append('./bin/')  # Импорт в проект путей/папок проекта, если это
# необходимо. "./" - текущая папка. "../" - родительская папка.

print(sys.version)  # печать версии системы из модуля sys
print(ma.pi)  # печать числа Пи, из модуля math, сокращенного выше до ma

print(max3(2, 5))   # Вызов Функции Из Внешнего Модуля.
# В Данном Случае Вызыватся Функция Max3 Из Модуля Mymodule,
hello1("test")  # вызов функции из внешнего модуля. В данном случае вызыватся
# функция hello1 из модуля mymodule. (в самой функции есть опертаор "print").
# То что стоит в скобках, заменяет параметр по умолчанию, который есть в
# модуле. Если ничего не писать, оставить (), будет использовать значения из
# модуля.

print("""
проверочный текст          #тройными кавычками замыкается текст, чтобы
с условными переносами     #выводить его также как в коде :)
как в коде. Замыкающие обязательно на отдельной строке.
""")

# Простое назначение переменных ----------------------------------------------
x = 105     # Назначение переменной x
y = 110     # Назнечение другой переменной y

# Цикл -----------------------------------------------------------------------
while(250 > x > 0):     # Начало цикла с определенным условием (в скобках)
    print(x, end=" = ")     # печатать x, оператор end - не переносить строку.
    # Если строку надо переносить - пишем "\n"
    print(bin(x))   # оператор возврата двоичного код из числа
    x += 100    # прибавлять к x 100 (при изменении знака - вычитать и т.п.)
print(x + 100 + (1 + 1) / 10)   # Печатать то, что внутри скобок

# Цикл for
words = ["cat", "catty", "worldpress"]  # Список (изменяемый), см. ниже.
for x in words:  # Ищет количество букв в словах из списка words
    print(x, "=", len(x), "length", end=", ")  # len - оператор считающий знаки
    # добавляет пернос строки, иначе сливается со следующим из за end.
    print()

# Сравнение двух значений (вывод результата во втором блоке)------------------


def max2(z, a):   # значения зде
    if z > a:     # известными. Они никак не связаны с конкретными переменными
        return z,   # вернуть
    else:           # "Иначе"" (его можно вообще убирать - лишний оператор)
        return a


print(max2("ab", "bc"))   # Параметры берутся из памяти (последние значения,)
# или можно их прописывать числами, или любыми сравниваемыми значениями
# непосредственно здесь, в скобках (если прописать x и y - возьмет из памяти)

hellow2 = "Привет, Василий!"
# Создание строковой переменной

f'{hellow2}'  # f-string, принимающая значение hellow2. Передает содержание
# переменной. на выходе "Привет, Василий!" https://python-scripts.com/f-strings
f'{hellow2=}'  #Строка передает название и значение переменной (новинка P 3.8)
# то есть на выходе: "hellow2 = 'Привет, Василий!'"

name = re.search(r', (.*)!', hellow2)
# имя = бибилиотека re, метод search, (маска разбирающая переменную и ее имя)
if name:
    print(name.group(1))
# печатать группу из полученной переменной name
#
if (name := re.search(r', (.*)!', hellow2)):
    print(name.group(1))
# Тоже самое что в верхнем блоке, но запись с использованием нового оператора
# присваивания ':=' (появился в Питоне 3.8)(PeP не обновился. потому рамка)

# Сформировать функцию---------------------------------------------


def hello(name="World"):    # При пустом значении при вызове функции, (ниже по
    # коду), вызывается то, что в кавычках,
    print("hello", name)    # если значение не пустое - печатается оно


hello()  # Вызывает ранее созданную функцию. Печатает значение переменной по
# умолчанию (см выше)
h = hello   # Переназначение функции на букву (см. ниже)
h("Проверка связи")  # то что внутри скобок добавляется к функции
h()  # Печатает значение переменной по умолчанию, то что в кавычках (см выше)


def some_func(x, y, /):
    # создание функции с позиционным аргументом "/" При его применении значения
    # берутся строго по маске записи. Новинка Пайтон 3.8
    print(x, y)


some_func(1, 2)
# передача в функцию значений по маске. Если в функции стоит "/", вот такую
# запись some_func(x=1, y=2) сделать уже нельзя.
# ----------------------------------------------------------------------------

# Калькулятор (на четрые действия - раскоментировать следующий блок)---------

# n = float(input("Введите первую цифру>  "))
# k = float(input("Введите вторую цифру>  "))
# operation = input("Знак математического действия>  ")
# result = None
# if operation == "+":    # Первый оператор "Если"
#     result = n + k
# elif operation == "-":  # Последующие оперторы "Если"
#     result = n - k
# elif operation == "*":
#     result = n * k
# elif operation == "/":
#     result = n / k
# else:                   # Иначе (можно просто не писать)
#     print("Неизвестное число")
# if result is not None:  # Хрен его знает, откула он знает про is not None
#     print("Результат =", result)
# ----------------------------------------------------------------------------

# Списки. Ключевое отличие - квадратные скобки. Внутри их может быть несколько.
lis = [23, 45.5, "s", [123, 2, 3]]   # Синтаксис создания простых списков
lis.append("Hi")        # Добавление в конец списка
lis = lis + ["!!!"]  # Тоже добавить в конец списка.
lis[1] = 4              # Замена в списке по индексу (индексы начинаются с 0)
lis.insert(1, "Hello")  # вставить в список. Первое значение - индекс
lis.remove(23)          # Удалить из списка
# list(lis1(1, 3, 5)) - покаа не понятно
print(lis)              # Печать списка
print(lis[3][-1])        # Печать значения из списка по индексу. Первое число
# это индекс, второе - либо символ в значении, либо значение из вложенного
# списка. Индексы можно выбирать с конца, если печатать со знаком минус.
print(lis[0:3:2])       # Печать списка по индексам. Откуда: Докуда: Шаг. Можно
# пропускать значения, например [::3] - от начала до конца, каждый третий.

ran = range(1, 10, 2)  # Создание списка от 1 до 10, с шагом 2
print(list(ran))  # печать этого списка, через оператор list

for ra in range(1, 10, 5):  # для последовательности от 1 до 10 с шагом 5,
    print(ra, end=", ")     # создается переменная ra - печатается в столбик.
print()     # для переноса строки после end=","

# Кортеджи (Не редактируемые списки) - ключевое отличие - обычные скобки.
# Используются для экономии памяти. Ну и для стабильности работы программы.
cort = (2, 4, 8, 15, 16, 23, 42, "LOST")
cort1 = 3, 5, 9, 16, 17, 24, 43, "No LOST"
# Скобки можно не использовать, все равно создается кортедж
print(cort, cort1)
print(cort[3])  # значения по индексам, достаются так же как в списках
cort2 = tuple("248151623,42")    # Оператор tuple - Создает кортедж по символам
print(cort2)

# Словари. Те же списки, только используются не индексы, а ключи. Символ {}
di = {"test": 4, "ost": "LOST"}
di1 = dict(shot=8, ne="hlor")   # с использованием переменной dict
di2 = dict.fromkeys([1, "bc", 3], [123, 122])  # всем ключам одно значение.
# в первых скобках - ключи. После запятой - значение. Если единичное - то можно
# значение указывать без квадратных скобок
print(di)
print(di1["ne"])   # вывод не по индексу, а по ключу. Ключь - в кавычках
print(di2[3])   # Либо без кавычек, если это число.

# Множества. Те же списки, но при выводе - значения уникальны. Без повторов.
# Синтаксис - как у словаря. ТО есть те же фигурные скобки, но без ключей
mnojestvo = {"d", "f", "gh", "d", "f", "jlkghdfkjlgh"}
mnojestvo1 = set("HELLO")   # То же самое, но через оператор set
mnojestvo2 = frozenset("ptintjreorej")  # Множество как кортедж,не изменяемое.
# Причем все элементы множества достаются в случайном порядке.
print(mnojestvo)

# ----------------------------------------------------------------------------
# ФУНКЦИИ. Создаются через ключевое слово DEF. Отделяются двумя абзацами с
# каждой стороны


def pr(one, two):  # Внутри скобок передаваемые значения (переменные). Их может
    # и не быть, но тогда внутри функции непонятно с чем их ассоциировать.
    print(one, "!!!+-", two)  # тело функции, то есть что она должна делать.
# Например это - функция печати.
    pass  # Используется тогда, когда функция пустая (не делает ничего) Если
# функция пустая и нет этого оператора, то дает ошибку. Ставят когда создают
# шаблон программы.


def summ(a, b):     # создание функции с переменными значениями в скобках
    res = a + b     # Что делать с переменными
    return res      # что надо вернуть на выходе фукнции. Если бы она ничего не
    # возвращала, то тут стояло бы pass


test = summ(10, 20)  # Вызов функции summ с переменными 10 и 20
pr("Number is", test)  # вызов функции pr. В скобках те самые переменные.

# mult = lambda x, y: x * y  # Упрощенная запись функции через оператор Lambda
# формула - название переменной = Lambda значения : что с ними делать.
# Не соответствует PEP8. Работает.. Но правильне записывать так:


def mult(a, b):
    return a * b  # Вот правильная упрощенная запись вместо lambda. Но для
    # сокращения кода, можно испольщовать и так, как указано выше.


print(mult(2, 5))
# ----------------------------------------------------------------------------

# ООП (Объектно ориентированное программирование)
# - создание классов и объектов, на основе классов.

"""docstring for бла бла бла бла
"""     # Описание (справка). Закрывается тройными кавычками на новой строке.


class Car:  # Создание класса
    name = "None"  # Создание аргументов присущих классу. В качестве значения
    speed = 250  # указываются используемые по умолчанию.

    def set(self, name, speed):  # Создание функции внутри класса.
        # Set - функция установки аргументов, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше


class Premium:
    # Конструктор используемый внутри класса, при создании
    def __init__(self, name, speed):  # Создание функции внутри класса.
        # ___init___ - специальный опретатор, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше
        print(self.name, "имеет Скорость", self.speed)  # форма исполнения
        # см пример на мерседесе.
    # super(obj1, self).__init__()  # Пока не понятно. Это из шаблона

    def set(self, name, speed):  # Создание функции внутри класса.
        # Set - функция установки аргументов, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше


class Light(Car):  # Создание подкласса. Внутри скобок указываются родители.
    # Родителей может быть много, указываются через запятую. Все родительские
    # аргументы и функции доступны ниже, при создании объекта.
    wheels = 4  # дополнительные аргументы подкласса. Доступны только в нем и
    # в его дочерних подклассах.


bmv = Car()  # Создание объекта и назначение ему класса
bmv.set("BMV", 125)  # присвоение аргументов согласно порядку в функции(выше)
print(bmv.name, "едет", bmv.speed, "км в час")  # вывод полученного значения

shkoda = Light()  # Cсоздание объекта из подкласса.
shkoda.wheels = 5  # изменение значения подкласса. Если не менять, то берется
# тот который указан в подклассе, по умолчанию.
shkoda.set("Shkoda", 145)  # Испольование и изменение аргументов из
# родительского класса, если не менять, то берутся по умолчанию.
print(shkoda.name, "имеет", shkoda.wheels, "колеса")

mersedes = Premium("Mersedes", 245)  # Создание объекта с помощью конструктора
# класса, в данном случае - Premium. В конструкторе прописываются все
# необходимые в том числе и действия (в данном примере - print).
mersedes.set("Mersedes-Bentz", 250)  # Изменение аргументов, созданных ранее
print(mersedes.name, "едет", mersedes.speed)

# ПРИМЕЧАНИЕ - создание и конструктором и через функцию set в одном классе,
# либо подклассе - работает, но конструктор должен идти раньше функции set.
# Если надо подкласс формировать не через конструктор, а родитель с
# конструктором, то в него надо вставить пустую функцию конструктора. Такую:
# def __init__(self):
#     pass
# ----------------------------------------------------------------------------
