# //ФУНКЦии. Они же Подпрограммы. Процедуры. Это именованный участок кода, к
# которму можно неоднократно обращаться. Могут принимать параметры (аргументы)
# и возвращать значения. А могут и не возвращать. Когда не возвращает, то на
# самом деле возвращает значение None.

# //Всегда отделяется от кода двумя абзацами сверху и снизу. Создается через
# единый оператор def. После создания может использоваться путем вызова
# множество раз.

# //Есть вшитые функции: int, input, print, id и другие.
# Список и описание функций - https://youtu.be/KSL_32HvBew
# Справка по любой функции вшита. Вызывается help(название функции)


def funct():  # func это название функции. В скобках, ее параметры. Если
    # параметров много, то через ",". Тут формальные параметры. Меняются при
    # вызове (см ниже).
    """ Стока стоящая в самом начале функции - это документация к функции
    """
    # внутри тройных кавычек документация к функции. Закрывающие кавычки
    # ставятся на отдельной строке. Не обязательный параметр.
    pass  # Тут расписывается то, что она делает. То есть сама подпрограмма.


funct()  # а это вызов функции в любм месте кода. Внутри скобок указывается
# локальное значение, то есть то, с каким аргументом она используется. То есть
# фактический параметр. или пустые скобки. Тогда применяется формальный.

# *Сформировать функцию---------------------------------------------


def hello(name="World"):    # При пустом значении при вызове функции, (ниже по
    # коду), вызывается то, что в кавычках,
    print("hello", name)    # если значение не пустое - печатается оно


hello()  # Вызывает ранее созданную функцию. Печатает значение переменной по
# умолчанию (см выше)
h = hello   # Переназначение функции на букву (см. ниже)
h("Проверка связи")  # то что внутри скобок добавляется к функции
h()  # Печатает значение переменной по умолчанию, то что в кавычках (см выше)


def some_func(x, y, /):
    # создание функции с позиционным аргументом "/" При его применении значения
    # берутся строго по маске записи.#// Нов Пайтон 3.8 (из за этого ошибка)
    print(x, y)
    # вот так print(x=10, y=20) - писать нельзя.


some_func(1, 2)
# передача в функцию значений по маске. Если в функции стоит "/", вот такую
# запись some_func(x=1, y=2) сделать уже нельзя.
# ----------------------------------------------------------------------------

# *Калькулятор (на четрые действия - раскоментировать следующий блок)---------

# n = float(input("Введите первую цифру>  "))
# k = float(input("Введите вторую цифру>  "))
# operation = input("Знак математического действия>  ")
# result = None
# if operation == "+":    # Первый оператор "Если"
#     result = n + k
# elif operation == "-":  # Последующие оперторы "Если"
#     result = n - k
# elif operation == "*":
#     result = n * k
# elif operation == "/":
#     result = n / k
# else:                   # иначе (можно просто не писать)
#     print("Неизвестное число")
# if result is not None:  # Хрен его знает, откула он знает про is not None
#     print("Результат =", result)
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# * ФУНКЦи. Создаются через ключевое оператор def. Отделяются двумя абзацами с
# каждой стороны


def pr(one, two, *args):  # Внутри скобок передаваемые значения (переменные).
    # их может и не быть, но тогда внутри функции непонятно с чем их
    # ассоциировать.
    # // *args значит + неопределенное число аргутменов. При этом во время
    # исполнения функции вместо args формируется кортедж из всех лишних
    # переданных аргументов, и уже в функции используется
    # // **args - ознчает что на входе ожидается словарь. Либо он сам будет
    # сформирован из полученных пар ключ/значение "a"=40, "b"=30 итд.
    print(one, "!!!+-", two, *args)  # тело функции, то есть что она должна
    # делать. Например это - функция печати.
    pass  # используется тогда, когда функция пустая (не делает ничего) Если
# функция пустая и нет этого оператора, то дает ошибку. Ставят когда создают
# шаблон программы.


def summ(a, b):     # создание функции с переменными значениями в скобках
    res = a + b     # Что делать с переменными
    return res      # что надо вернуть на выходе фукнции. Если бы она ничего не
    # возвращала, то тут стояло бы pass


ok_stat = 'ok'
test = summ(10, 20)  # Вызов функции summ с переменными 10 и 20
pr("Number is", test)  # вызов функции pr. В скобках те самые переменные.

# //mult = lambda x, y: x * y - Упрощенная запись функции через оператор Lambda
# формула - название переменной = Lambda значения : что с ними делать.
# Не соответствует PEP8. Работает.. Но правильне записывать так:


def mult(a, b):
    return a * b  # Вот правильная упрощенная запись вместо lambda. Но для
    # сокращения кода, можно испольщовать и так, как указано выше.


def mu(*a):  # При такой записи (*a) функция может принимать неопределнное
    # число аргументов. хоть 1 хоть 100 (список), а если **a - то словарь. Если
    # принимается словарь, то запись вида a=10, b='str' итп.
    global ok_stat  # обращение к глобальной переменной
    # nonlocal ok_stat для обращения к нелокальной переменной (используется во)
    # вложенных функциях (функция в функции)
    # Есть области пространства имен: #// local, non-local, global, built-in
    pass


print(mult(2, 5))


# ----------------------------------------------------------------------------

# *ООП (Объектно ориентированное программирование)
# - создание классов и объектов, на основе классов.

"""docstring for бла бла бла бла
"""  # Документация (справка). Вставляется сразу после имени функции, класса.
# Закрывается тройными кавычками на новой строке.


class Car:  # Создание класса
    name = "None"  # Создание аргументов присущих классу. В качестве значения
    speed = 250  # указываются используемые по умолчанию.

    def set(self, name, speed):  # Создание функции внутри класса.
        # Set - функция установки аргументов, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше


class Premium:
    # Конструктор используемый внутри класса, при создании
    def __init__(self, name, speed):  # Создание функции внутри класса.
        # ___init___ - специальный опретатор, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше
        print(self.name, "имеет Скорость", self.speed)  # форма исполнения
        # см пример на мерседесе.
    # super(obj1, self).__init__()  # Пока не понятно. Это из шаблона

    def set(self, name, speed):  # Создание функции внутри класса.
        # Set - функция установки аргументов, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше


class Light(Car):  # Создание подкласса. Внутри скобок указываются родители.
    # Родителей может быть много, указываются через запятую. Все родительские
    # аргументы и функции доступны ниже, при создании объекта.
    wheels = 4  # дополнительные аргументы подкласса. Доступны только в нем и
    # в его дочерних подклассах.


bmv = Car()  # Создание объекта и назначение ему класса
bmv.set("BMV", 125)  # присвоение аргументов согласно порядку в функции(выше)
print(bmv.name, "едет", bmv.speed, "км в час")  # вывод полученного значения

shkoda = Light()  # Cсоздание объекта из подкласса.
shkoda.wheels = 5  # изменение значения подкласса. Если не менять, то берется
# тот который указан в подклассе, по умолчанию.
shkoda.set("Shkoda", 145)  # испольование и изменение аргументов из
# родительского класса, если не менять, то берутся по умолчанию.
print(shkoda.name, "имеет", shkoda.wheels, "колеса")

mersedes = Premium("Mersedes", 245)  # Создание объекта с помощью конструктора
# класса, в данном случае - Premium. В конструкторе прописываются все
# необходимые в том числе и действия (в данном примере - print).
mersedes.set("Mersedes-Bentz", 250)  # изменение аргументов, созданных ранее
print(mersedes.name, "едет", mersedes.speed)

# //ПРиМЕЧАНиЕ - создание и конструктором и через функцию set в одном классе,
# либо подклассе - работает, но конструктор должен идти раньше функции set.
# Если надо подкласс формировать не через конструктор, а родитель с
# конструктором, то в него надо вставить пустую функцию конструктора. Такую:
# def __init__(self):
#     pass
# ----------------------------------------------------------------------------
