# region #* импорт библиотек, работа с библиотеками ---------------------------

import sys     # Простой импорт стандартного модуля sys целиком
import math as ma  # импорт стандартного модуля математических вычислений, с
# переименованием его в модуль ma для дальнейшего использования
import re  # импорт библиотеки разбора фраз, предложений и т.п. по маске
import requests
from lib.mymodule import (max3, hello1)  # импорт одной или нескольких
# переменных из внешенего модуля. После скобок, через оператор as можно его
# переименовать. Здесь для импорта необходимо прописывать пути. В частности
# lib - это папка расположения самого модуля относительно данного файла. Через
# точку, указывается название модуля (файла), затем в скобках или без -
# перечисляются импортируемые функции.
from lib.mymodule import *  # Импорт всех функций из модуля, при этом их можно
# как и в предыдущем примере вызывать по их мобственному имени без lib.mymodule
# но, такой импорт не рекомендуется, чтобы не было совпадений имен + в этом
# случае не импортируются имена начинающиеся с _ (нижнее подчеркивание)
# то есть если в импортируемом модуле есть _модуль то они по * не импортируется
# для выборочного импортирования с помощью * в импортируемом файле применяется
# конструкция __all__, если такая конструкция есть в импортируемом модуле, от
# // __all__ = [name_1_module, name_2_module]
# будут импортированы только указанные в [] модули и больше ничего
import shutil  # библиотека операций с файлами, копирование и т.п.
import operator  # библиотека операторов (+, *, взять последнее из списка итд.)
import functools  # системные функции
import os  # импорт системной библиотеки для виртуальной среды
# // os.path.join('.', 'dirname', 'filename.txt') это './dirname/testname.txt'
# добавление папок в системные

import dotenv  # импорт python-dotenv (см virtualenv.md), создание и вызов
dotenv.load_dotenv()  # системных переменных окружения, паролей из файла .env

sys.path.append('./lib/')  # импорт в проект путей/папок проекта, если это
# необходимо. "./" - текущая папка. "../" - родительская папка.

print(sys.version)  # печать версии системы из модуля sys
print(ma.pi)  # печать числа Пи, из модуля math, сокращенного выше до ma

name = os.getenv('MYNAME')  # присваивание имени из системной переменной (.env)
print(name)

key = os.environ.get('MYKEY')  # присваивание пароля из системной переменной
print(key)

print(os.getcwd())  # распечатать папку проекта
print(os.listdir())  # вывести все папки и файлы в текущей директории
print(os.path.exists('test.py'))  # узнать есть ли.. True/False
print(os.path.isdir('test.py'))  # является ли папкой есть еще isfile. тоже
# возвращает True/False
print(os.path.abspath('test.py'))  # абсолютный путь
# os.chdir() - сменить текущую директорию
# os.walk  - генератор директорий и файлов текущем проекте

print(max3(2, 5))   # Вызов Функции из Внешнего Модуля.
# В Данном Случае Вызыватся Функция Max3 из Модуля Mymodule,

hello1("test")  # вызов функции из внешнего модуля. В данном случае вызыватся
# функция hello1 из модуля mymodule. (в самой функции есть опертаор "print").
# То что стоит в скобках, заменяет параметр по умолчанию, который есть в
# модуле. Если ничего не писать, оставить (), будет использовать значения из
# модуля.

print("""
проверочный текст          #тройными кавычками замыкается текст, чтобы
с условными переносами     #выводить его также как в коде :)
как в коде. Замыкающие обязательно на отдельной строке.
""")
# endregion -------------------------------------------------------------------

# region #* СиНТАКСиС ЯЗЫКА ---------------------------------------------------
# * Операции:
# -----------------------------------------------------------------------------
#   ** возведение в степень (если значение меньше 1 - то корень)
#   >= больше или равно, <= - меньше или равно
#   != не равно
#   // Целочисленное деление. Дает челое число при делении
#   %  остаток после деления
#   x +=2 Прибавить (может быть любая операция /=, %=, **=), цифру после равно
#   == Проверяет равенство, одинаковые ли объекты
#
#   "is" не сравнивает значения, а спрашивает один и тот же это объект или нет
#   Операторы or (или), and(и), not(инверсия значения)
#   if ... in а, if ... not in а опертаторы проверки принадлежности. Если ...
#   есть в списке а, и если ... нет в слове а
#
#   =  Простой оператор присваивания значений переменной
#   := Новый оператор присваивания. используется в if и while (см ниже)
#   << сдвигает биты числа влево на заданное кол-во позиций
#   >> сдвигает биты числа вправо на заданное кол-во позиций
#   &  побитовая операция "и" над числами
#   |  побитовая операция "или" над числами
#   ~  побитовая операция "не" для чисел
#   ^  побтовая операция исключительно "или"
#   not логическое "нет"
#   and логическое "и"
#   or  лигическое "или"
#   dir() запросить имеющиеся у объекта аттрибуты в () название объекта
#
#   sep = "" - убирает пробелы между значениями, и вставляет туда то что в ""
#   end = "" - возможность не переносить строки. Можно добавить символы в ""
#   \n - в операторе print внутри кавычек, перевод строки
# -----------------------------------------------------------------------------
#   pop - удалить последний элемен из списка, стека или к чему он добавляется
#   push - добавить ......
#   clear - очистить
# -----------------------------------------------------------------------------
# (_) - подчеркивание в пустых скобках обозначает предыдущее значение.

# // Приоритет операторов
# ** чем ниже по таблице, темы выше приоритет исполнения
# lambda лямбда-выражение
# or Логическое “ИЛИ”
# and Логическое “И”
# not x Логическое “НЕ”
# in, not in Проверка принадлежности
# is, is not Проверка тождественности
# assert == проверка соответствия (используется при дебаге) и для контроля кода
# raise - обработка исключений (см ниже)
# <, <= , > , >= , != , == Сравнения
# | Побитовое “ИЛИ”
# ^ Побитовое “ИСКЛЮЧИТЕЛЬНО ИЛИ”
# & Побитовое “И”
# <<, >> Сдвиги
# +, - Сложение и вычитание
# / , // , *, % Умножение, деление, целочисленное деление и остаток от деления
# +x, -x Положительное, отрицательное
# ~x Побитовое НЕ
# ** Возведение в степень
# x.attribute Ссылка на атрибут
# x[индекс] Обращение по индексу
# x[индекс1:индекс2] Вырезка
# f(аргументы ...) Вызов функции
# (выражения, ...) Связка или кортеж 2
# [выражения, ...] Список
# {ключ: данные, ...} Словарь

# //идентификатор - имя объекта. Какой то функции, переменной, класса в
# программе. Может состоять из больших и маленьких букв, цифр, знаков
# подчеркивания. Не может начинаться с цифры. Регистр имеет значение. Не может
# совпадать с синтаксисом языка.

# //Переменная - ссылка на какой либо объект. Записывается маленькими буквами
# через знаки подчеркивания: my_variable.

# //Константа - значение не предназначенное для изменения. Принято писать
# большими буквами: MY_CONSTANT. Такое обозначение используется только для себя
# (чтобы случайно не изменить). Чтобы сделать объект доступным только для
# чтения см. курс Essential.

# //Тип данных - определяет возможные значения данных и их смысл. В Python
# используются динамические типы данных. То есть моггут меняться (но это не
# желательно). В большинстве языков - типы задаются и не меняются на протяжении
# всей программы.

# //int, float, complex и другие - тип данных числа.

# //float - число с запятой. Записывется 5.3 или 5. Для больших или маленьких
# чисел используется как возведение в степень через e. Например 5е3 - 5*10 в 3
# степени. Можно возводить и в отрицательную степень, например 5е-3 = 5*10 в
# минус 3 стпени.

# //bool - часть int, для логики. Только 1 или 0. True или False
# соответственно. Всегда пишется с большой буквы.

# //Контейнеры и последовательности str, tuple - неизменные. list - изменяемая.
# None - пустой тип. Объявления переменной не имеющей значения.(с большшой)

# //изменением типа переменных можно преобразовывать строки в числа и наоборот.
# например:
()  # вызов чего то... Если в скобках пусто, то вызов пустых параметров.
# обязательный параметр при создании или вызове функции
stroka = "143"  # Объявление строковой переменной.. То есть она у нас текст.
int(stroka)  # использование данных из строковой переменной как числа.
x = int(43.567)  # создание переменной x типа int, со значением 43 (
# значение после точки отбрасывается)
y = str()  # содание пустой переменной "y" типа str
assert y == str()  # проверка значения при дебаге
print(x)
print(dir(x))  # запросить имеющиеся у объекта атрибуты
s = "Образец длинной строки, которая не помещается в определенный предел PEP8 \
    для того чтобы ее перенести, либо все берется в скобки, либо при переносе \
    строки ставится '\'"

nom = int(stroka)  # Преобразование данных из переменной stroka в целое
# число и в переменную nom, которую уже можно использовать при расчетах и т. п.

type(134)  # вызов класса объекта. В консоли печатает к какому классу
# приналдежит объект. В данном случае - int. В зависимости от содержимого
# может быть string, float, bool, type и т.п.

# Ввод чисел в других системах:
0b01000110100  # - двоичная система. Также для нее есть функция bin()
0o1274653621367  # - восьмеричная система. Есть функция oct()
0x123ABCDEF  # - шестнадцатеричная система. Есть функция hex()

number = 21342134
print(number)

# //Переменные
c = ""  # Простое объявление пустой строковой переменной.
d = int()  # Простое объявление переменной типа int
x = None  # объявление переменной (в данном случае совсем пустой, без типа).
y = 5  # объявление второй переменной. На сей раз тип int
x = 10  # теперь перменной задано значение (в реале может появляться откуда
print(type(c))  # печать типа переменной
# import graphics
# # импорт библиотеки graphics
# window = graphics.GraphWin("Test Window", 100, 100)
# # вызов окна графической оболочки с параметрами
# -----------------------------------------------------------------------------
# ! Раскраска комментариев (плагин Better Comments)
# ? После вопросительного знака
# * После звездочки
# ** после двух звездочек
# // Вот такие два палки в начале, выделяют коментарий

# * Список задач (плагин TODO Tree)
# FIXME: Проверка
# BUG: Проверка
# TODO: Проверка
# HACK: Проверка
# XXX:Проверка
# endregion -------------------------------------------------------------------

# region #* Простое назначение переменных -------------------------------------
x: float = 105     # Назначение переменной x, с типом float
y: int = 110     # Назнечение другой переменной y, с типом int
z = int(43.567)  # создание переменной z типа int, со значением 43, при этом
# значение после точки отбрасывается
a = b = c = 120  # присвоение одного значения трем переменным
a, b, c = 80, 90, 100  # Присвеоение значений по типу кортеджа
first, second, *center, last = [2, 4, 6, 8, 12]  # Создание кортеджа через
#  присваивание. Здесь создаются 3 кортеджа. в первый попадает первое значение
# в последний - последнее. Така как *center с * в него вся середина
print(center)
print(a, b, c, sep="-")  # //sep - разделиттель между словами, одновременно
# убираюший пробелы. Если в кавычках пусто - получаем выражение без пробелов
print(a if a > b else b)  # //по выбору из значения.. используем то, что слева
# от if, если соблюдается условие a > b, иначе - используем то что после else

print(a, b)
print(b, c)
print(x, y)
# все эти три записи, поскольку они однотипные можно записать через for:
for p, z in (a, b), (b, c), (x, y):  # p и z - временные переменные цикла for
    print(p, z)  # котрые подсталяют вместо себя значения которые после in

# -----------------------------------------------------------------------------

x: float = 105     # Назначение переменной x, с типом float
y: int = 110     # Назнечение другой переменной y, с типом int
z = int(43.567)  # создание переменной z типа int, со значением 43, при этом
# значение после точки отбрасывается
strochka = 'stroka'  # Назначение переменной типа str
stroka = str("text_key")  # другая запись того же самого
a = b = c = 120  # присвоение одного значения трем переменным
a, b, c = 80, 90, 100  # Присвеоение значений по типу кортеджа
# endregion

# region #* регулярные выражения и их запись, библиотека "re" -----------------
# // https://stepik.org/lesson/24470/step/2?unit=6776

# // все метасимволы в строках, экранируются от текста через '\' (без кавычек)
# ? . ^ $ * + ? { } [ ] \ | ( ) метасимволы
# любой символ кроме переноса строки подходит под #? '.', которая заменяет
# любой входящий символ. то есть abcdef найдется по ab..ef (без скобок)
# любое количество символов подходят под #? '*', то есть abbbbbc = ab*c, при
# этом если вместо * указать #? "+" то кол-во символов должно быть > 0
# если указать #? "?" то вхождение должно быть или 0 или 1. Если нас интересует
# конкретное количество вхождений символа, то он указывается в #? {} - ab{4}c,
# а если ab{2,4}c - то ищем от 2-х до 4-х

# ? \d - цифры, эквивалентно [0-9], если \D то не цифры, эквивалентно [^0-9]
# ? \s - пробельные символы [ \t\n\r\f\v] и \S наоборот [^ \t\n\r\f\v]
# ? \w - буквы + цифры + _ [a-zA-Z0-9_] и \W наоборот [^a-zA-Z0-9_]
# внутри [] указываются подходящие символы, или диапазон. через '-' [a-zA-Z] (
# как пример такой записи - все буквы английского алфавита). Если внутри []
# стоит ^ это значит что указанный диапазон не подходит [^b-z] или [a-z^A-Z]
# что означает, что подходят только маленькие буквы, а большие - нет.
# ? при сокращенной записи [] не используют "abc[a-zA-Z0-9_]de" = "abc\wde"
# он испольуется при совмещении #? "abc[a-zA-Z0-9_юра]de" = "abc[\wюра]de"

# по умолчанию c + или * является "жадным" и ищет по самому длинному выражению
# форма записи ab[ab]+d - будет искать самые длинные вхождения
# если наборот, надо искать самые короткие вхождения, то вместе с + ставим ? то
# есть запись ab[ab]+?d - будет искать самое короткое вхождение

# метасимволы можно группировать через (), как пример
pattern = r"(test)*"  # ищет любое вхождение фразу в скобках
pattern = r"(test|text)*"  # ищет или test или text, с любым кол-ом вхождений
# символ | (или) можно ставить и вне скобок, например r"abc|(test|text)*"
# c помощью скобок можно группировать как угодно r"((abc)|(test|text)*|(bcd))"
# перед закрытием скобки через \ стоит номер группы которая нам нужна, то есть
pattern = r"((abc)|(test|text)*|(bcd)\2)"  # вызовет вторую группу. группы
# считаются с первой открывающей скобки, 1-я группа - все выражение целиком итд

hellow2 = "Привет, Василий!"  # Создание строковой переменной
pattern = r"abcd, Василий!"
mathc_obj = re.match(pattern, hellow2, re.IGNORECASE)  # проверяет подходит ли
# строка под заданный шаблон, а IGNORECASE говорит игнорировать заглавные буквы
search_obj = re.search(pattern, hellow2)  # ищет вхождение строки в шаблон
# ? символы подходящие под шаблон указываются в []
pattern = r"Пр[ивював]ет[,.-] Василий[!.ура]"  # в [] указываются возможные
# варианты, то есть в средних [] будут проходить и ',' и '.' и '-' а в конечных
# [] и '!' и '.' и 'у' 'р' 'а' (или их сочетание)
find_obj = re.findall(pattern, hellow2)  # ищет все вхождения патерна в строку
sub_obj = re.sub(pattern, "ва", hellow2)  # заменяет все вхождения щаблона на
# то, что указано в " "

hellow2 = "Привет, Василий!"  # Создание строковой переменной

f'{hellow2}'  # f-string, принимающая значение hellow2. Передает содержание
# переменной. на выходе "Привет, Василий!" https://python-scripts.com/f-strings
f'{hellow2=}'  # Строка передает название и значение переменной (новинка P 3.8)
# то есть на выходе: "hellow2 = 'Привет, Василий!'"

name = re.search(r', (.*)!', hellow2)
# имя = бибилиотека re, метод search, (маска разбирающая переменную и ее имя)
if name:  # когда просто # * if name: без всяких условий, сравнений или ==
    # подразумевается "если name == True (то есть оно просто существует)"
    print(name.group(1))  # печатать группу из полученной переменной name

if (name := re.search(r', (.*)!', hellow2)):
    print(name.group(1))
# Тоже самое что в верхнем блоке, но запись с использованием нового оператора
# присваивания ':=' (появился в Питоне 3.8)#//(PeP не обновился. потому ошибка)

# endregion -------------------------------------------------------------------

# region #* Работа со строками ------------------------------------------------
# Строки в Пайтон являются неизменяемыми кортеджами. изменить строку нельзя.
# даже через оператор .replace можно создать новую строку на основе имеющейся
# но нельзя изменить текущую
# ? Все что для строк работает и со списками []. Только списки можно изменять
s = r'Стр.\ntex'  # // raw, сырая строка переносы и спец симв. не применяются
s = "Строка текста"  # создание переменной str
s.find("к")  # поиск в строке элементов к, и вывод индекса начала
s.index('т')  # тоже самое, но дает ошибку если не находит
s.startswith('Стр')  # проверка начинается ли строка с какой то другой строки
s.endswith('та')  # то же самое для конца
s.count("к")  # подсчет кол-ва элементов "к" в строке
s.isdigit()  # является ли строка числом (True или False)
s.isalpha()  # или буквенной строкой
s.lower()  # возвращает строку маленькими буквами
s.upper()  # то же самое большими
# можно совмещать методы например:
print(s.lower().count('с'))  # перевести в нижний и вывести количество букв "c"
s.replace('к', 'К')  # найти и заменить
s1 = s.replace("ка", "ку")  # создание новой строковой переменной (строки
# менять нельзя) с измененим ку на ку, получится Строку текста
s.strip()  # убрать лишние символы. Есть еще lstrip (слева) и rstrip (справа)

if "к" in s:  # поиск элементов к в строке s и резултат bool
    pass
len(s)  # количество символов в строке. У всех символов есть индексы. индекс
# последнего элемента - "-1", второго с конца - "-2" и т.д.
s[0:5]  # вызов строки по индексу с 0-го по 5-й. Принцип работы с индексами
# как у range, только через : и в кв скобках [start:stop:step]. step не
# обязательный параметр. stop - не включительно.
s[0::2]  # печать каждого второго символа (стоп не указан. просто ::)
s[:-1:2]  # то же самое, только без start
s[:]  # с начала до конца, каждый символ.. то есть просто вызвать строку
s[::-1]  # от края до края с шагом -1, то есть в этом случае от конца к началу
s = s[::2] + s[::-2]  # s от края до края с шагом 2 и добавить s от края до
# края с шагом минус 2 (то есть в обратную сторону)
s = "иванов иван иванович"  # создать строковую переменную
sa = s.split()  # формирование списка sa из строки, split - разделяет строку по
# пробелам, и возвращает список
sa[0] = sa[0].upper()  # делает заглавными первое слово (по индексу) списка
# пробелам (см документацию)
s = "-".join(sa)  # собрать обратно строку из списка, в виде разделителей между
# словами указать "-". Основой может быть также кортедж итд. строковые значения
# собирает в принципе все подряд.. Ставится знак разделитель и вперед. Лучше
# использовать ее, # // чем конструкцию типа res+= value в цикле for
# Если список не строковый: #// ''.join(str(x) for x in my_list) здесь join
# перед применением преобразует все в str и с ним работает.
s.format()  # заполняет строку некими отфильтровнными значениями
print(s)
print('{:.5}'.format(s))  # вывести первые 5 знаков из строки
# // есть еще назначение для подстановки значений в типовую строку
capital = "London is a capital of Great Britain"
temlate = "{} is a capital of {}"
print(temlate.format("Moscow", "Russia"))
# можно сделать более правильно и расширенно (индексы с 0):
temlate = "{0} is a capital of {1}, {2}"
print(temlate.format("да пофиг", "Россия", "Москва"))
# или через список
temlate = "{capital} is a capital of {country}, {pofig}"
print(temlate.format(pofig="да пофиг", country="Россия", capital="Москва"))
# endregion -------------------------------------------------------------------

# region # *Списки. квадратные скобки -----------------------------------------
# Внутри, может быть несколько.
# //Списки и массивы.
# Список - тип данных, предстваляющих собой упорядоченную последовательность
# определенных значений, которые могут повторяться. Количество элементов списка
# произвольное. list () Если создавать без генератора, то квадратные скобки
lis = [23, 45.5, "s", [123, 2, 3]]   # Синтаксис создания простых списков. То
# что в отдельных скобках внутри списка - это вложенный список.
list()  # генератор списка - #// lis = list(lis)
# Списки это объекты, и при создании новой ссылки, новый список не создается
lis1 = lis
# если нужно создать новый список на основе имеющегося (скопировать) то надо
# делать это либо на основе коструктора:
lis1 = list(lis)
# либо через оператор copy
lis1 = lis.copy()
# * map
# d,t = map(int, input().split())  #* ввод списка из терминала через map
# считываем 2 int числа через map, от input().split(), где split разбивает ввод
# на 2 строки в одном списке, по умолчанию через пробел.
# такой синтаксис работает только если мы введем число значений равное числу
# определенных переменных (d, t). Иначе ошибка.
# Это можно обойти.. функция map работает по следующему принципу:
# // map делает: func[a, b, c...] = func(f), func(b), func(c)...
# одновеременно, он является итератором, то есть считывает в себя как в объект
# все значения, а затем выдает их по одному.
# // когда неизвесто что введет пользователь можно делать так:
# map_obj = map(int, input().split())  # вводим несколько чисел как в объект
# map1 = next(map_obj)  # вызываем первое введенное значение в новую переменную
# map2 = next(map_obj)  # вызываем следующее введенное значение и т.д.
# тоже самое можно сделать без map
# d, t = (int(i) for i in input().split())  #* тоже самое через for (строка)
# dt = [int(i) for i in input().split()] #* тоже самое но список на выходе
# * filter
# dt = filter(x % 2 == 0, (int(i) for i in input().split()))
# //пропускает введенные значение через фильтр (либо можно дать готовый список)
# либо вместо x % 2 == 0, сослаться на готовую функцию
# такой же итератор как и map, и также работает через методы list и т.п.
# dt = list(filter(func, dt) - #// отфильтровать значения и сделать список

lis2 = lis[::-1]  # создание перевернутой (поскольку -1) выборки lis и
#  копирование ее в новый список lis2
lis2[:] = lis  # // перезаписать в списке lis2 значения из списка lis (замена)
pr = lis.pop()  # записать последнее значение списка в переменную pr и рор
# то есть удалить его из списка. В скобках указывается индекс списка
lis[1] = 4  # Замена в списке по индексу (индексы начинаются с 0)
lis[2]  # вызов значения из списка по индексу
ind = lis2.index(23)  # узнать индекс по значению
lis.insert(1, "Hello")  # вставить в список. Первое значение - индекс
lis.append("Hi")        # Добавление в конец списка, без указания индекса
lis = lis + ["!!!"] + [23] + [46]  # Тоже добавить в конец списка.
lis.remove(23)  # Удалить из списка первое найденное значение "23"
lis.pop(2)  # удаление из списка по индексу, в скобках индекс
# list(lis1(1, 3, 5)) - пока не понятно
# Обращение к списку по индексу через [], то что в скобках всегда индекс. При
# этом [top] - это последний заполненный элемент в списке
print(lis)  # Печать списка как он есть (в скобках)
print(lis2)  # lis2 был создан как копия lis, после чего lis менялся. lis2 нет
print(*lis)  # печать только значений из списка (развернутый список)
lis2[0:3] = ["замена", "элементов", "списка"]  # сделать выборку из списка по
# индексам с 0 до 2-го и заменить эти значения на соответствующие после =
lis2[0:3] = []  # удалить индексы 0, 1, 2 из списка
lis2[0] = [1, 2, 3, 4, 5]  # добавить элементы в начало списка. все следующие
# индексы сдвинутся.
# ? Простые числовые списки можно суммировать, искать максимум и т.п.
lis2 = [1, 2, 3, 4, 5, 6]
lis3 = reversed(lis2)  # тоже создание нового перевернутого из текущего списка
lis2.reverse  # инвертирование списка (родительского), без создания нового
set(lis2)  # создание сета (перечень уникальных значений) списка
# // сортировка списков (возможна только если значения однотипные)
lis2.sort()  # сортровка самого списка без создания нового
ls_srt = sorted(lis2)  # новый список сортированный по значению
su = sum(lis2)  # суммировать все значения в списке
min(lis2)  # найти максимальное значение в списке
max(lis2)  # найти минимальное значение в списке
lis2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  # Создание двухмерного списка (типа)
# таблицы, из вложенных списков. Где первая тройка - верхняя строка, средняя -
# средняя, и последняя - нижняя. Отличия, вызов значения по индексу пересечений
lis2[1][1]  # в данном случае вызывается значение по пересечению индекса 1 в
# строке (первый индекс) и индекса 1 в столбце (второй индекс)
print(lis[3][-1])        # Печать значения из списка по индексу. Первое число
# это индекс, второе - либо символ в значении, либо значение из вложенного
# списка. индексы можно выбирать с конца, если печатать со знаком минус.
print(lis[0:3:2])       # Печать списка по индексам. Откуда: Докуда: Шаг. Можно
# пропускать значения, например [::3] - от начала до конца, каждый третий.
sa = s.split()  # формирование списка из строки.
# endregion -------------------------------------------------------------------

# region #* Кортеджи (Не редактируемые списки) - обычные скобки ---------------
# Массив - набор фиксированного количества однотипных элементов, расположенных
# в памяти непосресдственно друг за другом, доступ к которым осуществляется по
# их индексу. - array(). Не могут меняться. Только пересозадваться.
# используются для экономии памяти. Ну и для стабильности работы программы.
cort = (2, 4, 8, 15, 16, 23, 42, "LOST")
cort1 = 3, 5, 9, 16, 17, 24, 43, "No LOST"
# Скобки можно не использовать, все равно создается кортедж
print(cort, cort1)

print(cort[3])  # значения по индексам, достаются так же как в списках
cort2 = tuple("248151623,42")    # Оператор tuple - Создает кортедж по символам
print(cort2)
# endregion -------------------------------------------------------------------

# region #* Словари. Те же списки, но используются не индексы, а ключи. {} ----
# // Словари редактируемы. Не имеют порядка. Ключи уникальны, не изменяемы
dict, {}  # создание пустого словаря
dict()  # тоже создание пустого словаря
di = {"test": 4, "ost": "LOST"}
di1 = dict(shot=8, ne="hlor")   # с использованием переменной dict
di2 = dict.fromkeys([1, "bc", 3], [123, 122])  # всем ключам одно значение.
# в первых скобках - ключи. После запятой - значение. Если единичное - то можно
# значение указывать без квадратных скобок
# // Операции со словарями
"test" in di  # Проверка есть ли ключ в словаре
4 not in di  # Проверка есть ли значение в словаре
di["trulyalya"] = 4  # Добавить в словарь ключ и его значение
di["trulyalya"]  # проверка есть ли в словаре ключ. Кавычки имеют значение.
di.get("dfkjgndk")  # Вызов значения по ключу. Если его нет, вернет None
del di["ost"]  # удалить ключ и значение
print(di)
print(di1["ne"])   # вывод не по индексу, а по ключу. Ключь - в кавычках
print(di2[3])   # Либо без кавычек, если это число.
di3 = {"z": 4, "a": 3}
print(max3(**di3))  # передача значений из списка в функцию (имена аргументов)
# должны совпадать. тогда ** значит передать все аргументы по типу key:value
# endregion -------------------------------------------------------------------

# region #* Множества. Cпискиc уникальными значениями, без повторов -----------
set()  # Генератор множества #// lib = set(lis)  из строки/списка в множество
# Синтаксис - как у словаря. То есть те же фигурные скобки, но без ключей
mnojestvo = {"d", "f", "gh", "d", "f", "jlkghdfkjlgh"}
mnojestvo1 = set("HELLO")   # То же самое, но через оператор set
mnojestvo2 = frozenset("ptintjreorej")  # Множество как кортедж,не изменяемое.
# Причем все элементы множества достаются в случайном порядке.
"jlkghdfkjlgh" in mnojestvo  # проверка есть ли такой объект в множестве, дает
# ответ True или False. Делается чере #// оператор in
# Методы #//add('element'), remove(), discard() - remove без проверки, clear()
print(mnojestvo)
lib = set(lis)  # из строки / списка в множество
# endregion -------------------------------------------------------------------

# region #* Операции с файлами ------------------------------------------------
# ? Ключи =====================================================================
# "r" только для чтения (по умолчанию)
# "w" открыть для записи, содержимое файла стирается
# a(append) открыть для записи, запись идет в конец файла
# b (binary) открыть в бинарном режиме
# t (text) открыть в текстовом режиме (по умолчанию)
# r+ открыть для чтения и записи
# w+ чтение и запись, при этом содержимое файла стирается
# ? ===========================================================================
inf = open('test.txt', "r")
s0 = inf.read(5)  # чтение из файла первых 5 символов
s1 = inf.readline()  # чтение одной строки из файла
s1 = s1.rstrip()  # убрать все ведущие пробельные символы справа, вт.ч. перенос
# такую запись можно применять при считывании (см s2)
s2 = inf.readline().rstrip  # чтение второй строки без лишних символов и т.д
s00 = inf.read()  # считывание файла до конца
s = inf.readline().strip()
# убрать все служебные символы при чтении строки '\t abs  \n'.strip() > 'abs'
s = s.splitlines()  # тоже самое, то есть убрать управляющие символы и разбить
# по строкам как список (каждая строка - элемент списка)
print(repr(s00))  # оператор #? repr - печатать все что считано как строку
inf.close()  # закрытие файла, чтобы освободить рессурсы
# -----------------------------------------------------------------------------

with open('test.txt') as inf:  # При таком открытии инфо считывается и файл
    s1 = inf.readline()  # сразу закрывается. Считанная инфо остается в памяти
    s2 = inf.readline()

# // Можно считывать через цикл for -------------------------------------------
with open("test.txt") as inf:  # Функция читающая весь файл
    for line in inf:
        line = line.rstrip()
        print(repr(line))
    s = inf.read()
# -----------------------------------------------------------------------------

# * Открытие файла для записи -------------------------------------------------

ouf = open("test.txt", "w")  # порядок открытия для записи в файл
ouf.write('Some text\n')  # файла может и не быть, питон его создаст
ouf.write(str(25))

# для того чтобы не ставить перносы вручную надо создать содержимое файла через
# метод join:
lines = ['Line1', 'Line2', 'Line 3']
cont = "\n".join(lines)  # ? метод склеивания списка в строку через знак в " "
ouf.write(cont)
ouf.close

with open('test.txt', 'a') as ouf:  # При таком открытии идет открытие, запись
    ouf.write('Some text\n')  # в конец, и закрытие файла
    ouf.write(str(25))
# конструкцию with можно использовать для нескольких файлов, в т.ч. открывая их
# и на чтение и на запись, по форме:
# // with open('file1' 'r') as file1, open('file2' 'w') as file2:
# //    for line in file1:
# //        file2.write(line)


# * форматы файлов
""" под каждый формат файла существует своя библиотетка, даже на самые простые
типа JSON или CSV (таблица с разделением запятыми)
"""
# endregion--------------------------------------------------------------------

# ! Запуск файла --------------------------------------------------------------
# * если импорт библиотеки, то все что ниже этой формулировки не исполняется
# потому что name = main только внутри самого файла. Если вызывать его извне
# как модуль, то его имя с main меняется на его название
# Если модуль импортирован, то его __name__ это название модуля. Если же просто
# запустить сам модуль, то его __name__ - это "__main__"
if __name__ == "__main__":
    print('modul started', __name__)  # имя модуля = __main__
else:
    print('module imported', __name__)  # имя модуля = имя файла (модуля)
# При такой вставке если модуль импортирован, будет вывод 2-й строки. Если
# запущен самостоятельно - то первой.

# * ---------------------------------------------------------------------------
# ! файл __init__.py
# * если данный файл находится в папке, значит папка является пакетом. В нем
# находится информация что именно и в каком порядке необходимо импортировать
