# region #* импорт библиотек, работа с библиотеками ---------------------------
""" https://www.youtube.com/watch?v=vqsalStEu38 """
import sys  # Простой импорт стандартного модуля sys целиком. Доступ к методам
# при этом sys.metod_name()
import requests  # импорт внешней библиотеки

import math as ma  # импорт стандартного модуля математических вычислений, с
# переименованием его в модуль ma. для дальнейшего использования

import re  # импорт библиотеки разбора фраз, предложений и т.п. по маске

# импорт одной или нескольких переменных из внешенего модуля. После скобок,
# через оператор as можно его переименовать. Здесь для импорта необходимо
# прописывать пути. В частности lib - это папка расположения самого модуля
# относительно данного файла. Через точку, указывается название модуля (файла),
# затем в скобках или без - перечисляются импортируемые функции.
from lib.mymodule import (max3, hello1)

from lib.mymodule import *  # Импорт всех функций из модуля, при этом их можно
# как и в предыдущем примере вызывать по их мобственному имени без lib.***
# _Целесообразно при пакетном импорте через __init__.py (см ниже)
# но, такой импорт не рекомендуется, чтобы не было совпадений имен + в этом
# случае не импортируются имена начинающиеся с _ (нижнее подчеркивание)
# то есть если в импортируемом модуле есть _модуль то он по * не импортируется
# для выборочного импортирования с помощью * в импортируемом файле применяется
# конструкция __all__, если такая конструкция есть в импортируемом модуле, от
# // __all__ = [name_1_module, name_2_module] будут импортированы только
# указанные в [] модули и больше ничего.

import shutil  # библиотека операций с файлами, копирование и т.п.
import operator  # библиотека операторов (+, *, взять последнее из списка итд.)
import functools  # системные функции
import os  # импорт системной библиотеки для виртуальной среды
# // os.path.join('.', 'dirname', 'filename.txt') это './dirname/testname.txt'
# добавление папок в системные

import dotenv  # импорт python-dotenv (см virtualenv.md), создание и вызов
dotenv.load_dotenv()  # системных переменных окружения, паролей из файла .env

# уделение импортированного ранее модуля, чтобы освободить пространство имен
del requests

sys.path.append('./src')
# импорт в проект путей/папок проекта"./" - текущая папка. "../" - родительская
# Кроме путей могут быть импортиованы zip архивы.. И из них - модули.
# При импорте модуля, sys.path обходит пути слева на право.
print(sys.path)
"""
Модуль это файл с расширением py. Каждый модуль задаёт свое пространство имён,
атрибуты которого соответствуют именам, определённым в файле.
Имя файла, всегда имя модуля, кроме случая когда он запущен самостоятельно.
Тогда - __name__ = __main__.

Для импорта большого количества модулей их упаковывают в папку, нызываемую
пакетом. В ней создается файл __init__.py, в котором указан порядок импорта
всех/или не всех находящихся там модулей. Пакеты могут быть вложенными, и иметь
в себе другие пакеты.

Задача модуля __init__.py - инициировать пакет. Логику в нем реализовывать не
надо. Можно либо оставлять пустым, либо объявить глобальные переменные, либо
организовать через него упорядоченный импорт модулей из данного пакета.
Пути лучше указывать относительные #_ from .module_name import *, где "." перед
именем модуля - импорт из текущей дирректории.

Как правильный вариант - в __init__ импортируются все содержащиеся в пакете
модули с относительными путями "." и через "*":
#_ from .module1 import *
При необходимости, в каждом импортиремом модуле определяется свой собственный
__all__, а затем в __init__.py определяется фасад пространства имен пакета:
#_ __all__ = module_1.__all__ + module_2.__all__
После такой подготовки пакет может быть импортирован в основной файл, а все
вызовы по нему будут идти
#_ packet_name.function_name()
Плюсы такого метода, в основном модуле не надо прописывать пути импорта. Пакет
импортируется по имени папки, внутри него __init__.py содержит необходимые
импорты уже с относительными путями. + формируется уникальное и обобщенное
пространство имен пакета
Пример смотри ./lib/__init__.py
"""
""" Для того чтобы сам пакет запускать как 1 файл, внутри него должен лежать
__main__.py. Когда он есть внутри пакета, команда из консоли
#_ python -m packet_name
запускает код, находящийся в файле __main__.py, так, будто мы вызвали его. +
дополнительно, исполняется код инициации пакета __init__.py
"""

print(sys.version)  # печать версии системы
print(ma.pi)  # печать числа Пи, из модуля math, сокращенного выше до ma

name = os.getenv('MYNAME')  # присваивание имени из системной переменной (.env)
print(name)
# или
key = os.environ.get('MYKEY')  # присваивание пароля из системной переменной
print(key)

print(os.getcwd())  # распечатать папку проекта
print(os.listdir())  # вывести все папки и файлы в текущей директории
print(os.path.exists('test.py'))  # узнать есть ли.. True/False
print(os.path.isdir('test.py'))  # является ли папкой есть еще isfile. тоже
# возвращает True/False
print(os.path.abspath('test.py'))  # абсолютный путь
# os.chdir() - сменить текущую директорию
# os.walk  - генератор директорий и файлов текущем проекте

print(max3(2, 5))   # Вызов Функции из Внешнего Модуля.
# В Данном Случае Вызыватся Функция Max3 из Модуля Mymodule,

hello1("test")  # вызов функции из внешнего модуля. В данном случае вызыватся
# функция hello1 из модуля mymodule. (в самой функции есть опертаор "print").
# То что стоит в скобках, заменяет параметр по умолчанию, который есть в
# модуле. Если ничего не писать, оставить (), будет использовать значения из
# модуля.

print("""
проверочный текст          #тройными кавычками замыкается текст, чтобы
с условными переносами     #выводить его также как в коде :)
как в коде. Замыкающие обязательно на отдельной строке.
""")
# endregion -------------------------------------------------------------------

# region #* Синтаксис языка ---------------------------------------------------
# * Операции:
# help(print)  # вызов хелпа для любой имеющейся функции, класса, метода
# -----------------------------------------------------------------------------
#   ** возведение в степень (если значение меньше 1 - то корень)
#   >= больше или равно, <= - меньше или равно
#   != не равно
#   / простое деление. На выходе всегда float, даже если результат целое число
#   // Целочисленное деление. Дает целое число при делении
#   %  остаток после деления
#   * умножение. Также применяется для строк (напечатать одно и тоже n раз)
#   + Сложение для цифр и конкотинация для строк, списков, кортеджей итд.
#   x +=2 Прибавить (может быть любая операция /=, %=, **=), цифру после равно
#   == Проверяет равенство, одинаковые ли объекты
#   "is" не сравнивает значения, а спрашивает один и тот же это объект или нет
#   Операторы or (или), and(и), not(инверсия значения)
#   if ... in а, if ... not in а опертаторы проверки принадлежности. Если ...
#   есть в списке а, и если ... нет в слове а
#   _  назначение переменной, которая неважна. При множественном присваивании
#   *_ произвольное количество неважных элементов
#   =  Простой оператор присваивания значений переменной
#   := Новый оператор присваивания. используется в if и while (см WebNet)
#   << сдвигает биты числа влево на заданное кол-во позиций
#   >> сдвигает биты числа вправо на заданное кол-во позиций
#   &  побитовая операция "и" над числами
#   |  побитовая операция "или" над числами. Также является оператором слияния
#      в словарях. с = {a:"a", b:"b"} | {c:"c", d:"d"} - слив в новый словарь с
#   |= обновление словаря a |= b добавить ключи из и в существующий словарь a
#   ~  побитовая операция "не" для чисел
#   ^  побтовая операция исключительно "или"
#   not логическое "нет"
#   and логическое "и"
#   or  логическое "или". Ленивое выражение. Если то что слева от or
#       выполняется, дальше интерпритатор не проверяет.
#   in, not in - Проверка принадлежности
#   in  внутри (в циклах for, if, while итд.)
# _ print(), type(), dir(), id(), len() - применяются ко всем типам данных
#   dir() запросить имеющиеся у объекта аттрибуты в () название объекта
#   dis.dis() вывести на ассемблере как исполняется то или иное действие
#   sep = "" - убирает пробелы между значениями, и вставляет туда то что в ""
#   end = "" - возможность не переносить строки. Можно добавить символы в ""
#   \ экранирование символов. Кавычек, знаков переноса, и т.д.
#   \' одинарная кавычка,
#   \" двойная кавычка,
#   \t символ вертикальной табуляции,
#   \n символ переноса строки,
#   \xhh символ с HEX кодом hh
#
# -----------------------------------------------------------------------------
#   pop - удалить последний элемен из списка, стека или к чему он добавляется
#   reversed - отразить итерируемый объект зеракльно
#   push - добавить ......
#   clear - очистить
#   break - принудительно выйти из цикла
#   continue - принудительно пропустить оставшийся код на одном круге цикла
#   exit - завершить программу принудительно
#   exec - выполнить введенный код в любом случае. ОПАСНО!
#   eval - выполнить введенный код в любом случае. ОПАСНО!
# -----------------------------------------------------------------------------
# (_) - подчеркивание в пустых скобках обозначает предыдущее значение.
# py -i имя_файла.py - запуск файла в интерактиве (>>> после исполнения)
# // Приоритет операторов
# ** чем ниже по таблице, темы выше приоритет исполнения
# lambda лямбда-выражение
# or Логическое “ИЛИ”
# and Логическое “И”
# not x Логическое “НЕ”
# in, not in Проверка принадлежности
# is, is not Проверка тождественности
# assert == проверка соответствия (используется при дебаге) и для контроля кода
# raise - обработка исключений (см ниже)
# <, <= , > , >= , != , == Сравнения
# | Побитовое “ИЛИ”
# ^ Побитовое “ИСКЛЮЧИТЕЛЬНО ИЛИ”
# & Побитовое “И”
# <<, >> Сдвиги
# + Сложение для цифр и конкотинация для строк, списков, кортеджей итд.
# - вычитание для цифр.
# / , // , *, % деление, целочисленное деление, умножение, и остаток от деления
# +x, -x Положительное, отрицательное
# ~x Побитовое НЕ
# ** Возведение в степень
# x: int определение типа в атрибутах функции, метода (типизация языка)
# -> int что должны получить на выходе (типизация языка)
# x.attribute Ссылка на атрибут
# x[индекс] Обращение по индексу
# x[индекс1:индекс2] Вырезка
# f(аргументы ...) Вызов функции
# (выражения, ...) Связка или кортеж 2
# [выражения, ...] Список
# {ключ: данные, ...} Словарь

# // CRUD - create, read, update, delete
# все програмирование основано на двух слонах. Данные и их модификация. CRUD
# это 4 стандартных действия которые совершаются с любыми данными

# //идентификатор - имя объекта. Какой то функции, переменной, класса в
# программе. Может состоять из больших и маленьких букв, цифр, знаков
# подчеркивания. Не может начинаться с цифры. Регистр имеет значение. Не может
# совпадать с синтаксисом языка.

# //Переменная - ссылка на какой либо объект. Записывается маленькими буквами
# через знаки подчеркивания: my_variable.

# //Константа - значение не предназначенное для изменения. Принято писать
# большими буквами: MY_CONSTANT. Такое обозначение используется только для себя
# (чтобы случайно не изменить). Чтобы сделать объект доступным только для
# чтения см. курс Essential.

# //Тип данных - определяет возможные значения данных и их смысл. В Python
# используются динамические типы данных. То есть моггут меняться (но это не
# желательно). В большинстве языков - типы задаются и не меняются на протяжении
# всей программы.

# //int, float, complex и другие - тип данных числа.

# //float - число с запятой. Записывется 5.3 или 5. Для больших или маленьких
# чисел используется как возведение в степень через e. Например 5е3 - 5*10 в 3
# степени. Можно возводить и в отрицательную степень, например 5е-3 = 5*10 в
# минус 3 стпени.

# //bool - часть int, для логики. Только 1 или 0. True или False
# соответственно. Всегда пишется с большой буквы.

# //Контейнеры и последовательности str, tuple - неизменные. list - изменяемая.
# None - пустой тип. Объявления переменной не имеющей значения.(с большшой)

# //изменением типа переменных можно преобразовывать строки в числа и наоборот.
# например:
()  # вызов чего то... Если в скобках пусто, то вызов пустых параметров.
# обязательный параметр при создании или вызове функции
stroka = b"143"  # Объявление строковой, байтовой переменной..
b"143".decode('utf-8')  # перевод байтовой строки в другую кодировку
stroka = "143"  # Объявление строковой переменной.. То есть она у нас текст.
int(stroka)  # использование данных из строковой переменной как числа.
res = float('inf')  # бесконечно большое число (используется в функциях)
res = float('-inf')  # бесконечно малое число (используется в функциях)
float(140)  # приведение к типу данных. Также с int, str, list итп.
int(5.9)  # приведение к int путем отбрасывания остатка
x = int(43.567)  # создание переменной x типа int, со значением 43 (
# значение после точки отбрасывается)
y = str()  # содание пустой переменной "y" типа str
assert y == str()  # проверка значения при дебаге
x = 40 if x < 40 else 35  # назначение переменной по условию
print('hello' if x > 40 else "huylo")  # печать по условию
print(dir(x))  # запросить имеющиеся у объекта атрибуты
x, y = y, x  # поменять местами значения переменных

s = "Образец длинной строки, которая не помещается в определенный предел PEP8 \
    для того чтобы ее перенести, либо все берется в скобки, либо при переносе \
    строки ставится '\'"
print(s)

# _ (Если не хватает длины строки, все выражение берется в скобки, и тогда
# _ Пайтон понимает, что это единая строока). Пример
print(name,
      key)

nom = int(stroka)  # Преобразование данных из переменной stroka в целое
# число и в переменную nom, которую уже можно использовать при расчетах и т. п.

round(nom)  # округление чисел по правилам математики. Доп-но можно указать до
# какого знака после запятой округлять, для этого 2-й аргумент round(float, 4)

type(134)  # вызов класса объекта. В консоли печатает к какому классу
# приналдежит объект. В данном случае - int. В зависимости от содержимого
# может быть string, float, bool, type и т.п. Также в () можно вставлять имя
# переменной, чтобы узнать какой класс сейчас в ней присутствует

id(stroka)  # вызов id (уникальный идентификатор) ранее созданного объекта

# Ввод чисел в других системах:
0b01000110100  # - двоичная система. Также для нее есть функция bin()
0o1274653621367  # - восьмеричная система. Есть функция oct()
0x123ABCDEF  # - шестнадцатеричная система. Есть функция hex()

number = 21342134
print(number)

# //Переменные
c = ""  # Простое объявление пустой строковой переменной.
d = int()  # Простое объявление переменной типа int
x = None  # объявление переменной (в данном случае совсем пустой, без типа).
y = 5  # объявление второй переменной. На сей раз тип int
x = 10  # теперь перменной задано значение (в реале может появляться откуда
print(type(c))  # печать типа переменной
# import graphics
# # импорт библиотеки graphics
# window = graphics.GraphWin("Test Window", 100, 100)
# # вызов окна графической оболочки с параметрами
# -----------------------------------------------------------------------------
# Коментарии над блоком кода, сначала объяснение что делает код, затем сам код.
# ! Раскраска комментариев (плагин Better Comments)
# ? После вопросительного знака
# * После звездочки
# ** после двух звездочек
# // Вот такие два палки в начале, выделяют коментарий
# _ После нижнего подчеркивания

# * Список задач (плагин TODO Tree)
# FIXME: Проверка
# BUG: Проверка
# TODO: Проверка
# HACK: Проверка
# XXX:Проверка
# endregion -------------------------------------------------------------------

# region #* Простое назначение переменных -------------------------------------
"""Переменные в пайтон это не объекты, а лишь ссылки на созданные объекты.
Несколько переменных могут ссылаться на один и тот же объект
При этом объекты бывают не изменяемыми (числа, строка, кортедж) и изменяемыми
(список, словарь). Когда меняется материнский объект у числа, наследник
указывает на старый объект, а для материнского создается новый. Если объект
изменяемый, то новый оъект не создается, а потому и родитель и наслединик
всегда ссылаются на один и тот же объект. Если необходимо внести изменения в
изменяемый объект (список) и не трогать родителя, то делается копия"""
x: float = 105     # Назначение переменной x, с типом float
y: int = 110     # Назнечение другой переменной y, с типом int
z = int(43.567)  # создание переменной z типа int, со значением 43, при этом
# значение после точки отбрасывается
res = float('inf')  # бесконечно большое число. база для операций сравнения.
res = float('-inf')  # бесконечно малое число. база для операций сравнения.
w = 100_000_000  # метод записи разрешен для длинных чисел.
r = 100_100.000_001  # такая запись тоже допустима
""" Есть еще 2 типа данных.. Decimal тип чисел, позволяет работать с
вещественными числами с фиксированной точностью, и модуль fractions, который
позволяет работать с рациональными числами, проще говоря с дробями"""
a = b = c = 120  # присвоение одного значения трем переменным
del(a)  # удаление переменной из памяти

#  _множественное присваивание работает слева направо:
a, b, c = 80, 90, 100  # Присвеоение значений по типу кортеджа
a, (a, c) = 90, (80, 100)  # а будет = 80, так как вычисляется слева направо
"""
# _Ключевые аргументы, аналогично позиционным,можно упаковывать/распаковывать
упаковку/распаковку через '*' можно использовать вместе со всем чем угодно.
Для распаковки словарей - '**'
"""
center = (*range(5), 6)  # кортедж (1,2,3,4,6)
first, second, *center, last = [2, 4, 6, 8, 12]  # Создание списка через
#  присваивание. Здесь создаются 4 кортеджа. в первый попадает первое значение,
# во второй - второе, в последний - последнее. Така как *center с * в него все
# что осталось в середине
first, *center, last = range(8)  # тоже самое через генератор
#  _множественное присваивание через *, ** также работает в циклах (for).
print(center)


print(a, b, c, sep="-")  # //sep - разделиттель между словами, одновременно
# убираюший пробелы. Если в кавычках пусто - получаем выражение без пробелов
print(a if a > b else b)  # //по выбору из значения.. используем то, что слева
# от if, если соблюдается условие a > b, иначе - используем то что после else
id(x)  # вызов уникального идентификатора объекта
print(a, b)
print(b, c)
print(x, y)
# все эти три записи, поскольку они однотипные можно записать через for:
for p, z in (a, b), (b, c), (x, y):  # p и z - временные переменные цикла for
    print(p, z)  # котрые подсталяют вместо себя значения которые после in

# -----------------------------------------------------------------------------
xy = None  # путое значение. Объект ничего.
x: float = 105     # Назначение переменной x, с типом float
y: int = 110     # Назнечение другой переменной y, с типом int
z = int(43.567)  # создание переменной z типа int, со значением 43, при этом
# значение после точки отбрасывается
strochka = 'stroka'  # Назначение переменной типа str
stroka = str("text_key")  # другая запись того же самого
a = b = c = 120  # присвоение одного значения трем переменным
a, b, c = 80, 90, 100  # Присвеоение значений по типу кортеджа
locals()  # вызов функции выводящей все доступных на момент вызова переменные и
# их значений
# endregion -------------------------------------------------------------------

# region #* Итераторы, модуль itertools ---------------------------------------
""" Итераторы, это люьые итерируемые объекты. Строки, списки, словари и вообще
все, что можно вызывать один за другим..
Использует методы __inter__ и __next__.
Встроен в строки, списки и любые другие итерируемые объекты.
Для облегчения работы с итераторами есть модуль itertools. Его методы:
.islice(xs, 0, 3, 2) - слайс на произвольный итератор (xs, start, stop, step)
.count - бесконечная последовательность индекса с указанным шагом (0,10,20...)
.cicle - бесконечный круг последжовательности (1,2,3,1,2,3,1,2,3...)
.repeat - бесконечная константа (42,42,42,42...)
.dropwhile - выкидывает элементы из итератора, пока условие выполняется
.takewhile - достает элементы из итератора, пока условие выполняется
.chain - конкатинирует(складывает) произвольное число итерторируемых объектов
.tee - копирует итератор. Говорит сколько сделать независимых итераторов
Также в модуле itertools реализованы декартово произведение, перстановки и т.п.
"""
# endregion -------------------------------------------------------------------

# region #* Работа со строками. str() -----------------------------------------
""" Строки в Пайтон являются неизменяемыми кортеджами. изменить строку нельзя.
даже через оператор .replace можно создать новую строку на основе имеющейся но
нельзя изменить текущую. То есть если я сделаю print(a.upper()), в момент вызов
интерпритатор переведет регистр. и тут же об этом забудет. следующий print(a)
выведет изначальное значение a, без перевода в верхний регистр. Чтобы дейст-но
изменить переменную a, надо сделать a = a.upper()
"""
# _ Все что для строк работает и со списками []. Только списки можно изменять
s = r'Стр.\ntex'  # // raw, сырая строка. Переносы и спец симв. не применяются
s = ""  # содание переменной s с типом данных строка ("" - литерал строки)
s = b"hello"  # перевод строки в байтовый вид. Только ASSCI символы
encode = "привет".encode(encoding="utf-8")  # перевод в байты (универсальный)
encode = "привет".encode()  # тоже самое. utf-8 кодировка по умочанию
decode = encode.decode()  # обратный перевод в читаемый вид
stranno = "str" "anno"  # строковые литералы склеиваются выход "stranno"
s = "Строка текста"  # создание переменной str
# _ Предикаты (проверка является ли строка):
s.isdigit()  # является ли строка числом (True или False)
s.isalpha()  # или буквенной строкой
s.isalnum()  # или смесь букв и цифр
# такжы все другие: .islower, .istitle, .isuper, isspace и другие на .is
s.find("к")  # поиск в строке элементов к, и вывод индекса начала
s.index('т')  # тоже самое, но дает ошибку если не находит
s.startswith('Стр')  # проверка начинается ли строка с какой то другой строки
s.endswith('та')  # то же самое для конца
s.count("к")  # подсчет кол-ва элементов "к" в строке
s.lower()  # возвращает строку маленькими буквами
s.upper()  # то же самое большими
s.title()  # Первые Буквы В Словах Большие
s.title().swapcase()  # пОМЕНЯТЬ бООЛЬШИЕ и мАЛЕНЬКИЕ
s.startswith("э")  # проверяет начинается ли строка с буквы
s.capitalize()  # делает заглавной первую букву в строке
"HelloWorld".removesuffix("World")  # удаляет суфикс (вторую часть)
"HelloWorld".removeprefix("Hello")  # удаляет префикс (первую часть)
# _ можно совмещать методы например:
print(s.lower().count('с'))  # перевести в нижний и вывести количество букв "c"
s.replace('к', 'К')  # найти и заменить
s1 = s.replace("ка", "ку")  # создание новой строковой переменной (строки
# менять нельзя) с измененим ку на ку, получится Строку текста
s.strip()  # убрать лишние символы. Есть еще lstrip (слева) и rstrip (справа)
""" метод strip может принимать аргументы. то что в () то и будет убираться,
например, если в (';') - он уберет все символы ';', остальное не тронет"""
s.ljust(3, '-')  # выровнять строку в блоке. Добавить 3 символа '' слева (rjust
# справа, center выровнять по центру). Если '' не указано .rjust(3) - то пробел
if "к" in s:  # поиск элементов к в строке s и резултат bool
    pass
len(s)  # количество символов в строке. длина строки
# // Срезы строк
# У всех символов есть индексы. индекс первого элемента - 0, вторгого 1
# последнего элемента "-1", второго с конца - "-2" и т.д.
s[0:5]  # вызов строки по индексу с 0-го по 5-й. Принцип работы с индексами
# как у range, только через : и в кв скобках [start:stop:step]. step не
# обязательный параметр. stop - не включительно.
s[0::2]  # вызов каждого второго символа (стоп не указан. просто ::)
s[:-1:2]  # то же самое, только без start
s[:]  # с начала до конца, каждый символ.. то есть просто вызвать строку
s[::-1]  # от края до края с шагом -1, от конца к началу. инвертировать строку
s = s[::2] + s[::-2]  # s от края до края с шагом 2 и добавить s от края до
# края с шагом минус 2 (то есть в обратную сторону)
translation_map = {ord("a"): "*", ord("b"): "?"}  # маска для замены символов
"abracadabra".translate(translation_map)  # использование маски для замены
s = "иванов иван иванович"  # создать строковую переменную
sa = s.split()  # формирование списка sa из строки, split - разделяет строку по
# пробелам, и возвращает список, в () указывается символ по которому делить.
# Можно указывать максимальное количество разделений. Еще есть rsplit (справа)
s.partition(',')  # возвращает кортедж из 3-х элементов. Подстрока до ','  сам
# ',' и то, что после ','. rpartition - тоже самое но точка отсчета справа
sa[0] = sa[0].upper()  # делает заглавными первое слово (по индексу) списка
# пробелам (см документацию)
"".join(sa)  # простая сборка строки из списка. Можно комбинировать с filter
s = "-".join(sa)  # собрать обратно строку из списка, в виде разделителей между
# словами указать "-". Основой может быть также кортедж итд. строковые значения
# собирает в принципе все подряд.. Ставится знак разделитель и вперед. Лучше
# использовать ее, # // чем конструкцию типа res+= value в цикле for
# Если список не строковый: #// ''.join(str(x) for x in my_list) здесь join
# перед применением преобразует все в str и с ним работает.
# * форматирование строк - заполнение частей строки некими значениями.
# устаревший метод. Новый:
# https://docs.python.org/3/reference/lexical_analysis.html#f-strings
template = "%s - главное достоинство програмиста. (%s)"
print(template % ("Лень", "Larry Wall"))
# %s операторы подстановки. Указаны в шаблоне, определены по порядку при вызове
# Обозначают: %s - строка. %d - число
# * + Есть два метода. format и f-string нотация
s.format()  # заполняет строку некими отфильтровнными значениями
print(s)

# _ совмещение с преобразованием объекта в строки:
print("{} хороший товарищ {}".format("Вася", "Пети"))  # Внутри {} можно
# также указать способ преобразования объекта в строку и спецификацию формата
"{!s}".format('hello')  # преобразовать объект в строку {!r} repr, {!a} ascii
print('{:.5}'.format(s))  # вывести первые 5 знаков из строки

# // есть еще назначение для подстановки значений в типовую строку
capital = "London is a capital of Great Britain"
temlate = "{} is a capital of {}"
print(temlate.format("Moscow", "Russia"))
# можно сделать более правильно и расширенно (индексы с 0):
temlate = "{0} is a capital of {1}, {2}"
print(temlate.format("да пофиг", "Россия", "Москва"))
# или через список
temlate = "{capital} is a capital of {country}, {pofig}"
print(temlate.format(pofig="да пофиг", country="Россия", capital="Москва"))
# _ f-string тоже самое, что format только без вызова метода format:
# кроме этого f-string позволяют выполнять внутри себя математические операции
capital = "Moscow"
country = "Russia"
pofig = "да пофиг"
print(f"{capital} is a capital of {country}, {pofig}")

# _модификаторы форматирования указываются через #.
num = 8
print(f"Binary 8 is: {num:#b}")  # вернуть в бинарном виде
print(f"is: {num:#3f}")  # вывести 3 знака после точки
print(f"2 * x = {2 * x}")  # то что в {} - вычисляется, то что не в них вывод.
# endregion -------------------------------------------------------------------

# region # *Списки. Литерал- [], list() ---------------------------------------
# _Списки - изменяемый тип данных. Внутри, могуть быть числа, строки, вложенные
# списки, иные типы данных
# // Распаковка списка при передаче как аргумент в функцию - через *
# Список - тип данных, предстваляющих собой упорядоченную последовательность
# определенных значений, которые могут повторяться. Количество элементов списка
# произвольное. list () Если создавать без генератора, то квадратные скобки
lis = [0] * 4  # на выходе [0, 0, 0, 0]
# Данные в списке разложены по индексам. Каждый элемент списка имеет индекс от
# 0 до ... Первый элем-т "0", второй "1". Последний "-1", предпослений "-2" итп
lis = [23, 45.5, "s", [123, 2, 3]]   # Синтаксис создания простых списков. То
# что в отдельных скобках внутри списка - это вложенный список.
list()  # генератор списка - #// lis = list(lis)
# Списки это объекты, и при создании новой ссылки, новый список не создается
lis1 = lis  # если нужно создать новый список (скопировать) то надо делать это
# либо на основе коструктора:
lis1 = list(lis)
# либо через оператор copy
lis1 = lis.copy()
lis2 = lis[::-1]  # создание перевернутой (поскольку -1) выборки lis и
#  копирование ее в новый список lis2
lis2[:] = lis  # // перезаписать в списке lis2 значения из списка lis (замена)
pr = lis.pop(-1)  # записать последнее значение списка в переменную pr и рор
# то есть удалить его из списка. В скобках указывается индекс списка. По
# умолчанию, если () - то последний элемент. Можно просто удалять lis.pop()
lis[1] = 4  # Замена в списке по индексу (индексы начинаются с 0)
lis[2]  # вызов значения из списка по индексу
ind = lis2.index(23)  # узнать индекс по значению
lis.insert(1, "Hello")  # вставить в список. Первое значение - индекс. ДОРОГО!
lis.append("Hi")  # Добавление в конец списка, одного элемента. Если добавить
# несколько, или добавить список - то добавляется как вложенный элемент [[],[]]
lis.extend(lis2)  # расширение первого списка за счет (..) без вложенности [,,]
# вместо extend можно +, то есть запись соответствует lis + lis2. ДОРОГО!!!
# _append получение табличного списка, extend - получение плоского списка
list(zip(lis1, lis2))  # склеивание списков (1-й эл-т 1-го с 1-м эл-том 2-го)
lis + [1, 2, 3, 4]  # + не сохраняют в текущий список. Только в новую (или
# текущую) переменную, то есть это строковый оператор, со всеми вытекающими
lis = lis + ["!!!"] + [23] + [46]  # Тоже добавить в конец списка. ДОРОГО!!!
lis.remove(23)  # Удалить из списка первое найденное значение "23"
ls = lis.pop(2)  # удаление из списка по индексу, и вернуть удаленное в ls
lis5 = list(lis1[0:-1:2])  # сделать копию списка по индексу через []
print(lis)  # Печать списка как он есть (в скобках)
print(lis2)  # lis2 был создан как копия lis, после чего lis менялся. lis2 нет
print(*lis)  # печать только значений из списка (развернутый список)
lis2[0:3] = ["замена", "элементов", "списка"]  # сделать выборку из списка по
# индексам с 0 до 2-го и заменить эти значения на соответствующие после =
lis2[0:3] = []  # удалить индексы 0, 1, 2 из списка
lis2[0] = [1, 2, 3, 4, 5]  # добавить элементы в начало списка. все следующие
# индексы сдвинутся. Дорогая операция.
lis2 = lis2 + [6, 7, 8]  # добавить в конец списка (конкатинация). ДОРОГО!
list(reversed([1, 2, 3, 4]))  # развернет создаваемый список зеркально
lis2 = [1, 2, 3, 4, 5, 6]
lis3 = reversed(lis2)  # создание нового перевернутого из текущего списка
lis2.reverse()  # инвертирование списка (родительского), без создания нового
lis2 = lis2[::-1]  # инверитровать список в его копию
set(lis2)  # создание сета (перечень уникальных значений) списка
# // сортировка списков (возможна только если значения однотипные)
lis2.sort()  # сортровка самого списка без создания нового
ls_srt = sorted(lis2)  # новый список сортированный по значению
""" sorted - возвращает новый упорядоченные список. sort - возвращает тот же
самый список, но уже отсортированный. Оба могут принимать аргументы, то есть
указание как именно сортировать (создаются с помощью функций, циклов и т.п)
https://www.youtube.com/watch?v=7tFOlqHlP-E
"""
children = ['ivanov_2000', 'petrov_1990', 'sidorov_2005']
# создаем список фамилия_год рождения. задача отсортировать по году


def sort_year(name):
    """ функция принимает элемент списка (строку ivanov_2000), делает из строки
    по знаку (_) список из элементов ['ivanov', '2000'] и возвращает последний
    по индексу элемент [-1] """
    return name.split('_')[-1]


sort_children = sorted(children, key=sort_year)
""" key - ключ сортировки через созданную выше функцию, поэлементно сортирует
список по значению в функции передавая туда список по элементно"""
print(sort_children)
# ---------------------------------------------------------------------------
# _ Простые числовые списки можно суммировать, искать максимум и т.п.
su = sum(lis2)  # суммировать все значения в списке
min(lis2)  # найти максимальное значение в списке
max(lis2)  # найти минимальное значение в списке
lis2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  # Создание двухмерного списка (типа)
# таблицы, из вложенных списков. Где первая тройка - верхняя строка, средняя -
# средняя, и последняя - нижняя. Отличия, вызов значения по индексу пересечений
lis2[1][1]  # в данном случае вызывается значение по пересечению индекса 1 в
# строке (первый индекс) и индекса 1 в столбце (второй индекс)
print(lis2[2][-1])        # Печать значения из списка по индексу. Первое число
# это индекс, второе - либо символ в значении, либо значение из вложенного
# списка. индексы можно выбирать с конца, если печатать со знаком минус.
print(lis[0:3:2])       # Печать списка по индексам. Откуда: Докуда: Шаг. Можно
# пропускать значения, например [::3] - от начала до конца, каждый третий.
sa = s.split()  # формирование списка из строки.
lis.clear()  # очистить список
# endregion -------------------------------------------------------------------

# region #* Кортеджи (tuple) - Литерал (). slice() ----------------------------
# Массив - набор фиксированного количества однотипных элементов, расположенных
# в памяти непосресдственно друг за другом, доступ к которым осуществляется по
# их индексу. - array(). Не могут меняться. Только пересозадваться.
# используются для экономии памяти. Ну и для стабильности работы программы.
cort = (2, )  # кортедж из 1-го элемента. Если не поставить , - строка или int
cort = (2, 4, 8, 15, 16, 23, 42, "LOST")
cort1 = 3, 5, 9, 16, 17, 24, 43, "No LOST"
# Скобки можно не использовать, все равно создается кортедж
print(cort, cort1)

print(cort[3])  # значения по индексам, достаются так же как в списках
cort2 = tuple("248151623,42")    # Оператор tuple - Создает кортедж по символам
print(cort2)

# _ использование именованых slice. Такой же принцип для всех итеррируемых
"""Именованные слайсы создаются, чтобы во множестве однотипных кортеджей не
доставать значения по индексам для каждого из них. Например при наличии
множества кортеджей со значением (имя, фамилия, день, месяц, год рождения)
Для этого делаются объекты типа slice, которым присваивается шаблон выборки,
как в примере ниже, слайс FIRST достает элементы с 0-го по 2-й не включительно,
имя и фамилия, а слайс SECOND с 2-го и до конца кортеджа, дата рождения"""
NAME, DATE = slice(2), slice(2, None)  # синтаксис slice(start, stop, step)
petrov = ("Andrey", "Petrov", "Mart", 25, 1990)
sidorov = ("Sergey", "Sidorov", "Aprel", 1, 1987)
print(petrov[NAME])
print(sidorov[DATE])
"""для вызова, именованный слайс используется как индекс итеррируемого объекта
"""
# endregion -------------------------------------------------------------------

# region #* Словари.  Литерал {}, dict() --------------------------------------

# // Те же списки, но используются не индексы, а ключи. итерируемый, изменяемый
# тип объектов. Редактируемы. Не имеют порядка. Ключи уникальны, не изменяемы
# // Распаковка словаря при передаче как аругмент в функцию - через **

dic = {}  # создание пустого словаря
dic = dict()  # тоже создание пустого словаря
di = {"test": 4, "ost": "LOST"}
di1 = dict(shot=8, ne="hlor")   # с использованием переменной dict
di2 = dict.fromkeys([1, "bc", 3], [123, 122])  # всем ключам одно значение.
# в первых скобках - ключи. После запятой - значение. Если единичное - то можно
# значение указывать без квадратных скобок. Если не указать вторую пару, всем
# ключам будет присвоено None
di3 = dict.fromkeys(["abc", "def", "gh"])  # ключам abc, def и gh значение None
di3 = dict.fromkeys("abcd", 0)  # ключам a, b, c и d значение 0

# // Операции со словарями
"test" in di  # Проверка есть ли ключ в словаре
4 not in di  # Проверка есть ли значение в словаре
di["trulyalya"] = 4  # Добавить в словарь ключ и его значение
dicsliv = dic | di  # слить два соваря вместе в новый словарь dicsliv
dic |= di  # обновление существующего словаря dic. Добавлять (в правую часть)
# можно и итерируемый объект, а не готовый словарь

# _ информацию из словарей достают двумя методами:
d = di['test']  # вызов по ключу словаря, записьь значения в переменную d
d = dic.get(key)  # Вызов значения по ключу. Если его нет, вернет None
"""первый, по литералу d = dic[key] при отсутсвии в словаре искомого ключа дает
исключение. Второй d = dic.get(key) при отстутсвии дает просто значение None.
При этом вместо None, вторым аргументом можно указать умолчание. То есть то что
даст вызов если искомого ключа не оказалось в словаре. dic.get(key, default)"""
d = di.get("key", 'default_value')
# кроме get есть метод update, он обновляет имеющиеся значение словаря и
# добавляет новые значения, если на момент исполнения их там нет
dic.update(key='default_value_new', key_1='default_value_1')  # вместо
# именованых аргументов можно передавать другой словарь, список, любой
# итерируемый объект

# // проверка наличия значений в словfре производится по форме:
"value" in di.values()  # возвращает True, False. Аналогично для key, item
di.items()  # вызов коллекции всех пар из словаря
di.keys()  # вызов коллекции ключей из словаря

"""если необходимо найти ключ в словаре, а если его там нет, и имеется
#_ необходимость его создать, существует метод:"""
d = di.setdefault("key", 'set_default_value')

di["trulyalya"]  # проверка есть ли в словаре ключ. Кавычки имеют значение.
del di["ost"]  # удалить ключ и значение
print(di)
print(di1["ne"])   # вывод не по индексу, а по ключу. Ключь - в кавычках
print(di2[3])   # Либо без кавычек, если это число.
di3 = {"z": 4, "a": 3}
print(max3(**di3))  # передача значений из списка в функцию (имена аргументов)
# должны совпадать. тогда ** значит передать все аргументы по типу key:value

# _ словари = итерируемые объекты и их можно крутить в циклах for
"""у каждого словаря есть методы items, keys, value итп, которые можно крутить
в цикле и доставать значения."""
for value in di.values():
    print(value)
"""можно доставать пары значений (как enumerate в списках), а не по одному,
через метод items"""
for key, value in di.items():
    print(key, value)

for k in set(di):
    """Чтобы добавлять/изменять значения по итерируемому словарю, надо создать
    его копию через set()"""
    del di[k]

"""Ключи и значения в словарях хранятся в неупорядоченном виде. Если необходимо
хранить по порядку добавления, метод - from collections import OrderedDict """
# endregion -------------------------------------------------------------------

# region #* Множества. Литерал {}, set() Cписки c уникальными значениями ------
set()  # Генератор множества #// lib = set(lis)  из строки/списка в множество
# Синтаксис - как у словаря. То есть те же фигурные скобки, но без ключей
frosen = frozenset("12345")  # замороженное, не изменяемое множество
mnojestvo = {"d", "f", "gh", "d", "f", "jlkghdfkjlgh"}
mnojestvo1 = set("HELLO")   # То же самое, но через оператор set
mnojestvo2 = frozenset("ptintjreorej")  # Множество как кортедж,не изменяемое.
# Причем все элементы множества достаются в случайном порядке.
"jlkghdfkjlgh" in mnojestvo  # проверка есть ли такой объект в множестве, дает
# ответ True или False. Делается чере #// оператор in
# Методы #//add('element'), remove(), discard() - remove без проверки, clear()
print(mnojestvo)
lib = set(cort)  # из строки/списка/кортеджа в множество
set.union(mnojestvo, mnojestvo1)  # объединить множества в одно (+)
set.intersection(mnojestvo, mnojestvo2)  # mnogestvo &(or) mnogestvo1
set.difference(mnojestvo, mnojestvo1)  # mnogestvo -(minus) mnogestvo1
mnojestvo.add('add element')  # добавление одного элемента
print(mnojestvo)
mnojestvo.update(["update element"], "0987")  # добавление множества элементов
print(mnojestvo)
mnojestvo.remove("0")  # уделение, если элемента нет - исключение
mnojestvo.discard("128471029")  # удаление. если элемента нет - pass
# endregion -------------------------------------------------------------------

# region #* Операции с файлами ------------------------------------------------
# доступные пути можно посмотреть командой print(sys.path)
# модуль io - для работы с текстовыми и бинарными данными.

# _ Ключи =====================================================================
# "r" только для чтения (по умолчанию)
# "w" открыть для записи, содержимое файла стирается
# "rb" только для чтения, бинарный файл
# "wb" открыть для записи бинарный файл, содержимое файла стирается
# a(append) открыть для записи, запись идет в конец файла
# b (binary) в бинарном режиме (вторая часть второго аргумента "rb", "wb" итп)
# t (text) открыть в текстовом режиме (по умолчанию) 2-я часть 2-го аргумента
# r+ открыть для чтения и записи
# w+ чтение и запись, при этом содержимое файла стирается
# _ ===========================================================================
inf = open('./src/test.txt', "r")
"""метод open сначала ищет файл, и если второй аргумент 'r', то либо его
открывает, либо выдает исключение. Если второй аргумент 'w', то создает этот
файл.
Python имеет 3 метода ввода/вывода (I/O). Text IO, Binary IO, Raw IO
"""
""" Просто открытия файла не достаточно, чтобы добраться до содержащейся в нем
информации. Для этого эту информацию необходимо прочитать
"""
s0 = inf.read(5)  # чтение первых 5 символов. Если () то читает целиком файл
s1 = inf.readline()  # чтение одной строки из файла
sall = inf.readlines()  # чтение всех строк файла, возвращает список строк.
s1 = s1.rstrip()  # убрать все ведущие пробельные символы справа, вт.ч. перенос
# такую запись можно применять при считывании (см s2)
s2 = inf.readline().rstrip  # чтение второй строки без лишних символов и т.д
s00 = inf.read()  # считывание файла до конца
s = inf.readline().strip()
# убрать все служебные символы при чтении строки '\t abs  \n'.strip() > 'abs'
s = s.splitlines()  # тоже самое, то есть убрать управляющие символы и разбить
# по строкам как список (каждая строка - элемент списка)
print(repr(s00))  # оператор #_ repr - печатать все что считано как строку
inf.close()  # закрытие файла, чтобы освободить рессурсы
# -----------------------------------------------------------------------------

with open('./src/test.txt') as inf:  # инфо считывается и файл
    s1 = inf.readline()  # сразу закрывается. Считанная инфо остается в памяти
    s2 = inf.readline()

# // Можно считывать через цикл for -------------------------------------------
with open("./src/test.txt") as inf:  # Функция читающая весь файл
    for line in inf:
        line = line.rstrip()
        print(repr(line))
    s = inf.read()
# -----------------------------------------------------------------------------

# * Открытие файла для записи -------------------------------------------------
""" открытие файла для записи происхожит по ключу "w". При этом исходное
содержимое, после чтения, стирается. Чтобы этого не происходило есть метод
октрытия файлов - .a (append), в этом режиме идет дозаписывание новой инфо в
конец файла."""
ouf = open("./src/test.txt", "w")  # порядок открытия для записи в файл
""" метод write для записи в файловые объекты. Аргументы для write - "строка"
При этом в момент write идет запись в буфер. Физическая запись происходит либо
при закрытии файла .close(), либо через метод .flush(), как ctrl-S"""
ouf.write('Some text\n')  # файла может и не быть, питон его создаст
ouf.write(str(25))

# для того чтобы не ставить перносы вручную надо создать содержимое файла через
# метод join:
lines = ['Line1', 'Line2', 'Line 3']
cont = "\n".join(lines)  # _метод склеивания списка в строку через знак в " "
ouf.write(cont)
ouf.close

with open('./src/test.txt', 'a') as ouf:  # При таком открытии идет открытие
    ouf.write('Some text\n')  # запись в конец, и закрытие файла
    ouf.write(str(25))
# конструкцию with можно использовать для нескольких файлов, в т.ч. открывая их
# и на чтение и на запись, по форме:
# // with open('file1' 'r') as file1, open('file2' 'w') as file2:
# //    for line in file1:
# //        file2.write(line)


# * форматы файлов
""" под каждый формат файла существует своя библиотетка, даже на самые простые
типа JSON или CSV (таблица с разделением запятыми)
"""
# _ пример октрытия и копирования картинки (бинарного файла)
pic = './src/test_pic.jpg'  # присваиваем переменной pic объект файл
file = open(pic, "rb")  # открываем файл в режиме чтения бинарных данных
new_file = open(pic + "_copy.jpg", "wb")  # создание нового файла по маске
new_file.write(file.read())  # запись в новый файл данных, прочитанных из pic

# _ запись результатов работы скрипта в файл
# py имя_файла.py > log.txt

"""#_ Поток Python соджержит 3 системных файла. sys.stdin - поток входа,
sys.stdout - поток выхода, и sys.stderr - поток ошибок. Они всегда открыты в
текстовом режиме. input(), print() - работают именно с этими файлами. Но, с
ними также можно работать через стандартные операторы работы с файлами read()
write() и т.п."""

# ! Запуск файла --------------------------------------------------------------
# * если импорт библиотеки, то все что ниже этой формулировки не исполняется
# потому что name == main только внутри самого файла. Если вызывать его извне
# как модуль, то его имя с main меняется на его название
# Если модуль импортирован, то его __name__ это название модуля. Если же просто
# запустить сам модуль, то его __name__ - это "__main__"
if __name__ == "__main__":
    print('modul started', __name__)  # имя модуля = __main__
else:
    print('module imported', __name__)  # имя модуля = имя файла (модуля)
# При такой вставке если модуль импортирован, будет вывод 2-й строки. Если
# запущен самостоятельно - то первой.
"""https://www.youtube.com/watch?v=cW_-zGG4ef4
Интепритатор читает код сверху вниз и затем последовательно исполняет весь тот
код, который находит в скриптах. Перед тем как начать исполнение, он определяет
несколько встроенных переменных. В том числе __name__. Это служебная переменная
хранит в себе имя модуля. Если имя __name__ == __main__, это означает, что
модуль был запущен самостоятельно. Иначе, при запуска через импорт или как то
еще, __name__ будет равным имени модуля (файла).
"""

# * ---------------------------------------------------------------------------
# ! файл __init__.py
# * если данный файл находится в папке, значит папка является пакетом. В нем
# находится информация что именно и в каком порядке необходимо импортировать
# endregion--------------------------------------------------------------------
