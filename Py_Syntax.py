# region  СиНТАКСиС ЯЗЫКА
# * Операции:
# -----------------------------------------------------------------------------
#   ** возведение в степень (если значение меньше 1 - то корень)
#   >= больше или равно, <= - меньше или равно
#   != не равно
#   // Целочисленное деление. Дает челое число при делении
#   %  остаток после деления
#   x +=2 Прибавить (может быть любая операция /=, %=, **=), цифру после равно
#   == Проверяет равенство, одинаковые ли объекты
#
#   "is" не сравнивает значения, а спрашивает один и тот же это объект или нет
#   Операторы or (или), and(и), not(инверсия значения)
#   if ... in а, if ... not in а опертаторы проверки принадлежности. Если ...
#   есть в списке а, и если ... нет в слове а
#
#   =  Простой оператор присваивания значений переменной
#   := Новый оператор присваивания. используется в if и while (см ниже)
#
#   sep = "" - убирает пробелы между значениями, и вставляет туда то что в ""
#   end = "" - возможность не переносить строки. Можно добавить символы в ""
#   \n - в операторе print внутри кавычек, перевод строки
# -----------------------------------------------------------------------------
#   pop - удалить последний элемен из списка, стека или к чему он добавляется
#   push - добавить ......
#   clear - очистить
# -----------------------------------------------------------------------------
# import graphics
# # импорт библиотеки graphics
# window = graphics.GraphWin("Test Window", 100, 100)
# # вызов окна графической оболочки с параметрами
# -----------------------------------------------------------------------------
# ! Раскраска комментариев (плагин Better Comments)
# ? После вопросительного знака
# * После звездочки
# ** после двух звездочек
# // Вот такие два палки в начале, выделяют коментарий
# endregion

# -----------------------------------------------------------------------------

import sys     # Простой импорт стандартного модуля sys целиком
import math as ma  # импорт стандартного модуля математических вычислений, с
# переименованием его в модуль ma для дальнейшего использования
import re  # импорт библиотеки разбора фраз, предложений и т.п. по маске

from lib.mymodule import (max3, hello1)  # импорт одной или нескольких
# переменных из внешенего модуля. После скобок, через оператор as можно его
# переименовать. Здесь для импорта необходимо прописывать пути. В частности
# lib - это папка расположения самого модуля относительно данного файла. Через
# точку, указывается название модуля (файла), затем в скобках или без -
# перечисляются импортируемые функции.
from lib.mymodule import *  # Импорт всех функций из модуля, при этом их можно
# как и в предыдущем примере вызывать по их мобственному имени без lib.mymodule
# но, такой импорт не рекомендуется, чтобы не было совпадений имен + в этом
# случае не импортируются имена начинающиеся с _ (нижнее подчеркивание)
# то есть если в импортируемом модуле есть _модуль то они по * не импортируется
# для выборочного импортирования с помощью * в импортируемом файле применяется
# конструкция __all__, если такая конструкция есть в импортируемом модуле, от
# // __all__ = [name_1_module, name_2_module]
# будут импортированы только указанные в [] модули и больше ничего

import os  # импорт системной библиотеки для виртуальной среды
import dotenv  # импорт python-dotenv (см virtualenv.md), создание и вызов
dotenv.load_dotenv()  # системных переменных окружения, паролей из файла .env

sys.path.append('./lib/')  # импорт в проект путей/папок проекта, если это
# необходимо. "./" - текущая папка. "../" - родительская папка.

print(sys.version)  # печать версии системы из модуля sys
print(ma.pi)  # печать числа Пи, из модуля math, сокращенного выше до ma

name = os.getenv('MYNAME')  # присваивание имени из системной переменной (.env)
print(name)

key = os.environ.get('MYKEY')  # присваивание пароля из системной переменной
print(key)

print(max3(2, 5))   # Вызов Функции из Внешнего Модуля.
# В Данном Случае Вызыватся Функция Max3 из Модуля Mymodule,

hello1("test")  # вызов функции из внешнего модуля. В данном случае вызыватся
# функция hello1 из модуля mymodule. (в самой функции есть опертаор "print").
# То что стоит в скобках, заменяет параметр по умолчанию, который есть в
# модуле. Если ничего не писать, оставить (), будет использовать значения из
# модуля.

print("""
проверочный текст          #тройными кавычками замыкается текст, чтобы
с условными переносами     #выводить его также как в коде :)
как в коде. Замыкающие обязательно на отдельной строке.
""")

# -----------------------------------------------------------------------------

#
# //СиНТАКСиС
# (_) - подчеркивание в пустых скобках обозначает предыдущее значение.

# //идентификатор - имя объекта. Какой то функции, переменной, класса в
# программе. Может состоять из больших и маленьких букв, цифр, знаков
# подчеркивания. Не может начинаться с цифры. Регистр имеет значение. Не может
# совпадать с синтаксисом языка.

# //Переменная - ссылка на какой либо объект. Записывается маленькими буквами
# через знаки подчеркивания: my_variable.

# //Константа - значение не предназначенное для изменения. Принято писать
# большими буквами: MY_CONSTANT. Такое обозначение используется только для себя
# (чтобы случайно не изменить). Чтобы сделать объект доступным только для
# чтения см. курс Essential.

# //Тип данных - определяет возможные значения данных и их смысл. В Python
# используются динамические типы данных. То есть моггут меняться (но это не
# желательно). В большинстве языков - типы задаются и не меняются на протяжении
# всей программы.

# //int, float, complex и другие - тип данных числа.

# //float - число с запятой. Записывется 5.3 или 5. Для больших или маленьких
# чисел используется как возведение в степень через e. Например 5е3 - 5*10 в 3
# степени. Можно возводить и в отрицательную степень, например 5е-3 = 5*10 в
# минус 3 стпени.

# //bool - часть int, для логики. Только 1 или 0. True или False
# соответственно. Всегда пишется с большой буквы.

# //Контейнеры и последовательности str, tuple - неизменные. list - изменяемая.
# None - пустой тип. Объявления переменной не имеющей значения.(с большшой)


# //изменением типа переменных можно преобразовывать строки в числа и наоборот.
# например:
()  # вызов чего то... Если в скобках пусто, то вызов пустых параметров.
# обязательный параметр при создании или вызове функции
stroka = "143"  # Объявление строковой переменной.. То есть она у нас текст.
int(stroka)  # использование данных из строковой переменной как числа.
x = int(43.567)  # создание переменной x типа int, со значением 43 (
# значение после точки отбрасывается)
y: str()  # содание пустой переменной "y" типа str
print(x)

nom = int(stroka)  # Преобразование данных из переменной stroka в целое
# число и в переменную nom, которую уже можно использовать при расчетах и т. п.

type(134)  # вызов класса объекта. В консоли печатает к какому классу
# приналдежит объект. В данном случае - int. В зависимости от содержимого
# может быть string, float, bool, type и т.п.

# Ввод чисел в других системах:
0b01000110100  # - двоичная система. Также для нее есть функция bin()
0o1274653621367  # - восьмеричная система. Есть функция oct()
0x123ABCDEF  # - шестнадцатеричная система. Есть функция hex()

number = 21342134
print(number)

# //Переменные
c = ""  # Простое объявление пустой строковой переменной.
d = int()  # Простое объявление переменной типа int
x = None  # объявление переменной (в данном случае совсем пустой, без типа).
y = 5  # объявление второй переменной. На сей раз тип int
x = 10  # теперь перменной задано значение (в реале может появляться откуда

# *Простое назначение переменных ----------------------------------------------
x: float = 105     # Назначение переменной x, с типом float
y: int = 110     # Назнечение другой переменной y, с типом int
z = int(43.567)  # создание переменной z типа int, со значением 43, при этом
# значение после точки отбрасывается
a = b = c = 120  # присвоение одного значения трем переменным
a, b, c = 80, 90, 100  # Присвеоение значений по типу кортеджа
first, second, *center, last = [2, 4, 6, 8, 12]  # Создание кортеджа через
#  присваивание. Здесь создаются 3 кортеджа. в первый попадает первое значение
# в последний - последнее. Така как *center с * в него вся середина
print(center)
print(a, b, c, sep="-")  # //sep - разделиттель между словами, одновременно
# убираюший пробелы. Если в кавычках пусто - получаем выражение без пробелов
print(a if a > b else b)  # //по выбору из значения.. используем то, что слева
# от if, если соблюдается условие a > b, иначе - используем то что после else

print(a, b)
print(b, c)
print(x, y)
# все эти три записи, поскольку они однотипные можно записать через for:
for p, z in (a, b), (b, c), (x, y):  # p и z - временные переменные цикла for
    print(p, z)  # котрые подсталяют вместо себя значения которые после in

# -----------------------------------------------------------------------------

x: float = 105     # Назначение переменной x, с типом float
y: int = 110     # Назнечение другой переменной y, с типом int
z = int(43.567)  # создание переменной z типа int, со значением 43, при этом
# значение после точки отбрасывается
strochka = 'stroka'  # Назначение переменной типа str
stroka = str("text_key")  # другая запись того же самого
a = b = c = 120  # присвоение одного значения трем переменным
a, b, c = 80, 90, 100  # Присвеоение значений по типу кортеджа

# * Работа со строками и списками
# Строки в Пайтон являются неизменяемыми кортеджами. изменить строку нельзя.
# даже через оператор .replace можно создать новую строку на основе имеющейся
# но нельзя изменить текущую
s = "Строка текста"  # создание переменной str
# ? Все что для строк работает и со списками []. Только списки можно изменять
s.find("к")  # поиск в строке элементов к
if "к" in s:  # поиск элементов к в строке s и резултат bool
    pass
s.count("к")  # подсчет кол-ва элементов "к" в строке
s.isdigit()  # является ли строка числом (True или False)
s.isalpha()  # или буквенной строкой
s1 = s.replace("ка", "ку")  # создание новой строковой переменной (строки
# менять нельзя) с измененим ку на ку, получится Строку текста
len(s)  # количество символов в строке. У всех символов есть индексы. индекс
# последнего элемента - "-1", второго с конца - "-2" и т.д.
s[0:5]  # вызов строки по индексу с 0-го по 5-й. Принцип работы с индексами
# как у range, только через : и в кв скобках [start:stop:step]. step не
# обязательный параметр. stop - не включительно.
s[0::2]  # печать каждого второго символа (стоп не указан. просто ::)
s[:-1:2]  # то же самое, только без start
s[:]  # с начала до конца, каждый символ.. то есть просто вызвать строку
s[::-1]  # от края до края с шагом -1, то есть в этом случае от конца к началу
s = s[::2] + s[::-2]  # s от края до края с шагом 2 и добавить s от края до
# края с шагом минус 2 (то есть в обратную сторону)
s = "иванов иван иванович"  # создать строковую переменную
sa = s.split()  # формирование списка sa из строки, split - разделяет строку по
# пробелам
sa[0] = sa[0].upper()  # делает заглавными первое слово (по индексу) списка
# пробелам (см документацию)
s = "-".join(sa)  # собрать обратно строку из списка, в виде разделителей между
# словами указать "-". Основой может быть также кортедж итд. строковые значения
# собирает в принципе все подряд.. Ставится знак разлелитель и вперед. Лучше
# использовать ее, # // чем конструкцию типа res+= value в цикле for
# Если список не строковый: #// ''.join(str(x) for x in my_list) здесь join
# перед применением преобразует все в str и с ним работает.
s.format()  # заполняет строку некими значениями

# -----------------------------------------------------------------------------

# *Списки. Ключевое отличие - квадратные скобки. Внутри, может быть несколько.
# //Списки и массивы.

# Список - тип данных, предстваляющих собой упорядоченную последовательность
# определенных значений, которые могут повторяться. Количество элементов списка
# произвольное. list () Если создавать без функции, то квадратные скобки
list()  # генератор словаря - #// lis = list(lis)
lis = [23, 45.5, "s", [123, 2, 3]]   # Синтаксис создания простых списков. То
# что в отдельных скобках внутри списка - это вложенный список.
# dt = [int(i) for i in input().split()] #* ввод списка с клавиатуры
lis2 = lis[::-1]  # создание перевернутой (поскольку -1) выборки lis и
#  копирование ее в новый список lis2
lis2[:] = lis  # // перезаписать в списке lis2 значения из списка lis (замена)
pr = lis.pop()  # записать последнее значение списка в переменную pr и рор
# то есть удалить его из списка. В скобках указывается индекс списка
lis[1] = 4  # Замена в списке по индексу (индексы начинаются с 0)
lis[2]  # вызов значения из списка по индексу
ind = lis2.index(23)  # узнать индекс по значению
lis.insert(1, "Hello")  # вставить в список. Первое значение - индекс
lis.append("Hi")        # Добавление в конец списка, без указания индекса
lis = lis + ["!!!"] + [23] + [46]  # Тоже добавить в конец списка.
lis.remove(23)  # Удалить из списка первое найденное значение "23"
lis.pop(2)  # удаление из списка по индексу, в скобках индекс
# list(lis1(1, 3, 5)) - пока не понятно
# Обращение к списку по индексу через [], то что в скобках всегда индекс. При
# этом [top] - это последний заполненный элемент в списке
print(lis)  # Печать списка как он есть (в скобках)
print(lis2)  # lis2 был создан как копия lis, после чего lis менялся. lis2 нет
print(*lis)  # печать только значений из списка (развернутый список)
lis2[0:3] = ["замена", "элементов", "списка"]  # сделать выборку из списка по
# индексам с 0 до 2-го и заменить эти значения на соответствующие после =
lis2[0:3] = []  # удалить индексы 0, 1, 2 из списка
lis2[0] = [1, 2, 3, 4, 5]  # добавить элементы в начало списка. все следующие
# индексы сдвинутся.
# ? Простые числовые списки можно суммировать, искать максимум и т.п.
lis2 = [1, 2, 3, 4, 5, 6]
lis3 = reversed(lis2)  # тоже создание нового перевернутого из текущего списка
lis2.reverse  # инвертирование списка (родительского), без создания нового
set(lis2)  # создание сета (перечень уникальных значений) списка
# // сортировка списков (возможна только если значения однотипные)
lis2.sort()  # сортровка самого списка без создания нового
ls_srt = sorted(lis2)  # новый список сортированный по значению
su = sum(lis2)  # суммировать все значения в списке
min(lis2)  # найти максимальное значение в списке
max(lis2)  # найти минимальное значение в списке
lis2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  # Создание двухмерного списка (типа)
# таблицы, из вложенных списков. Где первая тройка - верхняя строка, средняя -
# средняя, и последняя - нижняя. Отличия, вызов значения по индексу пересечений
lis2[1][1]  # в данном случае вызывается значение по пересечению индекса 1 в
# строке (первый индекс) и индекса 1 в столбце (второй индекс)
print(lis[3][-1])        # Печать значения из списка по индексу. Первое число
# это индекс, второе - либо символ в значении, либо значение из вложенного
# списка. индексы можно выбирать с конца, если печатать со знаком минус.
print(lis[0:3:2])       # Печать списка по индексам. Откуда: Докуда: Шаг. Можно
# пропускать значения, например [::3] - от начала до конца, каждый третий.
sa = s.split()  # формирование списка из строки.

# *Кортеджи (Не редактируемые списки) - ключевое отличие - обычные скобки.
# Массив - набор фиксированного количества однотипных элементов, расположенных
# в памяти непосресдственно друг за другом, доступ к которым осуществляется по
# их индексу. - array(). Не могут меняться. Только пересозадваться.
# используются для экономии памяти. Ну и для стабильности работы программы.
cort = (2, 4, 8, 15, 16, 23, 42, "LOST")
cort1 = 3, 5, 9, 16, 17, 24, 43, "No LOST"
# Скобки можно не использовать, все равно создается кортедж
print(cort, cort1)

print(cort[3])  # значения по индексам, достаются так же как в списках
cort2 = tuple("248151623,42")    # Оператор tuple - Создает кортедж по символам
print(cort2)

# *Словари. Те же списки, только используются не индексы, а ключи. Символ {}
# // Словари редактируемы. Не имеют порядка. Ключи уникальны, не изменяемы
dict, {}  # создание пустого словаря
dict()  # тоже создание пустого словаря
di = {"test": 4, "ost": "LOST"}
di1 = dict(shot=8, ne="hlor")   # с использованием переменной dict
di2 = dict.fromkeys([1, "bc", 3], [123, 122])  # всем ключам одно значение.
# в первых скобках - ключи. После запятой - значение. Если единичное - то можно
# значение указывать без квадратных скобок
# // Операции со словарями
"test" in di  # Проверка есть ли ключ в словаре
4 not in di  # Проверка есть ли значение в словаре
di["trulyalya"] = 4  # Добавить в словарь ключ и его значение
di["trulyalya"]  # проверка есть ли в словаре ключ. Кавычки имеют значение.
di.get("dfkjgndk")  # Вызов значения по ключу. Если его нет, вернет None
del di["ost"]  # удалить ключ и значение
print(di)
print(di1["ne"])   # вывод не по индексу, а по ключу. Ключь - в кавычках
print(di2[3])   # Либо без кавычек, если это число.
di3 = {"z": 4, "a": 3}
print(max3(**di3))  # передача значений из списка в функцию (имена аргументов)
# должны совпадать. тогда ** значит передать все аргументы по типу key:value

# *Множества. Те же списки, но при выводе - значения уникальны. Без повторов.
set()  # Генератор множества #// lib = set(lis)  из строки/списка в множество
# Синтаксис - как у словаря. То есть те же фигурные скобки, но без ключей
mnojestvo = {"d", "f", "gh", "d", "f", "jlkghdfkjlgh"}
mnojestvo1 = set("HELLO")   # То же самое, но через оператор set
mnojestvo2 = frozenset("ptintjreorej")  # Множество как кортедж,не изменяемое.
# Причем все элементы множества достаются в случайном порядке.
"jlkghdfkjlgh" in mnojestvo  # проверка есть ли такой объект в множестве, дает
# ответ True или False. Делается чере #// оператор in
# Методы #//add('element'), remove(), discard() - remove без проверки, clear()
print(mnojestvo)
lib = set(lis)  # из строки / списка в множество
