# region #* импорт библиотек, работа с библиотеками ---------------------------
""" https://www.youtube.com/watch?v=vqsalStEu38 """
import sys     # Простой импорт стандартного модуля sys целиком
import math as ma  # импорт стандартного модуля математических вычислений, с
# переименованием его в модуль ma для дальнейшего использования
import re  # импорт библиотеки разбора фраз, предложений и т.п. по маске
import requests
from lib.mymodule import (max3, hello1)  # импорт одной или нескольких
# переменных из внешенего модуля. После скобок, через оператор as можно его
# переименовать. Здесь для импорта необходимо прописывать пути. В частности
# lib - это папка расположения самого модуля относительно данного файла. Через
# точку, указывается название модуля (файла), затем в скобках или без -
# перечисляются импортируемые функции.
from lib.mymodule import *  # Импорт всех функций из модуля, при этом их можно
# как и в предыдущем примере вызывать по их мобственному имени без lib.mymodule
# но, такой импорт не рекомендуется, чтобы не было совпадений имен + в этом
# случае не импортируются имена начинающиеся с _ (нижнее подчеркивание)
# то есть если в импортируемом модуле есть _модуль то они по * не импортируется
# для выборочного импортирования с помощью * в импортируемом файле применяется
# конструкция __all__, если такая конструкция есть в импортируемом модуле, от
# // __all__ = [name_1_module, name_2_module]
# будут импортированы только указанные в [] модули и больше ничего
import shutil  # библиотека операций с файлами, копирование и т.п.
import operator  # библиотека операторов (+, *, взять последнее из списка итд.)
import functools  # системные функции
import os  # импорт системной библиотеки для виртуальной среды
# // os.path.join('.', 'dirname', 'filename.txt') это './dirname/testname.txt'
# добавление папок в системные

import dotenv  # импорт python-dotenv (см virtualenv.md), создание и вызов
dotenv.load_dotenv()  # системных переменных окружения, паролей из файла .env

sys.path.append('./src')  # импорт в проект путей/папок проекта
# "./" - текущая папка. "../" - родительская папка.
print(sys.path)
print(sys.version)  # печать версии системы из модуля sys
print(ma.pi)  # печать числа Пи, из модуля math, сокращенного выше до ma

name = os.getenv('MYNAME')  # присваивание имени из системной переменной (.env)
print(name)
# или
key = os.environ.get('MYKEY')  # присваивание пароля из системной переменной
print(key)

print(os.getcwd())  # распечатать папку проекта
print(os.listdir())  # вывести все папки и файлы в текущей директории
print(os.path.exists('test.py'))  # узнать есть ли.. True/False
print(os.path.isdir('test.py'))  # является ли папкой есть еще isfile. тоже
# возвращает True/False
print(os.path.abspath('test.py'))  # абсолютный путь
# os.chdir() - сменить текущую директорию
# os.walk  - генератор директорий и файлов текущем проекте

print(max3(2, 5))   # Вызов Функции из Внешнего Модуля.
# В Данном Случае Вызыватся Функция Max3 из Модуля Mymodule,

hello1("test")  # вызов функции из внешнего модуля. В данном случае вызыватся
# функция hello1 из модуля mymodule. (в самой функции есть опертаор "print").
# То что стоит в скобках, заменяет параметр по умолчанию, который есть в
# модуле. Если ничего не писать, оставить (), будет использовать значения из
# модуля.

print("""
проверочный текст          #тройными кавычками замыкается текст, чтобы
с условными переносами     #выводить его также как в коде :)
как в коде. Замыкающие обязательно на отдельной строке.
""")
# endregion -------------------------------------------------------------------

# region #* Синтаксис языка ---------------------------------------------------
# * Операции:
help(print)  # вызов хелпа для любой имеющейся в языке функции, класса, метода
# -----------------------------------------------------------------------------
#   ** возведение в степень (если значение меньше 1 - то корень)
#   >= больше или равно, <= - меньше или равно
#   != не равно
#   // Целочисленное деление. Дает челое число при делении
#   %  остаток после деления
#   x +=2 Прибавить (может быть любая операция /=, %=, **=), цифру после равно
#   == Проверяет равенство, одинаковые ли объекты
#   "is" не сравнивает значения, а спрашивает один и тот же это объект или нет
#   Операторы or (или), and(и), not(инверсия значения)
#   if ... in а, if ... not in а опертаторы проверки принадлежности. Если ...
#   есть в списке а, и если ... нет в слове а
#
#   =  Простой оператор присваивания значений переменной
#   := Новый оператор присваивания. используется в if и while (см ниже)
#   << сдвигает биты числа влево на заданное кол-во позиций
#   >> сдвигает биты числа вправо на заданное кол-во позиций
#   &  побитовая операция "и" над числами
#   |  побитовая операция "или" над числами
#   ~  побитовая операция "не" для чисел
#   ^  побтовая операция исключительно "или"
#   not логическое "нет"
#   and логическое "и"
#   or  лигическое "или"
#   in  внутри (в циклах for, if, while итд.)
# ? print(), type(), dir(), id(), len() - применяются ко всем типам данных
#   dir() запросить имеющиеся у объекта аттрибуты в () название объекта
#   sep = "" - убирает пробелы между значениями, и вставляет туда то что в ""
#   end = "" - возможность не переносить строки. Можно добавить символы в ""
#   \ экранирование символов. Кавычек, знаков переноса, и т.д.
#   \n - в операторе print внутри кавычек, перевод строки
# -----------------------------------------------------------------------------
#   pop - удалить последний элемен из списка, стека или к чему он добавляется
#   push - добавить ......
#   clear - очистить
#   break - принудительно выйти из цикла
#   continue - принудительно пропустить оставшийся код на одном круге цикла
# -----------------------------------------------------------------------------
# (_) - подчеркивание в пустых скобках обозначает предыдущее значение.
# py -i имя_файла.py - запуск файла в интерактиве (>>> после исполнения)
# // Приоритет операторов
# ** чем ниже по таблице, темы выше приоритет исполнения
# lambda лямбда-выражение
# or Логическое “ИЛИ”
# and Логическое “И”
# not x Логическое “НЕ”
# in, not in Проверка принадлежности
# is, is not Проверка тождественности
# assert == проверка соответствия (используется при дебаге) и для контроля кода
# raise - обработка исключений (см ниже)
# <, <= , > , >= , != , == Сравнения
# | Побитовое “ИЛИ”
# ^ Побитовое “ИСКЛЮЧИТЕЛЬНО ИЛИ”
# & Побитовое “И”
# <<, >> Сдвиги
# + Сложение для цифр и конкотинация для строк, списков, кортеджей итд.
# - вычитание для цифр.
# / , // , *, % деление, целочисленное деление, умножение, и остаток от деления
# умножение также применяется для строк (напечатать одно и тоже n раз)
# +x, -x Положительное, отрицательное
# ~x Побитовое НЕ
# ** Возведение в степень
# x.attribute Ссылка на атрибут
# x[индекс] Обращение по индексу
# x[индекс1:индекс2] Вырезка
# f(аргументы ...) Вызов функции
# (выражения, ...) Связка или кортеж 2
# [выражения, ...] Список
# {ключ: данные, ...} Словарь

# // CRUD - create, read, update, delete
# все програмирование основано на двух слонах. Данные и их модификация. CRUD
# это 4 стандартных действия которые совершаются с любыми данными

# //идентификатор - имя объекта. Какой то функции, переменной, класса в
# программе. Может состоять из больших и маленьких букв, цифр, знаков
# подчеркивания. Не может начинаться с цифры. Регистр имеет значение. Не может
# совпадать с синтаксисом языка.

# //Переменная - ссылка на какой либо объект. Записывается маленькими буквами
# через знаки подчеркивания: my_variable.

# //Константа - значение не предназначенное для изменения. Принято писать
# большими буквами: MY_CONSTANT. Такое обозначение используется только для себя
# (чтобы случайно не изменить). Чтобы сделать объект доступным только для
# чтения см. курс Essential.

# //Тип данных - определяет возможные значения данных и их смысл. В Python
# используются динамические типы данных. То есть моггут меняться (но это не
# желательно). В большинстве языков - типы задаются и не меняются на протяжении
# всей программы.

# //int, float, complex и другие - тип данных числа.

# //float - число с запятой. Записывется 5.3 или 5. Для больших или маленьких
# чисел используется как возведение в степень через e. Например 5е3 - 5*10 в 3
# степени. Можно возводить и в отрицательную степень, например 5е-3 = 5*10 в
# минус 3 стпени.

# //bool - часть int, для логики. Только 1 или 0. True или False
# соответственно. Всегда пишется с большой буквы.

# //Контейнеры и последовательности str, tuple - неизменные. list - изменяемая.
# None - пустой тип. Объявления переменной не имеющей значения.(с большшой)

# //изменением типа переменных можно преобразовывать строки в числа и наоборот.
# например:
()  # вызов чего то... Если в скобках пусто, то вызов пустых параметров.
# обязательный параметр при создании или вызове функции
stroka = "143"  # Объявление строковой переменной.. То есть она у нас текст.
int(stroka)  # использование данных из строковой переменной как числа.
float(140)  # приведение к типу данных. Также с int, str, list итп.
int(5.9)  # приведение к int путем отбрасывания остатка
x = int(43.567)  # создание переменной x типа int, со значением 43 (
# значение после точки отбрасывается)
y = str()  # содание пустой переменной "y" типа str
assert y == str()  # проверка значения при дебаге
x = 40 if x < 40 else 35  # назначение переменной по условию
print('hello' if x > 40 else "huylo")  # печать по условию
print(dir(x))  # запросить имеющиеся у объекта атрибуты
x, y = y, x  # поменять местами значения переменных

s = "Образец длинной строки, которая не помещается в определенный предел PEP8 \
    для того чтобы ее перенести, либо все берется в скобки, либо при переносе \
    строки ставится '\'"

# ? (Если не хватает длины строки, все выражение берется в скобки, и тогда
# ? Пайтон понимает, что это единая строока). Пример
print(name,
      key)
print()  # пустая строка

nom = int(stroka)  # Преобразование данных из переменной stroka в целое
# число и в переменную nom, которую уже можно использовать при расчетах и т. п.

round(nom)  # округление чисел по правилам математики. Доп-но можно указать до
# какого знака после запятой округлять, для этого 2-й аргумент round(float, 4)

type(134)  # вызов класса объекта. В консоли печатает к какому классу
# приналдежит объект. В данном случае - int. В зависимости от содержимого
# может быть string, float, bool, type и т.п. Также в () можно вставлять имя
# переменной, чтобы узнать какой класс сейчас в ней присутствует

id(stroka)  # вызов id (уникальный идентификатор) ранее созданного объекта

# Ввод чисел в других системах:
0b01000110100  # - двоичная система. Также для нее есть функция bin()
0o1274653621367  # - восьмеричная система. Есть функция oct()
0x123ABCDEF  # - шестнадцатеричная система. Есть функция hex()

number = 21342134
print(number)

# //Переменные
c = ""  # Простое объявление пустой строковой переменной.
d = int()  # Простое объявление переменной типа int
x = None  # объявление переменной (в данном случае совсем пустой, без типа).
y = 5  # объявление второй переменной. На сей раз тип int
x = 10  # теперь перменной задано значение (в реале может появляться откуда
print(type(c))  # печать типа переменной
# import graphics
# # импорт библиотеки graphics
# window = graphics.GraphWin("Test Window", 100, 100)
# # вызов окна графической оболочки с параметрами
# -----------------------------------------------------------------------------
# ! Раскраска комментариев (плагин Better Comments)
# ? После вопросительного знака
# * После звездочки
# ** после двух звездочек
# // Вот такие два палки в начале, выделяют коментарий

# * Список задач (плагин TODO Tree)
# FIXME: Проверка
# BUG: Проверка
# TODO: Проверка
# HACK: Проверка
# XXX:Проверка
# endregion -------------------------------------------------------------------

# region #* Простое назначение переменных -------------------------------------
"""Переменные в пайтон это не объекты, а лишь ссылки на созданные объекты.
Несколько переменных могут ссылаться на один и тот же объект
При этом объекты бывают не изменяемыми (числа, строка, кортедж) и изменяемыми
(список, словарь) Когда меняется материнский объект у числа, наследник
указывает на старый объект, а для материнского создается новый. Если объект
изменяемый, то новый оъект не создается, а потому и родитель и наслединик
всегда ссылаются на один и тот же объект. Если необходимо внести изменения в
изменяемый объект (список) и не трогать родителя, то делается копия"""
x: float = 105     # Назначение переменной x, с типом float
y: int = 110     # Назнечение другой переменной y, с типом int
z = int(43.567)  # создание переменной z типа int, со значением 43, при этом
# значение после точки отбрасывается
a = b = c = 120  # присвоение одного значения трем переменным
del(a)  # удаление переменной из памяти
a, b, c = 80, 90, 100  # Присвеоение значений по типу кортеджа
first, second, *center, last = [2, 4, 6, 8, 12]  # Создание кортеджа через
#  присваивание. Здесь создаются 3 кортеджа. в первый попадает первое значение
# в последний - последнее. Така как *center с * в него вся середина
print(center)
print(a, b, c, sep="-")  # //sep - разделиттель между словами, одновременно
# убираюший пробелы. Если в кавычках пусто - получаем выражение без пробелов
print(a if a > b else b)  # //по выбору из значения.. используем то, что слева
# от if, если соблюдается условие a > b, иначе - используем то что после else
id(x)  # вызов уникального идентификатора объекта
print(a, b)
print(b, c)
print(x, y)
# все эти три записи, поскольку они однотипные можно записать через for:
for p, z in (a, b), (b, c), (x, y):  # p и z - временные переменные цикла for
    print(p, z)  # котрые подсталяют вместо себя значения которые после in

# -----------------------------------------------------------------------------

x: float = 105     # Назначение переменной x, с типом float
y: int = 110     # Назнечение другой переменной y, с типом int
z = int(43.567)  # создание переменной z типа int, со значением 43, при этом
# значение после точки отбрасывается
strochka = 'stroka'  # Назначение переменной типа str
stroka = str("text_key")  # другая запись того же самого
a = b = c = 120  # присвоение одного значения трем переменным
a, b, c = 80, 90, 100  # Присвеоение значений по типу кортеджа
locals()  # вызов функции выводящей все доступных на момент вызова переменные и
# их значений
# endregion

# region #* регулярные выражения и их запись, библиотека "re" -----------------
# // https://stepik.org/lesson/24470/step/2?unit=6776

# // все метасимволы в строках, экранируются от текста через '\' (без кавычек)
# ? . ^ $ * + ? { } [ ] \ | ( ) метасимволы
# любой символ кроме переноса строки подходит под #? '.', которая заменяет
# любой входящий символ. то есть abcdef найдется по ab..ef (без скобок)
# любое количество символов подходят под #? '*', то есть abbbbbc = ab*c, при
# этом если вместо * указать #? "+" то кол-во символов должно быть > 0
# если указать #? "?" то вхождение должно быть или 0 или 1. Если нас интересует
# конкретное количество вхождений символа, то он указывается в #? {} - ab{4}c,
# а если ab{2,4}c - то ищем от 2-х до 4-х

# ? \d - цифры, эквивалентно [0-9], если \D то не цифры, эквивалентно [^0-9]
# ? \s - пробельные символы [ \t\n\r\f\v] и \S наоборот [^ \t\n\r\f\v]
# ? \w - буквы + цифры + _ [a-zA-Z0-9_] и \W наоборот [^a-zA-Z0-9_]
# внутри [] указываются подходящие символы, или диапазон. через '-' [a-zA-Z] (
# как пример такой записи - все буквы английского алфавита). Если внутри []
# стоит ^ это значит что указанный диапазон не подходит [^b-z] или [a-z^A-Z]
# что означает, что подходят только маленькие буквы, а большие - нет.
# ? при сокращенной записи [] не используют "abc[a-zA-Z0-9_]de" = "abc\wde"
# он испольуется при совмещении #? "abc[a-zA-Z0-9_юра]de" = "abc[\wюра]de"

# по умолчанию c + или * является "жадным" и ищет по самому длинному выражению
# форма записи ab[ab]+d - будет искать самые длинные вхождения
# если наборот, надо искать самые короткие вхождения, то вместе с + ставим ? то
# есть запись ab[ab]+?d - будет искать самое короткое вхождение

# метасимволы можно группировать через (), как пример
pattern = r"(test)*"  # ищет любое вхождение фразу в скобках
pattern = r"(test|text)*"  # ищет или test или text, с любым кол-ом вхождений
# символ | (или) можно ставить и вне скобок, например r"abc|(test|text)*"
# c помощью скобок можно группировать как угодно r"((abc)|(test|text)*|(bcd))"
# перед закрытием скобки через \ стоит номер группы которая нам нужна, то есть
pattern = r"((abc)|(test|text)*|(bcd)\2)"  # вызовет вторую группу. группы
# считаются с первой открывающей скобки, 1-я группа - все выражение целиком итд

hellow2 = "Привет, Василий!"  # Создание строковой переменной
pattern = r"abcd, Василий!"
mathc_obj = re.match(pattern, hellow2, re.IGNORECASE)  # проверяет подходит ли
# строка под заданный шаблон, а IGNORECASE говорит игнорировать заглавные буквы
search_obj = re.search(pattern, hellow2)  # ищет вхождение строки в шаблон
# ? символы подходящие под шаблон указываются в []
pattern = r"Пр[ивював]ет[,.-] Василий[!.ура]"  # в [] указываются возможные
# варианты, то есть в средних [] будут проходить и ',' и '.' и '-' а в конечных
# [] и '!' и '.' и 'у' 'р' 'а' (или их сочетание)
find_obj = re.findall(pattern, hellow2)  # ищет все вхождения патерна в строку
sub_obj = re.sub(pattern, "ва", hellow2)  # заменяет все вхождения щаблона на
# то, что указано в " "

hellow2 = "Привет, Василий!"  # Создание строковой переменной

f'{hellow2}'  # f-string, принимающая значение hellow2. Передает содержание
# переменной. на выходе "Привет, Василий!" https://python-scripts.com/f-strings
f'{hellow2=}'  # Строка передает название и значение переменной (новинка P 3.8)
# то есть на выходе: "hellow2 = 'Привет, Василий!'"

name = re.search(r', (.*)!', hellow2)
# имя = бибилиотека re, метод search, (маска разбирающая переменную и ее имя)
if name:  # когда просто # * if name: без всяких условий, сравнений или ==
    # подразумевается "если name == True (то есть оно просто существует)"
    print(name.group(1))  # печатать группу из полученной переменной name

if (name := re.search(r', (.*)!', hellow2)):
    print(name.group(1))
# Тоже самое что в верхнем блоке, но запись с использованием нового оператора
# присваивания ':=' (появился в Питоне 3.8)#//(PeP не обновился. потому ошибка)

# endregion -------------------------------------------------------------------

# region #* Работа со строками ------------------------------------------------
""" Строки в Пайтон являются неизменяемыми кортеджами. изменить строку нельзя.
даже через оператор .replace можно создать новую строку на основе имеющейся но
нельзя изменить текущую. То есть если я сделаю print(a.upper()), в момент вызов
интерпритатор переведет регистр. и тут же об этом забудет. следующий print(a)
выведет изначальное значение a, без перевода в верхний регистр. Чтобы дейст-но
изменить переменную a, надо сделать a = a.upper()
"""
# ? Все что для строк работает и со списками []. Только списки можно изменять
s = r'Стр.\ntex'  # // raw, сырая строка переносы и спец симв. не применяются
s = ""  # содание переменной s с типом данных строка ("" - литерал строки)
s = "Строка текста"  # создание переменной str
s.find("к")  # поиск в строке элементов к, и вывод индекса начала
s.index('т')  # тоже самое, но дает ошибку если не находит
s.startswith('Стр')  # проверка начинается ли строка с какой то другой строки
s.endswith('та')  # то же самое для конца
s.count("к")  # подсчет кол-ва элементов "к" в строке
s.isdigit()  # является ли строка числом (True или False)
s.isalpha()  # или буквенной строкой
s.lower()  # возвращает строку маленькими буквами
s.upper()  # то же самое большими
s.title()  # Первые Буквы В Словах Большие
s.startswith("э")  # проверяет начинается ли строка с буквы
# можно совмещать методы например:
print(s.lower().count('с'))  # перевести в нижний и вывести количество букв "c"
s.replace('к', 'К')  # найти и заменить
s1 = s.replace("ка", "ку")  # создание новой строковой переменной (строки
# менять нельзя) с измененим ку на ку, получится Строку текста
s.strip()  # убрать лишние символы. Есть еще lstrip (слева) и rstrip (справа)
""" метод strip может принимать аргументы. то что в () то и будет убираться,
например, если в (';') - он уберет все символы ';', остальное не тронет"""
if "к" in s:  # поиск элементов к в строке s и резултат bool
    pass
len(s)  # количество символов в строке. длина строки
# У всех символов есть индексы. индекс первого элемента - 0, вторгого 1
# последнего элемента "-1", второго с конца - "-2" и т.д.
s[0:5]  # вызов строки по индексу с 0-го по 5-й. Принцип работы с индексами
# как у range, только через : и в кв скобках [start:stop:step]. step не
# обязательный параметр. stop - не включительно.
s[0::2]  # печать каждого второго символа (стоп не указан. просто ::)
s[:-1:2]  # то же самое, только без start
s[:]  # с начала до конца, каждый символ.. то есть просто вызвать строку
s[::-1]  # от края до края с шагом -1, то есть в этом случае от конца к началу
s = s[::2] + s[::-2]  # s от края до края с шагом 2 и добавить s от края до
# края с шагом минус 2 (то есть в обратную сторону)
s = "иванов иван иванович"  # создать строковую переменную
sa = s.split()  # формирование списка sa из строки, split - разделяет строку по
# пробелам, и возвращает список
sa[0] = sa[0].upper()  # делает заглавными первое слово (по индексу) списка
# пробелам (см документацию)
j = ""
j.join(sa)  # простая сборка строки из списка
s = "-".join(sa)  # собрать обратно строку из списка, в виде разделителей между
# словами указать "-". Основой может быть также кортедж итд. строковые значения
# собирает в принципе все подряд.. Ставится знак разделитель и вперед. Лучше
# использовать ее, # // чем конструкцию типа res+= value в цикле for
# Если список не строковый: #// ''.join(str(x) for x in my_list) здесь join
# перед применением преобразует все в str и с ним работает.
""" #* форматирование строк - заполнение частей строки некими значениями. Есть
два метода. format и f-string нотация"""
s.format()  # заполняет строку некими отфильтровнными значениями
print(s)
print('{:.5}'.format(s))  # вывести первые 5 знаков из строки
# // есть еще назначение для подстановки значений в типовую строку
capital = "London is a capital of Great Britain"
temlate = "{} is a capital of {}"
print(temlate.format("Moscow", "Russia"))
# можно сделать более правильно и расширенно (индексы с 0):
temlate = "{0} is a capital of {1}, {2}"
print(temlate.format("да пофиг", "Россия", "Москва"))
# или через список
temlate = "{capital} is a capital of {country}, {pofig}"
print(temlate.format(pofig="да пофиг", country="Россия", capital="Москва"))
# ? f-string тоже самое, только без вызова метода fornat:
# кроме этого f-string позволяют выполнять внутри себя математические операции
capital = "Moscow"
country = "Russia"
pofig = "да пофиг"
print(f"{capital} is a capital of {country}, {pofig}")

# endregion -------------------------------------------------------------------

# region # *Списки. Литералы- [], list() --------------------------------------
# ?Списки - изменяемый тип данных. Внутри, могуть быть числа, строки, вложенные
# списки, иные типы данных
# // Распаковка списка при передаче как аругмент в функцию - через *
# Список - тип данных, предстваляющих собой упорядоченную последовательность
# определенных значений, которые могут повторяться. Количество элементов списка
# произвольное. list () Если создавать без генератора, то квадратные скобки
# Данные в списке разложены по индексам. Каждый элемент списка имеет индекс от
# 0 до ... Первый элем-т "0", второй "1". Последний "-1", предпослений "-2" итп
lis = [23, 45.5, "s", [123, 2, 3]]   # Синтаксис создания простых списков. То
# что в отдельных скобках внутри списка - это вложенный список.
list()  # генератор списка - #// lis = list(lis)
# Списки это объекты, и при создании новой ссылки, новый список не создается
lis1 = lis
# если нужно создать новый список на основе имеющегося (скопировать) то надо
# делать это либо на основе коструктора:
lis1 = list(lis)
# либо через оператор copy
lis1 = lis.copy()
lis2 = lis[::-1]  # создание перевернутой (поскольку -1) выборки lis и
#  копирование ее в новый список lis2
lis2[:] = lis  # // перезаписать в списке lis2 значения из списка lis (замена)
pr = lis.pop()  # записать последнее значение списка в переменную pr и рор
# то есть удалить его из списка. В скобках указывается индекс списка
lis[1] = 4  # Замена в списке по индексу (индексы начинаются с 0)
lis[2]  # вызов значения из списка по индексу
ind = lis2.index(23)  # узнать индекс по значению
lis.insert(1, "Hello")  # вставить в список. Первое значение - индекс
lis.append("Hi")  # Добавление в конец списка, как вложенный элемент [[],[]]
lis.extend(lis2)  # расширение первого списка за счет (..) без вложенности [,,]
# вместо extend можно + как пример
# ?  append получение табличного списка, extend - получение плоского списка
lis + [1, 2, 3, 4]  # + не сохраняют в текущий список. Только в новую (или
# текущую) переменную, то есть это строковый оператор, со всеми вытекающими
lis = lis + ["!!!"] + [23] + [46]  # Тоже добавить в конец списка.
lis.remove(23)  # Удалить из списка первое найденное значение "23"
lis.pop(2)  # удаление из списка по индексу, в скобках индекс
# list(lis1(1, 3, 5)) - пока не понятно
# Обращение к списку по индексу через [], то что в скобках всегда индекс. При
# этом [top] - это последний заполненный элемент в списке
print(lis)  # Печать списка как он есть (в скобках)
print(lis2)  # lis2 был создан как копия lis, после чего lis менялся. lis2 нет
print(*lis)  # печать только значений из списка (развернутый список)
lis2[0:3] = ["замена", "элементов", "списка"]  # сделать выборку из списка по
# индексам с 0 до 2-го и заменить эти значения на соответствующие после =
lis2[0:3] = []  # удалить индексы 0, 1, 2 из списка
lis2[0] = [1, 2, 3, 4, 5]  # добавить элементы в начало списка. все следующие
# индексы сдвинутся.
# ? Простые числовые списки можно суммировать, искать максимум и т.п.
lis2 = [1, 2, 3, 4, 5, 6]
lis3 = reversed(lis2)  # тоже создание нового перевернутого из текущего списка
lis2.reverse  # инвертирование списка (родительского), без создания нового
set(lis2)  # создание сета (перечень уникальных значений) списка
# // сортировка списков (возможна только если значения однотипные)
lis2.sort()  # сортровка самого списка без создания нового
ls_srt = sorted(lis2)  # новый список сортированный по значению
""" sorted - возвращает новый упорядоченные список. sort - возвращает тот же
самый список, но уже отсортированный. Оба могут принимать аргументы, то есть
указание как именно сортировать (создаются с помощью функций, циклов и т.п)
https://www.youtube.com/watch?v=7tFOlqHlP-E
"""
children = ['ivanov_2000', 'petrov_1990', 'sidorov_2005']
# создаем список фамилия_год рождения. задача отсортировать по году


def sort_year(name):
    """ функция принимает элемент списка (строку ivanov_2000), делает из строки
    по знаку (_) список из элементов ['ivanov', '2000'] и возвращает последний
    по индексу элемент [-1] """
    return name.split('_')[-1]


sort_children = sorted(children, key=sort_year)
""" key - ключ сортировки через созданную выше функцию, поэлементно сортирует
список по значению в функции передавая туда список по элементно"""
print(sort_children)
# ---------------------------------------------------------------------------
su = sum(lis2)  # суммировать все значения в списке
min(lis2)  # найти максимальное значение в списке
max(lis2)  # найти минимальное значение в списке
lis2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  # Создание двухмерного списка (типа)
# таблицы, из вложенных списков. Где первая тройка - верхняя строка, средняя -
# средняя, и последняя - нижняя. Отличия, вызов значения по индексу пересечений
lis2[1][1]  # в данном случае вызывается значение по пересечению индекса 1 в
# строке (первый индекс) и индекса 1 в столбце (второй индекс)
print(lis2[2][-1])        # Печать значения из списка по индексу. Первое число
# это индекс, второе - либо символ в значении, либо значение из вложенного
# списка. индексы можно выбирать с конца, если печатать со знаком минус.
print(lis[0:3:2])       # Печать списка по индексам. Откуда: Докуда: Шаг. Можно
# пропускать значения, например [::3] - от начала до конца, каждый третий.
sa = s.split()  # формирование списка из строки.
lis.clear()  # очистить список
# endregion -------------------------------------------------------------------

# region #* Кортеджи (Не редактируемые списки) - Литералы () -----------------
# Массив - набор фиксированного количества однотипных элементов, расположенных
# в памяти непосресдственно друг за другом, доступ к которым осуществляется по
# их индексу. - array(). Не могут меняться. Только пересозадваться.
# используются для экономии памяти. Ну и для стабильности работы программы.
cort = (2, 4, 8, 15, 16, 23, 42, "LOST")
cort1 = 3, 5, 9, 16, 17, 24, 43, "No LOST"
# Скобки можно не использовать, все равно создается кортедж
print(cort, cort1)

print(cort[3])  # значения по индексам, достаются так же как в списках
cort2 = tuple("248151623,42")    # Оператор tuple - Создает кортедж по символам
print(cort2)
# endregion -------------------------------------------------------------------

# region #* Словари.  Литералы dict(), {} ------------------------------------

# // Те же списки, но используются не индексы, а ключи. итерируемый, изменяемый
# тип объектов. Редактируемы. Не имеют порядка. Ключи уникальны, не изменяемы
# // Распаковка словаря при передаче как аругмент в функцию - через **

dic = {}  # создание пустого словаря
dic = dict()  # тоже создание пустого словаря
di = {"test": 4, "ost": "LOST"}
di1 = dict(shot=8, ne="hlor")   # с использованием переменной dict
di2 = dict.fromkeys([1, "bc", 3], [123, 122])  # всем ключам одно значение.
# в первых скобках - ключи. После запятой - значение. Если единичное - то можно
# значение указывать без квадратных скобок

# // Операции со словарями
"test" in di  # Проверка есть ли ключ в словаре
4 not in di  # Проверка есть ли значение в словаре
di["trulyalya"] = 4  # Добавить в словарь ключ и его значение

# ? информацию из словарей достают двумя методами:
d = di['test']  # вызов по ключу словаря, записьь значения в переменную d
d = dic.get(key)  # Вызов значения по ключу. Если его нет, вернет None
"""первый, по литералу d = dic[key] при отсутсвии в словаре искомого ключа дает
исключение. Второй d = dic.get(key) при отстутсвии дает просто значение None.
При этом вместо None, вторым аргументом можно указать умолчание. То есть то что
даст вызов если искомого ключа не оказалось в словаре. dic.get(key, default)"""
d = di.get("key", 'default_value')
# кроме get есть метод update, он обновляет имеющиеся значение словаря и
# добавляет новые значения, если на момент исполнения их там нет
dic.update(key='default_value_new', key_1='default_value_1')
# вместо именованых аргументов можно передавать другой словарь, список, любой
# итерируемый объект

"""если необходимо найти ключ в словаре, а если его там нет, то имеется
#? необходимость его создать, существует метод:"""
d = di.setdefault("key", 'default_value')

di["trulyalya"]  # проверка есть ли в словаре ключ. Кавычки имеют значение.
del di["ost"]  # удалить ключ и значение
print(di)
print(di1["ne"])   # вывод не по индексу, а по ключу. Ключь - в кавычках
print(di2[3])   # Либо без кавычек, если это число.
di3 = {"z": 4, "a": 3}
print(max3(**di3))  # передача значений из списка в функцию (имена аргументов)
# должны совпадать. тогда ** значит передать все аргументы по типу key:value

# ? словари = итерируемые объекты и их можно крутить в циклах for
"""у каждого словаря есть методы items, keys, value итп, которые можно крутить
в цикле и доставать значения."""
for value in di.values():
    print(value)
"""можно доставать пары значений (как enumerate в списках), а не по одному:"""
for key, value in di.items():
    print(key, value)

# endregion -------------------------------------------------------------------

# region #* Множества (Turple) Cписки c уникальными значениями, без повторов --
set()  # Генератор множества #// lib = set(lis)  из строки/списка в множество
# Синтаксис - как у словаря. То есть те же фигурные скобки, но без ключей
mnojestvo = {"d", "f", "gh", "d", "f", "jlkghdfkjlgh"}
mnojestvo1 = set("HELLO")   # То же самое, но через оператор set
mnojestvo2 = frozenset("ptintjreorej")  # Множество как кортедж,не изменяемое.
# Причем все элементы множества достаются в случайном порядке.
"jlkghdfkjlgh" in mnojestvo  # проверка есть ли такой объект в множестве, дает
# ответ True или False. Делается чере #// оператор in
# Методы #//add('element'), remove(), discard() - remove без проверки, clear()
print(mnojestvo)
lib = set(cort)  # из строки/списка/кортеджа в множество
# endregion -------------------------------------------------------------------

# region #* Операции с файлами ------------------------------------------------
# ? Ключи =====================================================================
# "r" только для чтения (по умолчанию)
# "w" открыть для записи, содержимое файла стирается
# "rb" только для чтения, бинарный файл
# "wb" открыть для записи бинарный файл, содержимое файла стирается
# a(append) открыть для записи, запись идет в конец файла
# b (binary) в бинарном режиме (вторая часть второго аргумента "rb", "wb" итп)
# t (text) открыть в текстовом режиме (по умолчанию) 2-я часть 2-го аргумента
# r+ открыть для чтения и записи
# w+ чтение и запись, при этом содержимое файла стирается
# ? ===========================================================================
inf = open('./src/test.txt', "r")
"""метод open сначала ищет файл, и если второй аргумент 'r', то либо его
открывает, либо выдает исключение. Если второй аргумент 'w', то создает этот
файл.
Python имеет 3 метода ввода/вывода (I/O). Text IO, Binary IO, Raw IO
"""
""" Просто открытия файла не достаточно, чтобы добраться до содержащейся в нем
информации. Для этого эту информацию необходимо прочитать
"""
s0 = inf.read(5)  # чтение первых 5 символов. Если () то читает целиком файл
s1 = inf.readline()  # чтение одной строки из файла
sall = inf.readlines()  # чтение всех строк файла, возвращает список строк.
s1 = s1.rstrip()  # убрать все ведущие пробельные символы справа, вт.ч. перенос
# такую запись можно применять при считывании (см s2)
s2 = inf.readline().rstrip  # чтение второй строки без лишних символов и т.д
s00 = inf.read()  # считывание файла до конца
s = inf.readline().strip()
# убрать все служебные символы при чтении строки '\t abs  \n'.strip() > 'abs'
s = s.splitlines()  # тоже самое, то есть убрать управляющие символы и разбить
# по строкам как список (каждая строка - элемент списка)
print(repr(s00))  # оператор #? repr - печатать все что считано как строку
inf.close()  # закрытие файла, чтобы освободить рессурсы
# -----------------------------------------------------------------------------

with open('./src/test.txt') as inf:  # инфо считывается и файл
    s1 = inf.readline()  # сразу закрывается. Считанная инфо остается в памяти
    s2 = inf.readline()

# // Можно считывать через цикл for -------------------------------------------
with open("./src/test.txt") as inf:  # Функция читающая весь файл
    for line in inf:
        line = line.rstrip()
        print(repr(line))
    s = inf.read()
# -----------------------------------------------------------------------------

# * Открытие файла для записи -------------------------------------------------
""" открытие файла для записи происхожит по ключу "w". При этом исходное
содержимое, после чтения, стирается. Чтобы этого не происходило есть метод
октрытия файлов - .a (append), в этом режиме идет дозаписывание новой инфо в
конец файла."""
ouf = open("./src/test.txt", "w")  # порядок открытия для записи в файл
""" метод write для записи в файловые объекты. Аргументы для write - "строка"
При этом в момент write идет запись в буфер. Физическая запись происходит либо
при закрытии файла .close(), либо через метод .flush(), как ctrl-S"""
ouf.write('Some text\n')  # файла может и не быть, питон его создаст
ouf.write(str(25))

# для того чтобы не ставить перносы вручную надо создать содержимое файла через
# метод join:
lines = ['Line1', 'Line2', 'Line 3']
cont = "\n".join(lines)  # ? метод склеивания списка в строку через знак в " "
ouf.write(cont)
ouf.close

with open('./src/test.txt', 'a') as ouf:  # При таком открытии идет открытие
    ouf.write('Some text\n')  # запись в конец, и закрытие файла
    ouf.write(str(25))
# конструкцию with можно использовать для нескольких файлов, в т.ч. открывая их
# и на чтение и на запись, по форме:
# // with open('file1' 'r') as file1, open('file2' 'w') as file2:
# //    for line in file1:
# //        file2.write(line)


# * форматы файлов
""" под каждый формат файла существует своя библиотетка, даже на самые простые
типа JSON или CSV (таблица с разделением запятыми)
"""
# ? пример октрытия и копирования картинки (бинарного файла)
pic = './src/test_pic.jpg'  # присваиваем переменной pic объект файл
file = open(pic, "rb")  # открываем файл в режиме чтения бинарных данных
new_file = open(pic + "_copy.jpg", "wb")  # создание нового файла по маске
new_file.write(file.read())  # запись в новый файл данных, прочитанных из pic

# ! Запуск файла --------------------------------------------------------------
# * если импорт библиотеки, то все что ниже этой формулировки не исполняется
# потому что name == main только внутри самого файла. Если вызывать его извне
# как модуль, то его имя с main меняется на его название
# Если модуль импортирован, то его __name__ это название модуля. Если же просто
# запустить сам модуль, то его __name__ - это "__main__"
if __name__ == "__main__":
    print('modul started', __name__)  # имя модуля = __main__
else:
    print('module imported', __name__)  # имя модуля = имя файла (модуля)
# При такой вставке если модуль импортирован, будет вывод 2-й строки. Если
# запущен самостоятельно - то первой.
"""https://www.youtube.com/watch?v=cW_-zGG4ef4
Интепритатор читает код сверху вниз и затем последовательно исполняет весь тот
код, который находит в скриптах. Перед тем как начать исполнение, он определяет
несколько встроенных переменных. В том числе __name__. Это служебная переменная
хранит в себе имя модуля. Если имя __name__ == __main__, это означает, что
модуль был запущен самостоятельно. Иначе, при запуска через импорт или как то
еще, __name__ будет равным имени модуля (файла).
"""

# * ---------------------------------------------------------------------------
# ! файл __init__.py
# * если данный файл находится в папке, значит папка является пакетом. В нем
# находится информация что именно и в каком порядке необходимо импортировать
# endregion--------------------------------------------------------------------
