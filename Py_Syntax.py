# region  СиНТАКСиС ЯЗЫКА
# * Операции:
# -----------------------------------------------------------------------------
#   ** возведение в степень (если значение меньше 1 - то корень)
#   >= больше или равно, <= - меньше или равно
#   != не равно
#   // Целочисленное деление. Дает челое число при делении
#   %  остаток после деления
#   x +=2 Прибавить (может быть любая операция /=, %=, **=), цифру после равно
#   == Проверяет равенство, одинаковые ли объекты
#
#   "is" не сравнивает значения, а спрашивает один и тот же это объект или нет
#   Операторы or (или), and(и), not(инверсия значения)
#   if ... in а, if ... not in а опертаторы проверки принадлежности. Если ...
#   есть в списке а, и если ... нет в слове а
#
#   =  Простой оператор присваивания значений переменной
#   := Новый оператор присваивания. используется в if и while (см ниже)
#
#   sep = "" - убирает пробелы между значениями, и вставляет туда то что в ""
#   end = "" - возможность не переносить строки. Можно добавить символы в ""
#   \n - в операторе print внутри кавычек, перевод строки
# -----------------------------------------------------------------------------
#   pop - удалить последний элемен из списка, стека или к чему он добавляется
#   push - добавить ......
#   clear - очистить
# -----------------------------------------------------------------------------
# import graphics
# # импорт библиотеки graphics
# window = graphics.GraphWin("Test Window", 100, 100)
# # вызов окна графической оболочки с параметрами
# -----------------------------------------------------------------------------
# ! Раскраска комментариев (плагин Better Comments)
# ? После вопросительного знака
# * После звездочки
# ** после двух звездочек
# // Вот такие два палки в начале, выделяют коментарий
# endregion

import sys     # Простой импорт стандартного модуля sys целиком
import math as ma  # импорт стандартного модуля математических вычислений, с
# переименованием его в модуль ma для дальнейшего использования
import re  # импорт библиотеки разбора фраз, предложений и т.п. по маске

from lib.mymodule import (max3, hello1)  # импорт одной или нескольких
# переменных из внешенего модуля. После скобок, через оператор as можно его
# переименовать. Здесь для импорта необходимо прописывать пути. В частности
# lib - это папка расположения самого модуля относительно данного файла. Через
# точку, указывается название модуля (файла), затем в скобках или без -
# перечисляются импортируемые функции.
from lib.mymodule import*  # Импорт всех функций из модуля, при этом их можно
# как и в предыдущем примере вызывать по их мобственному имени без lib.mymodule

import os  # импорт системной библиотеки для виртуальной среды
import dotenv  # импорт python-dotenv (см virtualenv.md), создание и вызов
dotenv.load_dotenv()  # системных переменных окружения, паролей из файла .env

sys.path.append('./lib/')  # импорт в проект путей/папок проекта, если это
# необходимо. "./" - текущая папка. "../" - родительская папка.

print(sys.version)  # печать версии системы из модуля sys
print(ma.pi)  # печать числа Пи, из модуля math, сокращенного выше до ma

name = os.getenv('MYNAME')  # присваивание имени из системной переменной (.env)
print(name)

key = os.environ.get('MYKEY')  # присваивание пароля из системной переменной
print(key)

print(max3(2, 5))   # Вызов Функции из Внешнего Модуля.
# В Данном Случае Вызыватся Функция Max3 из Модуля Mymodule,

hello1("test")  # вызов функции из внешнего модуля. В данном случае вызыватся
# функция hello1 из модуля mymodule. (в самой функции есть опертаор "print").
# То что стоит в скобках, заменяет параметр по умолчанию, который есть в
# модуле. Если ничего не писать, оставить (), будет использовать значения из
# модуля.

print("""
проверочный текст          #тройными кавычками замыкается текст, чтобы
с условными переносами     #выводить его также как в коде :)
как в коде. Замыкающие обязательно на отдельной строке.
""")

# -----------------------------------------------------------------------------

# *Простое назначение переменных ----------------------------------------------
x: float = 105     # Назначение переменной x, с типом float
y: int = 110     # Назнечение другой переменной y, с типом int
z = int(43.567)  # создание переменной z типа int, со значением 43, при этом
# значение после точки отбрасывается
a = b = c = 120  # присвоение одного значения трем переменным
a, b, c = 80, 90, 100  # Присвеоение значений по типу кортеджа
first, second, *center, last = [2, 4, 6, 8, 12]  # Создание кортеджа через
#  присваивание. Здесь создаются 3 кортеджа. в первый попадает первое значение
# в последний - последнее. Така как *center с * в него вся середина
print(center)
print(a, b, c, sep="-")  # //sep - разделиттель между словами, одновременно
# убираюший пробелы. Если в кавычках пусто - получаем выражение без пробелов
print(a if a > b else b)  # //по выбору из значения.. используем то, что слева
# от if, если соблюдается условие a > b, иначе - используем то что после else

print(a, b)
print(b, c)
print(x, y)
# все эти три записи, поскольку они однотипные можно записать через for:
for p, z in (a, b), (b, c), (x, y):  # p и z - временные переменные цикла for
    print(p, z)  # котрые подсталяют вместо себя значения которые после in

# -----------------------------------------------------------------------------

x: float = 105     # Назначение переменной x, с типом float
y: int = 110     # Назнечение другой переменной y, с типом int
z = int(43.567)  # создание переменной z типа int, со значением 43, при этом
# значение после точки отбрасывается
strochka = 'stroka'  # Назначение переменной типа str
stroka = str("text_key")  # другая запись того же самого
a = b = c = 120  # присвоение одного значения трем переменным
a, b, c = 80, 90, 100  # Присвеоение значений по типу кортеджа

# *Цикл -----------------------------------------------------------------------
print("Циклы")

if x > y:  # if - это Eсли. X > Y это Условие, логическое выражение. Должно
    # возвращать True или False - то есть тип данных на выходе bool (булеан)
    pass  # Тут укаываются операторы. То есть последовательность каких либо
    # действий (например сложение). Обязательный параметр. Если ничего то pass
elif y > x:  # elif - второе условие. Если первое не подошло, смотрится
    pass  # следующее.. и так далее. elif может быть много.
else:  # else иначе. Если ранние условия не выполнены, то выполняется оно.
    print(x - y)  # Любые другие операторы. Если ничего, то pass
    # // else также можно применять к циклу for

# управяющая конструкция для многократного исполнения набора инструкций
# Виды циклов:
# с предусловием - while
while x > y:  # while (ПОКА) выполняется X > Y (Условие). Булево. истина/Ложь
    pass  # Операторы, то есть делать то то... до тех пор пока выполнятеся
    # условие. Ну или ничего - тогда pass. Если условие изначально False, цикл
    # не выполнится ни разу.

while(250 > x > 0):     # Начало цикла с определенным условием (в скобках)
    print(x, end=" = ")  # //печатать x, оператор end - не переносить строку.
    # Если строку надо переносить - пишем "\n"
    print(bin(x))   # оператор возврата двоичного код из числа
    x += 100    # прибавлять к x 100 (при изменении знака - вычитать и т.п.)
    if x > 300:  # Проверка внутри цикла, здесь на Если
        break  # Если условие верно, срабатывает принудительный конец цикла
print(x + 100 + (1 + 1) / 10)   # Печатать то, что внутри скобок

# //с постусловием - do while
# //со счетчиком, и совместный - for

# // Цикл for
words = ["cat", "catty", "worldpress"]  # Список (изменяемый), см. ниже.

for x in words:  # ищет количество букв в словах из списка words
    print(x, "=", len(x), "length", end=", ")  # len - оператор считающий знаки
    print()  # второй ptint добавляет пернос строки, иначе сливается со
    # следующим из за end.

if a > b:  # elif - конструкция совмещающая if и else. Создана чтобы избежать
    pass  # вложенных каскадных конструкций if > else с большими кол-м
elif name:  # вложенностей (см пример в функции). иначе было бы if бла бла бла
    pass  # отступ else отступ if и т.д.

# * (Если не хватает длины строки, все выражение берется в скобки, и тогда
# * Пайтон понимает, что это единая строока). Пример
print(name,
      key)
print()  # пустая строка

# * Вызов исключения ----------------------------------------------------------
assert a < b, "ERROR"  # утверждение. я утверждаю, что a < b, если
# утверждение не верно, выпадает исключение, в котором печатается то что в " "
# -----------------------------------------------------------------------------

# *Сравнение двух значений (вывод результата во втором блоке)------------------


def max2(z, a):   # значения зде
    if z > a:     # известными. Они никак не связаны с конкретными переменными
        return z,   # вернуть
    else:           # "иначе"" (его можно вообще убирать - лишний оператор)
        return a


print(max2("ab", "bc"))   # Параметры берутся из памяти (последние значения,)
# или можно их прописывать числами, или любыми сравниваемыми значениями
# непосредственно здесь, в скобках (если прописать x и y - возьмет из памяти)

hellow2 = "Привет, Василий!"
# Создание строковой переменной

f'{hellow2}'  # f-string, принимающая значение hellow2. Передает содержание
# переменной. на выходе "Привет, Василий!" https://python-scripts.com/f-strings
f'{hellow2=}'  # Строка передает название и значение переменной (новинка P 3.8)
# то есть на выходе: "hellow2 = 'Привет, Василий!'"

name = re.search(r', (.*)!', hellow2)
# имя = бибилиотека re, метод search, (маска разбирающая переменную и ее имя)
if name:  # когда просто # * if name: без всяких условий, сравнений или ==
    # подразумевается "если name == True (то есть оно просто существует)"
    print(name.group(1))  # печатать группу из полученной переменной name
if (name := re.search(r', (.*)!', hellow2)):
    print(name.group(1))
# Тоже самое что в верхнем блоке, но запись с использованием нового оператора
# присваивания ':=' (появился в Питоне 3.8)#//(PeP не обновился. потому ошибка)


# * Работа со строками и списками
# Строки в Пайтон являются неизменяемыми кортеджами. изменить строку нельзя.
# даже через оператор .replace можно создать новую строку на основе имеющейся
# но нельзя изменить текущую
s = "Строка текста"  # создание переменной str
# ? Все что для строк работает и со списками []. Только списки можно изменять
s.find("к")  # поиск в строке элементов к
if "к" in s:  # поиск элементов к в строке s и резултат bool
    pass
s.count("к")  # подсчет кол-ва элементов "к" в строке
s.isdigit()  # является ли строка числом (True или False)
s.isalpha()  # или буквенной строкой
s1 = s.replace("ка", "ку")  # создание новой строковой переменной (строки
# менять нельзя) с измененим ку на ку, получится Строку текста
len(s)  # количество символов в строке. У всех символов есть индексы. индекс
# последнего элемента - "-1", второго с конца - "-2" и т.д.
s[0:5]  # вызов строки по индексу с 0-го по 5-й. Принцип работы с индексами
# как у range, только через : и в кв скобках [start:stop:step]. step не
# обязательный параметр. stop - не включительно.
s[0::2]  # печать каждого второго символа (стоп не указан. просто ::)
s[:-1:2]  # то же самое, только без start
s[:]  # с начала до конца, каждый символ.. то есть просто вызвать строку
s[::-1]  # от края до края с шагом -1, то есть в этом случае от конца к началу
s = s[::2] + s[::-2]  # s от края до края с шагом 2 и добавить s от края до
# края с шагом минус 2 (то есть в обратную сторону)
s = "иванов иван иванович"  # создать строковую переменную
sa = s.split()  # формирование списка sa из строки, split - разделяет строку по
# пробелам
sa[0] = sa[0].upper()  # делает заглавными первое слово (по индексу) списка
# пробелам (см документацию)
s = "-".join(sa)  # собрать обратно строку из списка, в виде разделителей между
# словами указать "-". Основой может быть также кортедж итд. строковые значения
# собирает в принципе все подряд.. Ставится знак разлелитель и вперед. Лучше
# использовать ее, # // чем конструкцию типа res+= value в цикле for
# Если список не строковый: #// ''.join(str(x) for x in my_list) здесь join
# перед применением преобразует все в str и с ним работает.
s.format()  # заполняет строку некими значениями

# -----------------------------------------------------------------------------

# *Списки. Ключевое отличие - квадратные скобки. Внутри, может быть несколько.
# //Списки и массивы.

# Список - тип данных, предстваляющих собой упорядоченную последовательность
# определенных значений, которые могут повторяться. Количество элементов списка
# произвольное. list () Если создавать без функции, то квадратные скобки
list()  # генератор словаря - #// lis = list(lis)
lis = [23, 45.5, "s", [123, 2, 3]]   # Синтаксис создания простых списков. То
# что в отдельных скобках внутри списка - это вложенный список.
lis2 = lis[::-1]  # создание перевернутой (поскольку -1) выборки lis и
#  копирование ее в новый список lis2
lis2[:] = lis  # // перезаписать в списке lis2 значения из списка lis (замена)
pr = lis.pop()  # записать последнее значение списка в переменную pr и рор
# то есть удалить его из списка. В скобках указывается индекс списка
lis[1] = 4  # Замена в списке по индексу (индексы начинаются с 0)
lis[2]  # вызов значения из списка по индексу
ind = lis2.index(23)  # узнать индекс по значению
lis.insert(1, "Hello")  # вставить в список. Первое значение - индекс
lis.append("Hi")        # Добавление в конец списка, без указания индекса
lis = lis + ["!!!"] + [23] + [46]  # Тоже добавить в конец списка.
lis.remove(23)  # Удалить из списка первое найденное значение "23"
lis.pop(2)  # удаление из списка по индексу, в скобках индекс
# list(lis1(1, 3, 5)) - пока не понятно
# Обращение к списку по индексу через [], то что в скобках всегда индекс. При
# этом [top] - это последний заполненный элемент в списке
print(lis)  # Печать списка как он есть (в скобках)
print(lis2)  # lis2 был создан как копия lis, после чего lis менялся. lis2 нет
print(*lis)  # печать только значений из списка (развернутый список)
lis2[0:3] = ["замена", "элементов", "списка"]  # сделать выборку из списка по
# индексам с 0 до 2-го и заменить эти значения на соответствующие после =
lis2[0:3] = []  # удалить индексы 0, 1, 2 из списка
lis2[0] = [1, 2, 3, 4, 5]  # добавить элементы в начало списка. все следующие
# индексы сдвинутся.
# ? Простые числовые списки можно суммировать, искать максимум и т.п.
lis2 = [1, 2, 3, 4, 5, 6]
lis3 = reversed(lis2)  # тоже создание нового перевернутого из текущего списка
lis2.reverse  # инвертирование списка (родительского), без создания нового
set(lis2)  # создание сета (перечень уникальных значений) списка
# // сортировка списков (возможна только если значения однотипные)
lis2.sort()  # сортровка самого списка без создания нового
ls_srt = sorted(lis2)  # новый список сортированный по значению
su = sum(lis2)  # суммировать все значения в списке
min(lis2)  # найти максимальное значение в списке
max(lis2)  # найти минимальное значение в списке
lis2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  # Создание двухмерного списка (типа)
# таблицы, из вложенных списков. Где первая тройка - верхняя строка, средняя -
# средняя, и последняя - нижняя. Отличия, вызов значения по индексу пересечений
lis2[1][1]  # в данном случае вызывается значение по пересечению индекса 1 в
# строке (первый индекс) и индекса 1 в столбце (второй индекс)
print(lis[3][-1])        # Печать значения из списка по индексу. Первое число
# это индекс, второе - либо символ в значении, либо значение из вложенного
# списка. индексы можно выбирать с конца, если печатать со знаком минус.
print(lis[0:3:2])       # Печать списка по индексам. Откуда: Докуда: Шаг. Можно
# пропускать значения, например [::3] - от начала до конца, каждый третий.
sa = s.split()  # формирование списка из строки.

# * Генераторы списков, цикл for  ---------------------------------------------
ran = range(1, 10, 2)  # Создание списка от 1 до 10, с шагом 2. Принцип
# построения range (start, stop, step)
# По такому же принципу, но через оператор for создаются многомерные списки:
n = 3
ran1 = [[0] * n for i in range(n)]  # для каждого i который предстваляет
# range(n), генерируем строку из [0] * n элементов. Или еще другая запись:
ran = [[0 for j in range(n)] for i in range(n)]  # здесь вложенная конструкиция
# [0 for j ...] создает прострой список из n нулей, а затем размножается второй
# частью цикла for i in ...
# Есть еще вариант генерации "ленивых" списков. То же самое что вверху только
# круглые а не квадратные скобки. В этом случае значение формируется
# (вычисляется) только в тот момент когда к нему непосредственно обращаются.
ran = (x for i in range(n))
# Такие Генераторы создаются для временных вычислений, чтобы получить что то
# конкретное на выходе. Использовать генераторы для постоянного хранения
# списков и т.п. не имеет смысла, так как после исполнения удаляются
print(list(ran))  # печать этого списка, через оператор list
print(*ran1)  # также можо вызывать через *. Но ленивые списки так не работают
# если печатать через list, то все берется в доп. скобки

# ? цикл for позволяет пробегать по списку и выбирать значения производя с ними
# какие либо действия, либо делать списки из строк, чисел и т.п.
# формулировка #// [x for x in list if x >0] При такой записи, цикл for создает
# временную переменную x и расшифровыввается как, выбрать х как х в списке list
# если она больше нуля. #// Также для этих целей есть функция map
# Вот еще одно испольщзование, когда надо введенную строку перевести в числа:
# // y = [int(i) for i in input().split()]  # на выходе получим список
# числовых переменных

for ra in range(1, 10, 5):  # для последовательности от 1 до 10 с шагом 5,
    print(ra, end=", ")     # создается переменная ra - печатается в столбик.
print()     # для переноса строки после end=","

for y in range(12, 100, 20):
    print("for range", y**0.5)

ran1 = range(10)  # создается список от 0 до 9

lizz = [x**2 for x in range(10)]  # атвоматическое создание списка, где x -
# несуществующая, временная переменная на время создания списка, на действующий
# x никак не влияет. Создает список из range(10) возводя каждое значение в **2
for x in lizz:  # перебирает список с временной переменной x
    pass
print(lizz)

lizz2 = [x**2 for x in lizz if x % 2 == 0]  # найти в списке lizz четные
# элементы, и возвести в квадрат.. Создав при этом список lizz2
print(lizz2)

lis3 = [[0] * 5 for i in range(3)]  # создание многомерного, в данном случае
# 3-х мерного пустого массива с 5-ю 0-ми значениями в каждой строке

for i, value in enumerate(lis3):  # Если надо получить доступ и к индексу и к
    print(i, value)    # переменной в списке - то используется 2-ая конструкция

# *Кортеджи (Не редактируемые списки) - ключевое отличие - обычные скобки.
# Массив - набор фиксированного количества однотипных элементов, расположенных
# в памяти непосресдственно друг за другом, доступ к которым осуществляется по
# их индексу. - array(). Не могут меняться. Только пересозадваться.
# используются для экономии памяти. Ну и для стабильности работы программы.
cort = (2, 4, 8, 15, 16, 23, 42, "LOST")
cort1 = 3, 5, 9, 16, 17, 24, 43, "No LOST"
# Скобки можно не использовать, все равно создается кортедж
print(cort, cort1)

print(cort[3])  # значения по индексам, достаются так же как в списках
cort2 = tuple("248151623,42")    # Оператор tuple - Создает кортедж по символам
print(cort2)

# *Словари. Те же списки, только используются не индексы, а ключи. Символ {}
# // Словари редактируемы. Не имеют порядка. Ключи уникальны, не изменяемы
dict, {}  # создание пустого словаря
dict()  # тоже создание пустого словаря
di = {"test": 4, "ost": "LOST"}
di1 = dict(shot=8, ne="hlor")   # с использованием переменной dict
di2 = dict.fromkeys([1, "bc", 3], [123, 122])  # всем ключам одно значение.
# в первых скобках - ключи. После запятой - значение. Если единичное - то можно
# значение указывать без квадратных скобок
# // Операции со словарями
"test" in di  # Проверка есть ли ключ в словаре
4 not in di  # Проверка есть ли значение в словаре
di["trulyalya"] = 4  # Добавить в словарь ключ и его значение
di["trulyalya"]  # проверка есть ли в словаре ключ. Кавычки имеют значение.
di.get("dfkjgndk")  # Вызов значения по ключу. Если его нет, вернет None
del di["ost"]  # удалить ключ и значение
print(di)
print(di1["ne"])   # вывод не по индексу, а по ключу. Ключь - в кавычках
print(di2[3])   # Либо без кавычек, если это число.
di3 = {"z": 4, "a": 3}
print(max2(**di3))  # передача значений из списка в функцию (имена аргументов)
# должны совпадать. тогда ** значит передать все аргументы по типу key:value

# *Множества. Те же списки, но при выводе - значения уникальны. Без повторов.
set()  # Генератор множества #// lib = set(lis)  из строки/списка в множество
# Синтаксис - как у словаря. То есть те же фигурные скобки, но без ключей
mnojestvo = {"d", "f", "gh", "d", "f", "jlkghdfkjlgh"}
mnojestvo1 = set("HELLO")   # То же самое, но через оператор set
mnojestvo2 = frozenset("ptintjreorej")  # Множество как кортедж,не изменяемое.
# Причем все элементы множества достаются в случайном порядке.
"jlkghdfkjlgh" in mnojestvo  # проверка есть ли такой объект в множестве, дает
# ответ True или False. Делается чере #// оператор in
# Методы #//add('element'), remove(), discard() - remove без проверки, clear()
print(mnojestvo)
lib = set(lis)  # из строки / списка в множество
