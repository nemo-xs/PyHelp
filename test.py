# Установка виртуальной среды разработки Env:
# -----------------------------------------------------------------------------
# https://www.youtube.com/watch?v=wTh-D8GTjeA
# -----------------------------------------------------------------------------

# 1. Создание вирутальной среды:
# -----------------------------------------------------------------------------
# Создаем папку проекта. Структура - любая, какая удобно. (см предыдущие) Из
# папки проекта, запускаем командную строку (CMD) В командной строке, выполняем
# команду:

#   virtualenv venv
# создает среду отдельным инструментом virtualenv, включая  различные пакеты
# (типа weels и т.п.)

# или

#   py -m venv venv
# создает пустую оболочку, внутри только pip и setuptools, причем pip почему то
# более старой версии чем в головном питоне.

# Итогом, в папке проекта создается папка env с питоном и скриптами.
# -----------------------------------------------------------------------------

# 2. Для установки локальных пакетов в виртуальную среду, в командной строке,
# -----------------------------------------------------------------------------
# запущенной из папки проекта, запускаем команду активатор виртуальной среды:
#     (пробел)venv\scripts\activate

# Для деактивации режима, команда:
#     deactivate

# При активированном env, перед путем командной сроки есть надпись (venv)
# В этом режиме все модули, устанавливаются через pip как обычно. Установка
# происходит в локальные папки проекта.

# При этом для компиляции в Sublime уже создан BuildSys с нужными настройками
# (пути меняются при желании в файле конфигурации)
# -----------------------------------------------------------------------------

# 3. Для включения синтаксиса Анаконды в виртуальной среде, заходим в настройки
# -----------------------------------------------------------------------------
# проекта. В нем после folders добавляем ключ settings, с указанным ниже
# настройками, естественно раскомментированными. Не забывать про запятую после
# квадратных скобок. Если не работает автозаполнение, нужно переключить
# BuildSystem на AnacondaENV запустить код, и убедится что автозаполнение
# включилось. Потом можно переключаться обратно на PythonENV
# "settings":
# {
#     "python_interpreter": "./venv/Scripts/python",
#     "auto_python_builder_enabled": false
# }
# -----------------------------------------------------------------------------

# Также есть более простой метод. А именно Хук.
# -----------------------------------------------------------------------------
# В папке где лежит запускаемый файл создается файл с уникальным названием:
# .anaconda
# и следующим содержанием:
# {
#     "python_interpreter": "$file_path/venv/Scripts/python",
#     "extra_paths": ["$file_path/venv/Lib/site-packages"]
# }
# Если интерпитатор находит данный файл в папке, то идет запуск интерпритатора
# через virtual venv
# -----------------------------------------------------------------------------

# Работа с GIT.
# -----------------------------------------------------------------------------
# Для начала устанавливается сам git. Есть несколько сборок под Win, две самые
# известные - gitFromWindows, просто git. Есть имеющие интерфейс (GitDesctop),
# но в основном без него. Также есть 2 главных облачных репозитория.

# Github.com - создан для опен сорса. Все опен проекты бесплатные. Есть
# ограничения по приватным проектам. Их там около трех можно создать. Владелец
# - Microsoft...
# https://www.youtube.com/watch?v=fYFiQ7lpfiE

# bitbucket.org - неограниченное количество в том числе приватных проектов.
# Ограничение лишь по количеству пользователей работающих над одним проектом.
# Не больше 5 по моему..

# При этом весь указанный софт имеет стандартные команды через консоль
# -----------------------------------------------------------------------------

# СИНТАКСИС ЯЗЫКА
# Математические операции:
# -----------------------------------------------------------------------------
#   ** - возведение в степень (если значение меньше 1 - то корень)
#   >= - больше или равно, <= - меньше или равно
#   != - не равно
#   // - Целочисленное деление. Дает челое число при делении
#   % - остаток после деления
#   x +=2 - Прибавить (может быть любая операция), цифру после равно
#   == Проверяет равенство, одинаковые ли объекты
# -----------------------------------------------------------------------------

# МОДУЛИ - встраиваемые сторонние библиотеки в свои программы. По правилам PEP8
# всегда находятся в начале файла. Порядок импорта имеет значение. Сначала
# импорт стандартных модулей, затем сторонних, и в конце - своих. -----------
# Для интсаляции модулей из репозитория, через cmd, используется команда:
#     pip install имя_модуля
# Если не прлучается - запуск командной строки от админа.
# Для установки в виртуальную среду - то же самое, только в режиме env (выше)


import sys     # Простой Импорт стандартного модуля sys целиком
import math as ma  # Импорт стандартного модуля математических вычислений, с
# переименованием его в модуль ma для дальнейшего использования
from lib.mymodule import (max3, hello1)  # Импорт одной или нескольких
# переменных из внешенего модуля. После скобок, через оператор as можно его
# переименовать. Здесь для импорта необходимо прописывать пути. В частности
# lib - это папка расположения самого модуля относительно данного файла. Через
# точку, указывается название модуля (файла), затем в скобках или без -
# перечисляются импортируемые функции.

sys.path.append('./bin/')  # Импорт в проект путей/папок проекта, если это
# необходимо. "./" - текущая папка. "../" - родительская папка.

print(sys.version)  # печать версии системы из модуля sys
print(ma.pi)  # печать числа Пи, из модуля math, сокращенного выше до ma

print(max3(2, 5))   # вызов функции из внешнего модуля.
# В данном случае вызыватся функция max3 из модуля mymodule,
hello1("test")  # вызов функции из внешнего модуля. В данном случае вызыватся
# функция hello1 из модуля mymodule. (в самой функции есть опертаор "print").
# То что стоит в скобках, заменяет параметр по умолчанию, который есть в
# модуле. Если ничего не писать, оставить (), будет использовать значения из
# модуля.

print("""
проверочный текст          #тройными кавычками замыкается текст, чтобы
с условными переносами     #выводить его также как в коде :)
как в коде
""")

# Простое назначение переменных ----------------------------------------------
x = 105     # Назначение переменной x
y = 110     # Назнечение другой переменной y

# Цикл -----------------------------------------------------------------------
while(250 > x > 0):     # Начало цикла с определенным условием (в скобках)
    print(x, end=" = ")     # печатать x, оператор end - не переносить строку.
    # Если строку надо переносить - пишем "\n"
    print(bin(x))   # оператор возврата двоичного код из числа
    x += 100    # прибавлять к x 100 (при изменении знака - вычитать и т.п.)
print(x + 100 + (1 + 1) / 10)   # Печатать то, что внутри скобок

# Цикл for
words = ["cat", "catty", "worldpress"]  # Список (изменяемый), см. ниже.
for x in words:  # Ищет количество букв в словах из списка words
    print(x, "=", len(x), "length", end=", ")  # len - оператор считающий знаки
print()  # добавляет пернос строки, иначе сливается со следующим из за end.

# Сравнение двух значений (вывод результата во втором блоке)------------------


def max2(z, a):   # значения здесь - могут быть условные (как неизвестные) или
    if z > a:     # известными. Они никак не связаны с конкретными переменными
        return z,   # вернуть
    else:           # "Иначе"" (его можно вообще убирать - лишний оператор)
        return a


print(max2("ab", "bc"))   # Параметры берутся из памяти (последние значения,)
# или можно их прописывать числами, или любыми сравниваемыми значениями
# непосредственно здесь, в скобках (если прописать x и y - возьмет из памяти)

# Сформировать функцию---------------------------------------------


def hello(name="World"):    # При пустом значении при вызове функции, (ниже по
                            # коду), вызывается то, что в кавычках,
    print("hello", name)    # если значение не пустое - печатается оно


hello()  # Вызывает ранее созданную функцию. Печатает значение переменной по
# умолчанию (см выше)
f = hello   # Переназначение функции на букву (см. ниже)
f("Проверка связи")  # то что внутри скобок добавляется к функции
f()  # Печатает значение переменной по умолчанию, то что в кавычках (см выше)

# Калькулятор (на четрые действия - раскоментировать следующий блок)---------

# n = float(input("Введите первую цифру>  "))
# k = float(input("Введите вторую цифру>  "))
# operation = input("Знак математического действия>  ")
# result = None
# if operation == "+":    # Первый оператор "Если"
#     result = n + k
# elif operation == "-":  # Последующие оперторы "Если"
#     result = n - k
# elif operation == "*":
#     result = n * k
# elif operation == "/":
#     result = n / k
# else:                   # Иначе (можно просто не писать)
#     print("Неизвестное число")
# if result is not None:  # Хрен его знает, откула он знает про is not None
#     print("Результат =", result)

# Списки. Ключевое отличие - квадратные скобки. Внутри их может быть несколько.
lis = [23, 45.5, "s", [123, 2, 3]]   # Синтаксис создания простых списков
lis.append("Hi")        # Добавление в конец списка
lis = lis + ["!!!"]  # Тоже добавить в конец списка.
lis[1] = 4              # Замена в списке по индексу (индексы начинаются с 0)
lis.insert(1, "Hello")  # вставить в список. Первое значение - индекс
lis.remove(23)          # Удалить из списка
# list(lis1(1, 3, 5)) - покаа не понятно
print(lis)              # Печать списка
print(lis[3][-1])        # Печать значения из списка по индексу. Первое число
# это индекс, второе - либо символ в значении, либо значение из вложенного
# списка. Индексы можно выбирать с конца, если печатать со знаком минус.
print(lis[0:3:2])       # Печать списка по индексам. Откуда: Докуда: Шаг. Можно
# пропускать значения, например [::3] - от начала до конца, каждый третий.

ran = range(1, 10, 2)  # Создание списка от 1 до 10, с шагом 2
print(list(ran))  # печать этого списка, через оператор list

for ra in range(1, 10, 5):  # для последовательности от 1 до 10 с шагом 5,
    print(ra, end=", ")     # создается переменная ra - печатается в столбик.
print()     # для переноса строки после end=","

# Кортеджи (Не редактируемые списки) - ключевое отличие - обычные скобки.
# Используются для экономии памяти. Ну и для стабильности работы программы.
cort = (2, 4, 8, 15, 16, 23, 42, "LOST")
cort1 = 3, 5, 9, 16, 17, 24, 43, "No LOST"
# Скобки можно не использовать, все равно создается кортедж
print(cort, cort1)
print(cort[3])  # значения по индексам, достаются так же как в списках
cort2 = tuple("248151623,42")    # Оператор tuple - Создает кортедж по символам
print(cort2)

# Словари. Те же списки, только используются не индексы, а ключи. Символ {}
di = {"test": 4, "ost": "LOST"}
di1 = dict(shot=8, ne="hlor")   # с использованием переменной dict
di2 = dict.fromkeys([1, "bc", 3], [123, 122])  # всем ключам одно значение.
# в первых скобках - ключи. После запятой - значение. Если единичное - то можно
# значение указывать без квадратных скобок
print(di)
print(di1["ne"])   # вывод не по индексу, а по ключу. Ключь - в кавычках
print(di2[3])   # Либо без кавычек, если это число.

# Множества. Те же списки, но при выводе - значения уникальны. Без повторов.
# Синтаксис - как у словаря. ТО есть те же фигурные скобки, но без ключей
mnojestvo = {"d", "f", "gh", "d", "f", "jlkghdfkjlgh"}
mnojestvo1 = set("HELLO")   # То же самое, но через оператор set
mnojestvo2 = frozenset("ptintjreorej")  # Множество как кортедж,не изменяемое.
# Причем все элементы множества достаются в случайном порядке.
print(mnojestvo)

# ----------------------------------------------------------------------------
# ФУНКЦИИ. Создаются через ключевое слово DEF. Отделяются двумя абзацами с
# каждой стороны


def pr(one, two):  # Внутри скобок передаваемые значения (переменные). Их может
    # и не быть, но тогда внутри функции непонятно с чем их ассоциировать.
    print(one, "!!!+-", two)  # тело функции, то есть что она должна делать.
# Например это - функция печати.
    pass  # Используется тогда, когда функция пустая (не делает ничего) Если
# функция пустая и нет этого оператора, то дает ошибку. Ставят когда создают
# шаблон программы.


def summ(a, b):     # создание функции с переменными значениями в скобках
    res = a + b     # Что делать с переменными
    return res      # что надо вернуть на выходе фукнции. Если бы она ничего не
    # возвращала, то тут стояло бы pass


test = summ(10, 20)  # Вызов функции summ с переменными 10 и 20
pr("Number is", test)  # вызов функции pr. В скобках те самые переменные.

# mult = lambda x, y: x * y  # Упрощенная запись функции через оператор Lambda
# формула - название переменной = Lambda значения : что с ними делать.
# Не соответствует PEP8. Работает.. Но правильне записывать так:


def mult(a, b):
    return a * b  # Вот правильная упрощенная запись вместо lambda. Но для
    # сокращения кода, можно испольщовать и так, как указано выше.


print(mult(2, 5))
# ----------------------------------------------------------------------------

# ООП (Объектно ориентированное программирование)
# - создание классов и объектов, на основе классов.

"""docstring for бла бла бла бла
"""     # Описание (справка). Закрывается тройными кавычками на новой строке.


class Car:  # Создание класса
    name = "None"  # Создание аргументов присущих классу. В качестве значения
    speed = 250  # указываются используемые по умолчанию.

    def set(self, name, speed):  # Создание функции внутри класса.
        # Set - функция установки аргументов, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше


class Premium:
    # Конструктор используемый внутри класса, при создании
    def __init__(self, name, speed):  # Создание функции внутри класса.
        # ___init___ - специальный опретатор, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше
        print(self.name, "имеет Скорость", self.speed)  # форма исполнения
        # см пример на мерседесе.
    # super(obj1, self).__init__()  # Пока не понятно. Это из шаблона

    def set(self, name, speed):  # Создание функции внутри класса.
        # Set - функция установки аргументов, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше


class Light(Car):  # Создание подкласса. Внутри скобок указываются родители.
    # Родителей может быть много, указываются через запятую. Все родительские
    # аргументы и функции доступны ниже, при создании объекта.
    wheels = 4  # дополнительные аргументы подкласса. Доступны только в нем и
    # в его дочерних подклассах.


bmv = Car()  # Создание объекта и назначение ему класса
bmv.set("BMV", 125)  # присвоение аргументов согласно порядку в функции(выше)
print(bmv.name, "едет", bmv.speed, "км в час")  # вывод полученного значения

shkoda = Light()  # Cсоздание объекта из подкласса.
shkoda.wheels = 5  # изменение значения подкласса. Если не менять, то берется
# тот который указан в подклассе, по умолчанию.
shkoda.set("Shkoda", 145)  # Испольование и изменение аргументов из
# родительского класса, если не менять, то берутся по умолчанию.
print(shkoda.name, "имеет", shkoda.wheels, "колеса")

mersedes = Premium("Mersedes", 245)  # Создание объекта с помощью конструктора
# класса, в данном случае - Premium. В конструкторе прописываются все
# необходимые в том числе и действия (в данном примере - print).
mersedes.set("Mersedes-Bentz", 250)  # Изменение аргументов, созданных ранее
print(mersedes.name, "едет", mersedes.speed)

# ПРИМЕЧАНИЕ - создание и конструктором и через функцию set в одном классе,
# либо подклассе - работает, но конструктор должен идти раньше функции set.
# Если надо подкласс формировать не через конструктор, а родитель с
# конструктором, то в него надо вставить пустую функцию конструктора. Такую:
# def __init__(self):
#     pass
# ----------------------------------------------------------------------------
