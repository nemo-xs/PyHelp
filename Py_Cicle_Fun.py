# region #// Назначение переменных --------------------------------------------
import re  # импорт библиотеки разбора фраз, предложений и т.п. по маске

# //Переменные
c = ""  # Простое объявление пустой строковой переменной.
d = int()  # Простое объявление переменной типа int
x = None  # объявление переменной (в данном случае совсем пустой, без типа).
y = 5  # объявление второй переменной. На сей раз тип int
x = 10  # теперь перменной задано значение (в реале может появляться откуда
a = 20
b = 30
name = 'name'
key = '3209423-key'
# endregion -------------------------------------------------------------------

# region #* Цикл if и While ---------------------------------------------------
print("Циклы")
"""Цикл while отличается от цикла for тем что не привязан к прокручиванию
конкретного итерируемого объекта, и нужен для того чтобы выполнять некий код
по каким либо условиям n количество раз.
То есть - пролистать книгу с 1-й страницы по последнюю - это цикл for..
А копать от забора и до обеда - это цикл while"""

# управяющая конструкция для многократного исполнения набора инструкций с
# предусловием - while
while x < y:  # while (ПОКА) выполняется X > Y (Условие). Булево. истина/Ложь
    pass  # Операторы, то есть делать то то... до тех пор пока выполнятеся
    # условие. Ну или ничего - тогда pass. Если условие изначально False, цикл
    # не выполнится ни разу.
else:
    pass
# внутри цикла while допускается испольщование else. При этом если внутри while
# есть break, то он перескакивает и через else.. а если на break не попадает,
# и не исполняется первичное условие, то #? 1 раз исполняется else

if a > b:  # elif - конструкция совмещающая if и else. Создана чтобы избежать
    pass  # вложенных каскадных конструкций if > else с большими кол-м
elif name:  # вложенностей (см пример в функции). иначе было бы if бла бла бла
    pass  # отступ else отступ if и т.д.

if x < y:  # if - это Eсли. X > Y это Условие, логическое выражение. Должно
    # возвращать True или False - то есть тип данных на выходе bool (булеан)
    pass  # Тут укаываются операторы. То есть последовательность каких либо
    # действий (например сложение). Обязательный параметр. Если ничего то pass
if 'my' in "my.company":  # если условие выполнилось - True, иначе False
    print('my is in company')
elif y > x:  # elif - второе условие. Если первое не подошло, смотрится
    pass  # следующее.. и так далее. elif может быть много.
else:  # else иначе. Если ранние условия не выполнены, то выполняется оно.
    print(x - y)  # Любые другие операторы. Если ничего, то pass
    # // else также можно применять к циклу for

while(250 > x > 0):     # Начало цикла с определенным условием (в скобках)
    print(x, end=" = ")  # //печатать x, оператор end - не переносить строку.
    # Если строку надо переносить - пишем "\n"
    print(bin(x))   # оператор возврата двоичного код из числа
    x += 100    # прибавлять к x 100 (при изменении знака - вычитать и т.п.)
    if x > 300:  # Проверка внутри цикла, здесь на Если
        break  # Если условие верно, срабатывает принудительный конец цикла
    else:
        continue  # оператор продолжающий действие но с нового цикла (итерации)
    # код идущий после него - пропускается (см цикл for для пояснений)

print(x + 100 + (1 + 1) / 10)   # Печатать то, что внутри скобок
# //с постусловием - do while
# //со счетчиком, и совместный - for

# endregion -------------------------------------------------------------------

# region #*Калькулятор (на четрые действия - раскоментировать следующий блок)-

# n = float(input("Введите первую цифру>  "))
# k = float(input("Введите вторую цифру>  "))
# operation = input("Знак математического действия>  ")
# result = None
# if operation == "+":    # Первый оператор "Если"
#     result = n + k
# elif operation == "-":  # Последующие оперторы "Если"
#     result = n - k
# elif operation == "*":
#     result = n * k
# elif operation == "/":
#     result = n / k
# else:                   # иначе (можно просто не писать)
#     print("Неизвестное число")
# if result is not None:  # Хрен его знает, откула он знает про is not None
#     print("Результат =", result)
# ----------------------------------------------------------------------------
# endregion -------------------------------------------------------------------

# region #* Цикл for ----------------------------------------------------------
# Циклически выполняемая операция (чистка картошки одна за другой)
""" https://www.youtube.com/watch?v=ND4MEy3Iquk как и в любом цикле допустимы
break, continue, совмещение циклов list comprihation и т.п."""

words = ["cat", "catty", "worldpress"]  # Список (изменяемый объект), см. ниже

for x in words:  # ищет количество букв в словах из списка words
    print(x, "=", len(x), "length", end=", ")  # len - оператор считающий знаки
    print()  # второй ptint добавляет пернос строки, иначе сливается со
    # следующим из за end.

# ? вместо 'words' вставляется любой итерируемый объект, то есть все, что можно
# перебирать. список, кортедж, словарь, множество, строка и т.п.

""" Если нужно чтобы итерация прошла определнное количество раз, а содержание
итератора при этом не важно, можно использовать вместо него "_"
"""
for _ in words:
    print("1, ", end="")

# ? Пример использвания цикла for для выборки значений из списка
children = ['ivanov_2000', 'petrov_1990', 'sidorov_2005']  # список детей
# фамилия_год. Задача сформировать список фамилий без года, и с Большой буквы
names = []  # создание пустого списка, который будет примнимать в себя фамилии

"""внутри цикла описаны действия которые будут производится на одной итерации
с каждым элементом исходного списка (итерируемого объекта)"""

for child_name in children:
    """берет элемент списка (ivanov_2000) и split ее в список [ivanov, 2000]
    берет сз этого списка первый элемент и кидает его в lastname."""
    lastname = child_name.split('_')[0].title()
    # lastname = lastname.title()  # Большая Первая Буква каждого элемента
    if lastname.startswith("R"):  # если первая буква lastname это R
        continue  # продолжить цикл со следующей итерации
    """continue - оператор пропускает код на всей текущей итерации и сразу
    переходит на следующую итерацию. при формировании данного списка, исключает
    детей с первой буквой R в фамилии, и в финальный список они не попадают"""
    names.append(lastname)  # append в пустой список каждого значения из цикла

print(names)
""" https://www.youtube.com/watch?v=ND4MEy3Iquk """
# * создание собственного цикла for:
# цикл for пробегает по индексам. в списках - по индексам списка, в словарях -
# по ключам словаря, с строках по каждому симовлу строки. Делается это через
# внутренний механизм python и два его внутренних оператора - иттератора:
# ? iter(x) и next(x)

i = names.__iter__()  # это команда возвращающая итератор элемента
next(i)  # передача метода next созданному итератору, тем самым вызывается
# следующий итерируемый элемент.
next(i)  # снова следующий..и так до тех пор пока они не закончатся.
# как только элементы закончились, при вызове next вылетает исключение
# StopIteration.. Цикл for обрабатывает это исключение и выходит из цикла

iterator = iter(names)
while True:
    try:
        i = next(iterator)
        print(i)
    except StopIteration:
        break
# именно таким образом работает цикл for. То есть он перебирает все имеющиеся
# индексы в списке, и если поймал ошибку StopIterration - выходит из цикла
# она полностью аналогична записи:
for i in names:
    print(i)
# на основании указанных итераторов можно писать собственные циклы for для
# собственных классов. при их создании есть специальный конструктор для
# создания итераций __next__
# // next(x) - аналогичная запись для конструктора x.__next__() то есть x
# внутри класса является итератором, когда у него есть метод __next__, а для
# того чтобы его можно было использовать в цикле for - метод __iter__
# через такие конструкторы можно создавать свои классы, которые, например
# перебирают элементы парами.
# видео по созданию класса iterrator
# ? https://stepik.org/lesson/24464/step/2?unit=6769

# * list comprihation
# ? Подобная запись в 2 раза быстрее варианта через цикл. Поскольку нет .append
# * (values) = [(expression) for (value) in (collection) if (condition)]
# ? list_res = [x for x in list]
""" Сокращает запись, синтаксический сахар. [каждый х как х в списке list].
Первое значение, что мы хотим получить, а затем цикл for.
Вот более применимая в жизни форма, возвращающая список значений х подходящих
по условию > 0 в списке list, и возведя каждое из них в квадрат:
# ? list_res = [x * x for x in list if x > 0]
[каждый х умножить на х для(for) каждого х из списка(List), для x которые > 0]
на выходе получим сгенерированный список, содержащий модифицированную выборку
Указанная строка полностью идентична приведенной ниже форме:
list_res = []
for x in list:
    if x > 0:
        x = x * x
        list2.append(x)
"""
# циклов for внутри может быть несколько, как и if
# если вместо [] поставить () - на выходе подучим не лист, а генератор
lizz = [x**2 for x in range(10)]  # атвоматическое создание списка, где x -
# несуществующая, временная переменная на время создания списка, на действующий
# x никак не влияет. Создает список из range(10) возводя каждое значение в **2
# вместо range может быть другой список и т.п.

for x in lizz:  # перебирает список с временной переменной x
    pass
print(lizz)

lizz2 = [x**2 for x in lizz if x % 2 == 0]  # найти в списке lizz четные
# элементы, и возвести в квадрат.. Создав при этом список lizz2
print(lizz2)

lis3 = [[0] * 5 for i in range(3)]  # создание многомерного, в данном случае
# 3-х мерного пустого массива с 5-ю 0-ми значениями в каждой строке

for i, value in enumerate(lis3):  # Если надо получить доступ и к индексу и к
    print(i, value)  # переменной в списке - то используется конструкция
    # enumerate

# * цикл for позволяет пробегать по списку и выбирать значения производя с ними
# какие либо действия, либо делать списки из строк, чисел и т.п.
# формулировка #// [x for x in list if x >0] При такой записи, цикл for создает
# временную переменную x и расшифровыввается как, выбрать х как х в списке list
# если она больше нуля. #// Также для этих целей есть функция map
# форма записи, когда надо введенную с клавиатуры строку перевести в числа:
# // y = [int(i) for i in input().split()]  # на выходе получаем список
# числовых переменных

for ra in range(1, 10, 5):  # для последовательности от 1 до 10 с шагом 5,
    print(ra, end=", ")     # создается переменная ra - печатается в столбик.
print()     # для переноса строки после end=","

for y in range(12, 100, 20):
    print("for range", y**0.5)

ran1 = range(10)  # создается список от 0 до 9
# endregion -------------------------------------------------------------------

# region #* else в исполняемых циклах (while, for и тд.) -------------
""" вариантов у любого цикла всего 2. Или он прокручивается до самого конца,
или прерывается инструкцией break. В любом случае, что в 1-м, что во 2-м
исполнение продолжается сразу далее за пределами оконченного цикла.
Else в циклах введен именно на тот случай, когда исполнение завершается
естественным путем."""
""" обычно, при наличии else в циклах, предполагается, что там, в каком либо
месте есть break. Чтобы else срабатывал как исключительный случай, поскольку
если цикл завершается break, управление не переходит в блок else.
"""
for i in range(5):
    """в данном цикле если цикл прерывается по break, то else пропускается.
    Если же он закончится так и не перейдя на break, исполнится else"""
    if i == 2:  # поменять на 6-ку и цикл не исполнится, перейдя в else
        print(i)
        break
else:  # // else в данном случае определен не для if, а для for
    print('This is the end')

""" #? пример использования - в банкомате. Запускается цикл проверки введеного
пин кода с тем, который известен циклу. Если введен правильный пин, else
пропускается. Если три раза ввели не правильный, срабатывает else
То есть использование else в циклах оправдано, когда предполагается, что цикл
не должен завершится естественным путем. Исключительная ситуация"""
""" Самый распространенный метод использования таких конструкций - циклы поиска
Что то ищем внутри итерируемого объекта. И если находим то выполняем какие то
инструкции.. Затем break и вышли из цикла. Если не находим, то else."""
# endregion -------------------------------------------------------------------

# region #* Функция map() как частная альтернатива цикла for ------------------
# ? map(function, *iterible)
# // Элемент функционального програмирования. Часто сочетается с lambda
""" в качестве аргументов принимает функцию и какой либо итерируемый объект.
занимается тем, что применяет выбранный обработчик к каждому элементу
итеррируемой последовательности. #? Фактически это цикл for для функций.
в качестве результата возрвщает map объект, который является итератором, и
который можно преобразовать в список.
"""


def upper(string):
    return string.upper()


lister = ['one', 'two', 'three']
new_lister = map(upper, lister)
""" в map передается upper как объект, без () - иначе она будет вызвана. А 2-м
аргументом передается список """
print(new_lister)  # получаем map объект созданного списка.
print(*new_lister)  # получаем развернутый map объект (список), в виде строки.
# либо, если нужен именно список на выходе - можно иначе:
new_lister = list(map(upper, lister))  # здесь мы сразу получили список внутри.
print(new_lister)  # Поскольку внутри уже готовый список, его и получаем

new_lister2 = map(lambda string: string.upper(), lister)
"""такая запись делает тоже самое что функция выше, но через лямбду. До запятой
указана запись функции lambda, а после запятой - список.
Опять таки, если обернуть в оператор list, на выходе получим список. Вот так:
"""
new_lister2 = list(map(lambda string: string.upper(), lister))
print(new_lister2)  # чтобы и список раскрылся, можно добавить *

# ? функция map может быть легко замен на простой цикл for следующей записью:
new_lister = [string.upper() for string in lister]  # это нагляднее map()
print(new_lister)
# ? все указанные результаты полностью идентичны. Везде на выходе список.

# d,t = map(int, input().split())  #* ввод списка из терминала через map
# считываем 2 int числа через map, от input().split(), где split разбивает ввод
# на 2 строки в одном списке, по умолчанию через пробел.
# такой синтаксис работает только если мы введем число значений равное числу
# определенных переменных (d, t). Иначе ошибка.
# Это можно обойти.. функция map работает по следующему принципу:
# // map делает: func[a, b, c...] = func(f), func(b), func(c)...
# одновеременно, он является итератором, то есть считывает в себя как в объект
# все значения, а затем выдает их по одному.
# // когда неизвесто что введет пользователь можно делать так:
# map_obj = map(int, input().split())  # вводим несколько чисел как в объект
# map1 = next(map_obj)  # вызываем первое введенное значение в новую переменную
# map2 = next(map_obj)  # вызываем следующее введенное значение и т.д.
# тоже самое можно сделать без map
# d, t = (int(i) for i in input().split())  #// тоже самое через for (строка)
# dt = [int(i) for i in input().split()] #// тоже самое но список на выходе
# endregion -------------------------------------------------------------------

# region #* Функция filter() как частная альтернатива цикла for ---------------
""" https://www.youtube.com/watch?v=H4AlLQnEXDY """
# ? filter(func, iterible)
""" Применяет правило фильтрации из функции к элементам последовательности.
Первый аргумент - фильтрующая функция, второй аргумент - последовательность
(любой итеррируемый объект)
в качестве результата возрвщает filter объект, который является итератором"""


def has_o(string):
    """ функция проверяет есть ли в строке 'o'. Возвращает True или False"""
    return "o" in string.lower()


new_lister = filter(has_o, lister)  # родительский lister создан выше,в map()
""" функция has_o передается в аргументы как объект, без ()вызова. В таком виде
возвращает итератор (обект filter). Чтобы получить список надо так:"""
new_lister = list(filter(has_o, lister))
"""Только те элементы которые имеют в своем составе 'o', попали в список.
# ? Как и map(), можно использовать с lambda()"""
new_lister = list(filter(lambda string: "o" in string.lower(), lister))
print(new_lister)

# // все тоже самое можно записать чере listComprihation цикла for
new_lister = [string for string in lister if has_o(string)]

# // для фильтрации вводимых элементов, можно делать так:
# dt = filter(x % 2 == 0, (int(i) for i in input().split()))
# //пропускает введенные значение через фильтр (либо можно дать готовый список)
# либо вместо x % 2 == 0, сослаться на готовую функцию
# такой же итератор как и map, и также работает через методы list и т.п.
# dt = list(filter(func, dt) - #// отфильтровать значения и сделать список
# endregion ------------------------------------------------------------------

# region #* Генераторы списков ------------------------------------------------
ran = range(1, 10, 2)  # Создание списка от 1 до 10, с шагом 2. Принцип
# построения range (start, stop, step)

# Если необходимо вызвать генератор (например в функцию print), используется *
print(*range(10))
# в этом случае генератор сначала полностью отрабатывает свой цикл и только
# ? после этого передает полученный результат вызывающей функции

# По такому же принципу, но через оператор for создаются многомерные списки:
n = 3
ran1 = [[0] * n for i in range(n)]  # для каждого i который предстваляет
# range(n), генерируем строку из [0] * n элементов. Или еще другая запись:
ran = [[0 for j in range(n)] for i in range(n)]  # здесь вложенная конструкиция
# [0 for j ...] создает прострой список из n нулей, а затем размножается второй
# частью цикла for i in ...
# Есть еще вариант генерации "ленивых" списков. То же самое что вверху только
# круглые а не квадратные скобки. В этом случае значение формируется
# (вычисляется) только в тот момент когда к нему непосредственно обращаются.
ran = (x for i in range(n))
# Такие Генераторы создаются для временных вычислений, чтобы получить что то
# конкретное на выходе. Использовать генераторы для постоянного хранения
# списков и т.п. не имеет смысла, так как после исполнения удаляются
print(list(ran))  # печать этого списка, через оператор list
print(*ran1)  # также можо вызывать через *. Но ленивые списки так не работают
# если печатать через list, то все берется в доп. скобки

# endregion -------------------------------------------------------------------

# region # * Генератор yield --------------------------------------------------
""" используется вместо оператора return, позволяет вернуть значение несколько
раз. То есть при return функция возвращает значение и прекращает работу. при
yield - возвращает значение и продолжает работу (одновременно запоминая
состояние на котором остановилась). Можно вызывать несколько раз

Разница между yield и return в том, что если указан return, то функция хранит
промежуточный результат свое работы в виде каких то внутренних данных... Если
же испольщовать yield, то получаемые данные постоянно выплевываются во вне.
То есть return это стоп, а yield - пауза.

Кроме того, return возвращает возможность исполнения кода в место вызова лишь
тогда, когда вся функция закончила работу. И при повторном ее вызове, весь
процесс происходит заново.

Yield же возвращает результат частями, и при повторном вызове функции с yield
он продолжает работу с того места где закончил, то есть с кода идущего сразу
вслед за yeild, и продолжает исполнение. Его локальные переменные сохраняют
свое состояние, и могут быть вызваны с того места, где закончили.

* Yield часто испольщуется в поисковых системах, чтобы вытащить из базы не
сразу 100 000 000 результатов, а выдать первые 40 найденных. При повторном
запросе еще 40 и так далее."""
# ? https://www.youtube.com/watch?v=ZjaVrzOkpZk
# https://stepik.org/lesson/24464/step/3?unit=6769
# https://www.coursera.org/learn/diving-in-python/lecture/3Ufax/gienieratory


def countdown(n):
    """ Задача собрать 100 яблок в цикле по 1-му. Это return. Он собирает и
    возвращает 100 яблок. """
    result = []
    while n != 0:
        result.append(n - 1)
        n -= 1
    return result


def get_countdown(n):
    """ Задача собрать 100 яблок в цикле по 1-му через yield. Он должен стоять
    внутри цикла. Тогда он соберет 1 яблоко и отдаст. Если вызвать снова, он
    помнит что уже собрал 1 яблок, то есть вернется на шаг yield в цикле,
    соберет еще и выдаст запрошенный результат. И так до тех пор, пока не
    соберет все 100 яблок. И лишь когда соберет все 100 (то есть функцию
    вызовут 100 раз), входное условие цикла не исполнится, и yield ничего не
    вернет. """
    while n != 0:
        yield n - 1
        n -= 1


g = get_countdown(100)
print(next(g))  # вызов через внутрненюю функцию иттератора (next) след. знач.
print(next(g))


def accumulyator():
    """Между моментом когда генератор выплюнул результат и ждет следующего
    вызова, в него можно добавить какие то значения, атрибуты. Через этот
    механизм можно реализовать аккумулятор значений
    функция накапливает значения """
    total = 0
    while True:
        value = yield total
        print("got: ", value)

        if not value:
            break
        total += value


generat = accumulyator()  # вызов функции. на выходе ничего, доходим до yield,
# выдает текущее значение value в основной код и ждет дальнейшего вызова
next(generat)  # следующий вызов генератора. Проходит дальше по циклу, a
# поскольку value = 0 то выскакивает через break
print("Accumulated: ", generat.send(1))  # вызов с передачей значения через
# метод send, который передается в generat в точку цикла где стоит yield.
# Поскольку в этом месте идет присвоение value, значение присваивается ему.
# Цикл проходит с переданным значением value, прибавляется к total, доходит до
# yield и значение выплевывается в виде total, и т.д.
print("Accumulated: ", generat.send(3))  # повторный вызов как выше..
# endregion -------------------------------------------------------------------

# region #* цикл try - механизм исключений ------------------------------------
""" https://www.youtube.com/watch?v=LRudk3FQLoM """
# // используется когда неизвестно какие даные будут получены на вход.
# блок try может быть где угодно в коде, внутри функции, вызова, класса и т.п.
""" Такая конструкция нужна для перехвата и обработки возникающих исключений.
При исполнении участка кода, пробует исполнить то, что указано после try.
Если исключений не возникло - идет на else и тд. Если возник определенный тип,
делает то, что указано для этого типа. Если except не содержит типа, то ловит
любое исключение, и исполняет то, что стоит в этом exсept и т.д.
инструкция except - перехватывает все исключения, которые только могут быть.Для
ее избирательности необходимо после метода указывать тип ожидаемых исключений.
Exception это событие (объект Python) которое предстваляет из себя ошибку.
---------
Кроме Exception существует базовый тип Warning. Принцип тот же, но ошибки менее
критичные. Наследуется от Exception. Для пользовательских предупреждений нужен
UserWarning. Вызов по форме:
#// warning.warn('Внимание.. Сообщение об ошибке')
Код при этом не прерывается. Выводится сообщение и код продолжает исполнение.
---------
Обычной практикой в блок try ставят лишь одну строку критическую.. Если
получаем исключение, то оно борабатывается. Если же строка выполнена корректно
то весь остальной код необходимый для исполнения ставят в блок else, который
исполняется только тогда когда исключений во время исполнения try не возникло
"""
try:  # пробуем
    a = 1 / 0  # сделать то то..
except NameError:  # проверить на ошибки NameError (название базового или
    # созданного класса объекта исключения).
    print('NameError')  # что делать если возникло исключение указанного типа
except Exception:  # станадртный обработчик исключений (самый обширный)
    print('oops')  # делать то то и то то...
else:  # если никаких исключений не возникло, то
    pass
finally:  # скрипт который выполняется в любом случае (необязательный)
    print("Погнали дальше")

# ? пример использования
# если вместо x поставить несуществующую переменную, то возникнет исключение
try:  # пробовать исполнить код. Хорошим тоном - только одна строка внутри try
    print(x)  # для деомонстрации надо поставить несуществующую перменную
except NameError as e:  # обработка ошибок.. если тип ошибки NameError
    # вывести ее в консоль
    print(type(e))  # класс к которому принадлежит ошибка
    print(e.args)  # ее аргументы
    print(e)  # сам текст ошибки (то же что и аргументы)
    print('Ошибка имени')  # произвольный вывод..
    # // также вместо принтов можно скриптовать какие либо действия
# except блоков может быть много.
except(TypeError, TimeoutError):  # типы можно комбинировать через кортедж
    print('Любая другая ошибочка')
# При этом само исключение не возникает. То есть происходит проверка исполнения
# и отработка действия. Если код прошел, то он просто исполняется.
# ? Только если ошибка не возникла, исполняeтся следующий за ним блок else
else:
    print(x, "Ошибка не возникла")
# метод raise для того чтобы самостоятельно создавать исключения. То есть, в
# данном случае, если соблюдается условие для else, py выдаст в консоль ошибку
# типа ValueError с пояснением из скобок
finally:  # ? блок который запускается в любом случае. #* он важнее даже return
    """ механизм работы... когда код видит finally он подставляет его значение
    перед вызовом return, так, как будто оно написано перед ним, а не после.
    типовое исользование - закрытие файлов, соединений с базой данных или иные
    действия необходимые для освобождения рессурсов"""
    pass

""" механизм исключений используется когда допускается какая либо ошибка во
время выполнения скрипта """

# * raise BaseException("Тут пишем текст который вылазает при исключении")
# raise команда вызывающая исключение, со ссылкой к классу исключений.
# в классе исключений BaseException есть много подклассов. Можно писать свои,
# но они должны быть дочерними по отношению к BaseExceprion
# * exit()
# команда полностью завершающая программу и прекращающая выполнение всего кода
# даже если она встречается внутри цикла, какого либо подцикла функции и т.п
"""
Исключения можно вставлять друг в друга, выстраивать из них циклы (в.т.ч. from)
Предыдущее исключение всегда попадает в атрибут данных __context__. Для связи
исключений в цикле используется:
#// raise новое_исключение from старое_исключение
В этом случае исключение сохраняется в __cause__ и атрибут __supress_context__
становится True. И если новое при этом не обработано, значит старое - причина!
#// raise новое_исключение from None
Здесь __supress_context__ становится True и __cause__ в None. При выводе,
старое исключение будет заменено новым, а старое будет в __context__
"""

# * Вызов исключения ----------------------------------------------------------
assert a < b, "ERROR"  # утверждение. я утверждаю, что a < b, если
# утверждение не верно, выпадает исключение, в котором печатается то что в " "

# endregion -------------------------------------------------------------------

# region #* ФУНКЦии. Они же Подпрограммы. Процедуры. --------------------------
""" Это именованный участок кода, к которму можно неоднократно обращаться.
Объекты первого класса. Могут принимать параметры (аргументы) и возвращать
значения. А могут и не возвращать. Когда не возвращает, то на самом деле
возвращает значение None.
Функции - это объекты. Имеют свои методы, могут быть присвоены переменным, их
можно передавать в качестве аргументов в другие функции, их можно возвращать.
Функции могут быть вложенными
"""
# // Название функций всегда осмысленное, как кличка у человека. Отвечает на
# вопрос "что она делает", а документация на вопрос "зачем". Название должно
# отражать суть хранимого в функции действия.

# // Принцип единой ответственности. Функция должна выполнять только ту задачу
# для которой она была создана. Чем уже и проще, тем лучше.

# //Всегда отделяется от кода двумя абзацами сверху и снизу. Создается через
# единый оператор def. После создания может использоваться путем вызова
# множество раз.

# //Имеет параметры и аргументы. Параметры это локальные переменные внутри
# функции. Аргументы, это данные передающиеся в нее извне

# //Есть вшитые функции: int, input, print, id и другие.
# Список и описание функций - https://youtu.be/KSL_32HvBew
# Справка по любой функции вшита. Вызывается help(название функции)

# //Все функции возвращают значения. Если не указано что именно return, то
# возврщаемым значением является None. По правилу хорошоего кода, во всех
# функциях должен имется return, и если ничего не надо возвращать return None

# // return - всегда завершает работу функции, где бы оно не встретилось, оно
# возвращает указанное значение во внешний код, а работа функции прекращается.
# все что написано после return работать не будет, кроме блока finally, который
# умеет подставлять себя из любого участка кода функции непосредственно перед
# return

# // map() - 1-м аргументом принимает имя функции, 2-м - последовательность,
# и итерирует через цикл for последовательность из 2-го аргумента. Синтаксис:
# map(function_name, list)

# // вызов результата функции в другую функцию - через *. Если результат
# вызываемой функции это какое либо множество (а особенно генерируемое), то
# при ее вызове перед именем вызываемой функции ставят *, чтобы раскрыть
# результат. Например print(*range(10)) - делается для того чтобы сначала
# полностью отработал range и сгенерировал всю последовательность, а затем
# через * раскрылся и передал родительской функции чистый результат
# // если раскрывать результат не надо, то и * указывать не надо


def funct():  # func это название функции. В скобках, ее параметры. Если
    # параметров много, то через ",". Тут формальные параметры. Меняются при
    # вызове (см ниже).
    """ документация к функции, название, расшифровка аргументов
                                                   пустая строка
    и затем дается расширенная документация
    """
    # внутри тройных кавычек документация к функции. Закрывающие кавычки
    # ставятся на отдельной строке. Не обязательный параметр.
    pass  # Тут расписывается то, что она делает. То есть сама подпрограмма.


funct()  # а это вызов функции в любом месте кода. Внутри скобок указывается
# локальное значение, то есть то, с каким аргументом она используется. То есть
# фактический параметр. или пустые скобки. Тогда применяется формальный.

""" Функциям можно присваивать переменные, и потом с ними работать """
l1 = funct  # присваивание функции переменной, поэтому после one нет (). Иначе
# она будет вызываться и в l1 попадет результат ее работы, а не она сама.
deco = l1()  # вызов функции через переменную, которую ей присвоили.

# *Сформировать функцию---------------------------------------------


def hello(name="World"):    # При пустом значении при вызове функции, (ниже по
    # коду), вызывается то, что в кавычках,
    print("hello", name)    # если значение не пустое - печатается оно


hello()  # Вызывает ранее созданную функцию. Печатает значение переменной по
# умолчанию (см выше)
h = hello   # Переназначение функции на букву (см. ниже)
h("Проверка связи")  # то что внутри скобок добавляется к функции
h()  # Печатает значение переменной по умолчанию, то что в кавычках (см выше)


def some_func(x, y, /):
    # создание функции с позиционным аргументом "/" При его применении значения
    # берутся строго по маске записи.#// Нов Пайтон 3.8 (из за этого ошибка)
    print(x, y)
    # вот так print(x=10, y=20) - писать нельзя.


some_func(1, 2)
# передача в функцию значений по маске. Если в функции стоит "/", вот такую
# запись some_func(x=1, y=2) сделать уже нельзя.
# ----------------------------------------------------------------------------

# *Сравнение двух значений -------------


def max2(z, a):   # значения где z и a это аргументы
    try:
        if z > a:  # Никак не связаны с глобальными переменными - x в формуле
            return z,  # вернуть
        else:  # "иначе"" (его можно вообще убирать - лишний оператор)
            return a
    finally:
        print('демонстрация finaly')  # которая ставит себя перед return


print(max2("ab", "bc"))   # Параметры берутся из памяти (последние значения,)
# или можно их прописывать числами, или любыми сравниваемыми значениями
# непосредственно здесь, в скобках (если прописать x и y - возьмет из памяти)

# ----------------------------------------------------------------------------
# * ФУНКЦи. Создаются через ключевое оператор def. Отделяются двумя абзацами с
# каждой стороны


def pr(one, two, *args):  # Внутри скобок передаваемые значения (переменные).
    # их может и не быть, но тогда внутри функции непонятно с чем их
    # ассоциировать.
    # // *args значит + неопределенное число аргутменов. Ключом является *
    # ? при вызове, * не указывается
    # означает передачу неограниченного числа аргументов. Например когда надо
    # сделеть функцию сложения, а сколько элементов будет передано не известно
    # Во время исполнения функции вместо args формируется кортедж из всех
    # лишних переданных аргументов, и уже в функции используется
    # Если на фход передается не кортедж, а, например, список, то при вызове
    # перед именем списка ставится * (этот синтаксис раскрывает список)
    # // **kwargs - означает что на входе ожидается словарь. Ключом являются **
    # ? при вызове, ** не указываются
    # Если подан не словарь, он будет сформирован при вызове, из полученных пар
    # ключ/значение "a"=40, "b"=30 итд.
    print(one, "!!!+-", two, args)  # тело функции, то есть что она должна
    # делать. Например это - функция печати.
    pass  # используется тогда, когда функция пустая (не делает ничего) Если
# функция пустая и нет этого оператора, то дает ошибку. Ставят когда создают
# шаблон программы.


def summ(a: "int, >0", b: int):  # создание функции с переменными в скобках
    """ при такой записи, указанные через : значения int и 'int > 0'- это всего
    лишь один из видов документации, на работу самой функции не влияют. то есть
    в данном случае можно подать и строки. запись оставляется создателем, как
    документация, чтобы пояснить что прогрмаист имел в виду при ее создании
    """
    res = a + b     # Что делать с переменными
    return res      # что надо вернуть на выходе фукнции. Если бы она ничего не
    # возвращала, то тут стояло бы pass


ok_stat = 'ok'
test = summ(10, 20)  # Вызов функции summ с переменными 10 и 20
pr("Number is", test)  # вызов функции pr. В скобках те самые переменные.


def mult(a, b):
    return a * b  # Вот правильная упрощенная запись вместо lambda. Но для
    # сокращения кода, можно испольщовать и так, как указано выше.


def mu(*a):  # При такой записи (*a) функция может принимать неопределнное
    # число аргументов. хоть 1 хоть 100 (список), а если **a - то словарь. Если
    # принимается словарь, то запись вида a=10, b='str' итп.
    global ok_stat  # обращение к глобальной переменной
    # nonlocal ok_stat для обращения к нелокальной переменной (используется во)
    # вложенных функциях (функция в функции)
    # Есть области пространства имен: #// local, non-local, global, built-in
    pass


print(mult(2, 5))


# * lambda функции ------------------------------------------------------------
# используется когда запись функции не имеет смысла (применяется 1 раз)
# синтаксис: lambda arguments: x % 2 == 0
# то есть lambda, затем аргументы до : затем что надо сделать или функция
# допускается только одна функция или одно выражение

# //mult = lambda x, y: x * y - Упрощенная запись функции через оператор Lambda
# формула - название переменной = Lambda значения : что с ними делать.
# Не соответствует PEP8. Работает.. Но правильне записывать так:

# // lambda может использоваться в качестве данных в словрях, пример:
d = {'sum': lambda x, y: x + y, 'sub': lambda x, y: x - y}
print(d['sum'](10, 5))
# -----------------------------------------------------------------------------


# * Созадние функций, работа которых основана на работе других функций
# данная методика испольуется для создания бОльших абстракций, расширения
# функционала имеющихся типов/методов/функций/классов и своих собственных
def print_wrapper(text):
    """ в данной функции расширяется базовый функционал print за счет
    использования его же собственного метода и встроенного аргумента file
    """
    with open('./src/test2.txt', "a") as f:
        print(text, file=f, end='')


print_wrapper(1)  # созданная функция не выводит на экран принимаемый аргумент
# а производит его запись в создаваемый во время исполнения файл

""" Существует модуль functools в стандартной библиотеке. В нем множество
инструментов облегчающих создание функций, по принципу, map, filter и т.п.
Там же есть наборы методов декораторов"""

# endregion -------------------------------------------------------------------
