# region #** Назначение переменных
import re  # импорт библиотеки разбора фраз, предложений и т.п. по маске

# //Переменные
c = ""  # Простое объявление пустой строковой переменной.
d = int()  # Простое объявление переменной типа int
x = None  # объявление переменной (в данном случае совсем пустой, без типа).
y = 5  # объявление второй переменной. На сей раз тип int
x = 10  # теперь перменной задано значение (в реале может появляться откуда
a = 20
b = 30
name = 'name'
key = '3209423-key'
# endregion -------------------------------------------------------------------

# region #* Цикл if и While ---------------------------------------------------
print("Циклы")

if x < y:  # if - это Eсли. X > Y это Условие, логическое выражение. Должно
    # возвращать True или False - то есть тип данных на выходе bool (булеан)
    pass  # Тут укаываются операторы. То есть последовательность каких либо
    # действий (например сложение). Обязательный параметр. Если ничего то pass
elif y > x:  # elif - второе условие. Если первое не подошло, смотрится
    pass  # следующее.. и так далее. elif может быть много.
else:  # else иначе. Если ранние условия не выполнены, то выполняется оно.
    print(x - y)  # Любые другие операторы. Если ничего, то pass
    # // else также можно применять к циклу for

# управяющая конструкция для многократного исполнения набора инструкций
# Виды циклов:
# с предусловием - while
while x < y:  # while (ПОКА) выполняется X > Y (Условие). Булево. истина/Ложь
    pass  # Операторы, то есть делать то то... до тех пор пока выполнятеся
    # условие. Ну или ничего - тогда pass. Если условие изначально False, цикл
    # не выполнится ни разу.
else:
    pass
# внутри цикла while допускается испольщование else. При этом если внутри while
# есть break, то он перескакивает и через else.. а если на break не попадает,
# и не исполняется первичное условие, то #? 1 раз исполняется else

while(250 > x > 0):     # Начало цикла с определенным условием (в скобках)
    print(x, end=" = ")  # //печатать x, оператор end - не переносить строку.
    # Если строку надо переносить - пишем "\n"
    print(bin(x))   # оператор возврата двоичного код из числа
    x += 100    # прибавлять к x 100 (при изменении знака - вычитать и т.п.)
    if x > 300:  # Проверка внутри цикла, здесь на Если
        break  # Если условие верно, срабатывает принудительный конец цикла
print(x + 100 + (1 + 1) / 10)   # Печатать то, что внутри скобок

# //с постусловием - do while
# //со счетчиком, и совместный - for

# ----------------------------------------------------------------------------
# *Калькулятор (на четрые действия - раскоментировать следующий блок)---------

# n = float(input("Введите первую цифру>  "))
# k = float(input("Введите вторую цифру>  "))
# operation = input("Знак математического действия>  ")
# result = None
# if operation == "+":    # Первый оператор "Если"
#     result = n + k
# elif operation == "-":  # Последующие оперторы "Если"
#     result = n - k
# elif operation == "*":
#     result = n * k
# elif operation == "/":
#     result = n / k
# else:                   # иначе (можно просто не писать)
#     print("Неизвестное число")
# if result is not None:  # Хрен его знает, откула он знает про is not None
#     print("Результат =", result)
# ----------------------------------------------------------------------------

# endregion -------------------------------------------------------------------

# region #* Цикл for ----------------------------------------------------------
words = ["cat", "catty", "worldpress"]  # Список (изменяемый), см. ниже.

for x in words:  # ищет количество букв в словах из списка words
    print(x, "=", len(x), "length", end=", ")  # len - оператор считающий знаки
    print()  # второй ptint добавляет пернос строки, иначе сливается со
    # следующим из за end.

# ? вместо 'words' вставляется любой итерируемый объект, то есть все, что можно
# перебирать. список, кортедж, словарь, множество, строка и т.п.

if a > b:  # elif - конструкция совмещающая if и else. Создана чтобы избежать
    pass  # вложенных каскадных конструкций if > else с большими кол-м
elif name:  # вложенностей (см пример в функции). иначе было бы if бла бла бла
    pass  # отступ else отступ if и т.д.

# * (Если не хватает длины строки, все выражение берется в скобки, и тогда
# * Пайтон понимает, что это единая строока). Пример
print(name,
      key)
print()  # пустая строка

# * Вызов исключения ----------------------------------------------------------
assert a < b, "ERROR"  # утверждение. я утверждаю, что a < b, если
# утверждение не верно, выпадает исключение, в котором печатается то что в " "
# -----------------------------------------------------------------------------

# * Генераторы списков, цикл for  ---------------------------------------------
ran = range(1, 10, 2)  # Создание списка от 1 до 10, с шагом 2. Принцип
# построения range (start, stop, step)
# По такому же принципу, но через оператор for создаются многомерные списки:
n = 3
ran1 = [[0] * n for i in range(n)]  # для каждого i который предстваляет
# range(n), генерируем строку из [0] * n элементов. Или еще другая запись:
ran = [[0 for j in range(n)] for i in range(n)]  # здесь вложенная конструкиция
# [0 for j ...] создает прострой список из n нулей, а затем размножается второй
# частью цикла for i in ...
# Есть еще вариант генерации "ленивых" списков. То же самое что вверху только
# круглые а не квадратные скобки. В этом случае значение формируется
# (вычисляется) только в тот момент когда к нему непосредственно обращаются.
ran = (x for i in range(n))
# Такие Генераторы создаются для временных вычислений, чтобы получить что то
# конкретное на выходе. Использовать генераторы для постоянного хранения
# списков и т.п. не имеет смысла, так как после исполнения удаляются
print(list(ran))  # печать этого списка, через оператор list
print(*ran1)  # также можо вызывать через *. Но ленивые списки так не работают
# если печатать через list, то все берется в доп. скобки

# ? цикл for позволяет пробегать по списку и выбирать значения производя с ними
# какие либо действия, либо делать списки из строк, чисел и т.п.
# формулировка #// [x for x in list if x >0] При такой записи, цикл for создает
# временную переменную x и расшифровыввается как, выбрать х как х в списке list
# если она больше нуля. #// Также для этих целей есть функция map
# форма записи, когда надо введенную с клавиатуры строку перевести в числа:
# // y = [int(i) for i in input().split()]  # на выходе получаем список
# числовых переменных

for ra in range(1, 10, 5):  # для последовательности от 1 до 10 с шагом 5,
    print(ra, end=", ")     # создается переменная ra - печатается в столбик.
print()     # для переноса строки после end=","

for y in range(12, 100, 20):
    print("for range", y**0.5)

ran1 = range(10)  # создается список от 0 до 9

# ? list comprihation
# ? list2 = [x * x for x in list if x > 0]
# циклов for внутри может быть несколько, как и if
# если вместо [] поставить () - на выходе подучим не лист, а генератор
lizz = [x**2 for x in range(10)]  # атвоматическое создание списка, где x -
# несуществующая, временная переменная на время создания списка, на действующий
# x никак не влияет. Создает список из range(10) возводя каждое значение в **2
# вместо range может быть другой список и т.п.

for x in lizz:  # перебирает список с временной переменной x
    pass
print(lizz)

lizz2 = [x**2 for x in lizz if x % 2 == 0]  # найти в списке lizz четные
# элементы, и возвести в квадрат.. Создав при этом список lizz2
print(lizz2)

lis3 = [[0] * 5 for i in range(3)]  # создание многомерного, в данном случае
# 3-х мерного пустого массива с 5-ю 0-ми значениями в каждой строке

for i, value in enumerate(lis3):  # Если надо получить доступ и к индексу и к
    print(i, value)  # переменной в списке - то используется конструкция
    # enumerate

# * генератор yield
# используется вместо оператора return, позволяет вернуть значение несколько
# раз. То есть при return функция возвращает значение и прекращает работу. при
# yield - возвращает значение и продолжает работу (одновременно запоминая
# состояние на котором остановилась). Можно вызывать несколько раз
# ? https://stepik.org/lesson/24464/step/3?unit=6769
# -----------------------------------------------------------------------------

# * создание собственного цикла for:
# цикл for пробегает по индексам. в списках - по индексам списка, в словарях -
# по ключам словаря, с строках по каждому симовлу строки. Делается это через
# внутренний механизм python и два его внутренних оператора - иттератора:
# ? iter(x) и next(x)
iterator = iter(lis3)
while True:
    try:
        i = next(iterator)
        print(i)
    except StopIteration:
        break
# именно таким образом работает цикл for. То есть он перебирает все имеющиеся
# индексы в списке, и если поймал ошибку StopIterration - выходит из цикла
# она полностью аналогична записи:
for i in lis3:
    print(i)
# на основании указанных итераторов можно писать собственные циклы for для
# собственных классов. при их создании есть специальный конструктор для
# создания итераций __next__
# // next(x) - аналогичная запись для конструктора x.__next__() то есть x
# внутри класса является итератором, когда у него есть метод __next__, а для
# того чтобы его можно было использовать в цикле for - метод __iter__
# через такие конструкторы можно создавать свои классы, которые, например
# перебирают элементы парами.
# видео по созданию класса iterrator
# ? https://stepik.org/lesson/24464/step/2?unit=6769
# -----------------------------------------------------------------------------
# endregion -------------------------------------------------------------------

# region #* цикл try - механизм исключений ------------------------------------
# // используется когда неизвестно какие даные будут получены на вход.
# блок try может быть где угодно в коде, внутри функции, вызова, класса и т.п.
try:  # пробуем
    pass  # сделать то то..
except Exception:  # проверить на ошибки Excaption название базового или
    # созданного класса объекта) исключения.
    pass  # что делать если возникло исключение
except():  # станадртный обработчик исключений
    pass  # делать то то и то то...
else:  # если никаких исключений не возникло, то
    pass
finally:  # скрипт который выполняется в любом случае (необязательный)
    print("Погнали дальше")

# ? пример использования
# если вместо x поставить несуществующую переменную, то возникнет исключение
try:  # пробовать исполнить код
    print(x)
except NameError as e:  # обработка ошибок.. если тип ошибки NameError
    # сформировать переменную e c содержимым ошибки и вывести ее в консоль
    # //переменную e можно и не формировать.. Она только для отладки
    # // тип ошибки - тоже не обязательное значение. Если его нет, ловит все
    print(type(e))  # класс к которому принадлежит ошибка
    print(e.args)  # ее аргументы
    print(e)  # сам текст ошибки (то же что и аргументы)
    print('Ошибка имени')  # произвольный вывод..
    # // также вместо принтов можно скриптовать какие либо действия
# except блоков может быть много.
except(TypeError, TimeoutError):  # типы можно комбинировать через кортедж
    print('Любая другая ошибочка')
# При этом само исключение не возникает. То есть происходит проверка исполнения
# и отработка действия. Если код прошел, то он просто исполняется. Если ошибка
# не возникает, то исполняются следующие за ним болки else и finally
else:  # // блок try также содержить логику else и finally.
    print(x, "Ошибка не возникла")
# метод raise для того чтобы самостоятельно создавать исключения. То есть, в
# данном случае, если соблюдается условие для else, py выдаст в консоль ошибку
# типа ValueError с пояснением из скобок
finally:  # блок который запускается в любом случае
    pass

# * raise BaseException("Тут пишем текст который вылазает при исключении")
# raise команда вызывающая исключение, со ссылкой к классу исключений.
# в классе исключений BaseException есть много подклассов. Можно писать свои,
# но они должны быть дочерними по отношению к BaseExceprion
# * exit()
# команда полностью завершающая программу и прекращающая выполнение всего кода
# даже если она встречается внутри цикла, какого либо подцикла функции и т.п
# endregion -------------------------------------------------------------------

#region #* ФУНКЦии. Они же Подпрограммы. Процедуры. ---------------------------
# Это именованный участок кода, к которму можно неоднократно обращаться. Могут
# принимать параметры (аргументы) и возвращать значения. А могут и не
# возвращать. Когда не возвращает, то на самом деле возвращает значение None.

# // Название функций всегда осмысленное, как кличка у человека. Отвечает на
# вопрос "что", а документация на вопрос "зачем". Название должно отражать суть
# хранимого в функции

# //Всегда отделяется от кода двумя абзацами сверху и снизу. Создается через
# единый оператор def. После создания может использоваться путем вызова
# множество раз.

# //Есть вшитые функции: int, input, print, id и другие.
# Список и описание функций - https://youtu.be/KSL_32HvBew
# Справка по любой функции вшита. Вызывается help(название функции)


def funct():  # func это название функции. В скобках, ее параметры. Если
    # параметров много, то через ",". Тут формальные параметры. Меняются при
    # вызове (см ниже).
    """ документация к функции, название, расшифровка аргументов
                                                   пустая строка
    и затем дается расширенная документация
    """
    # внутри тройных кавычек документация к функции. Закрывающие кавычки
    # ставятся на отдельной строке. Не обязательный параметр.
    pass  # Тут расписывается то, что она делает. То есть сама подпрограмма.


funct()  # а это вызов функции в любм месте кода. Внутри скобок указывается
# локальное значение, то есть то, с каким аргументом она используется. То есть
# фактический параметр. или пустые скобки. Тогда применяется формальный.

# *Сформировать функцию---------------------------------------------


def hello(name="World"):    # При пустом значении при вызове функции, (ниже по
    # коду), вызывается то, что в кавычках,
    print("hello", name)    # если значение не пустое - печатается оно


hello()  # Вызывает ранее созданную функцию. Печатает значение переменной по
# умолчанию (см выше)
h = hello   # Переназначение функции на букву (см. ниже)
h("Проверка связи")  # то что внутри скобок добавляется к функции
h()  # Печатает значение переменной по умолчанию, то что в кавычках (см выше)


def some_func(x, y, /):
    # создание функции с позиционным аргументом "/" При его применении значения
    # берутся строго по маске записи.#// Нов Пайтон 3.8 (из за этого ошибка)
    print(x, y)
    # вот так print(x=10, y=20) - писать нельзя.


some_func(1, 2)
# передача в функцию значений по маске. Если в функции стоит "/", вот такую
# запись some_func(x=1, y=2) сделать уже нельзя.
# ----------------------------------------------------------------------------

# *Сравнение двух значений (вывод результата во втором блоке)------------------


def max2(z, a):   # значения где z и a входят при вызове.
    if z > a:     # известными. Они никак не связаны с конкретными переменными
        return z,   # вернуть
    else:           # "иначе"" (его можно вообще убирать - лишний оператор)
        return a


print(max2("ab", "bc"))   # Параметры берутся из памяти (последние значения,)
# или можно их прописывать числами, или любыми сравниваемыми значениями
# непосредственно здесь, в скобках (если прописать x и y - возьмет из памяти)

# ----------------------------------------------------------------------------
# * ФУНКЦи. Создаются через ключевое оператор def. Отделяются двумя абзацами с
# каждой стороны


def pr(one, two, *args):  # Внутри скобок передаваемые значения (переменные).
    # их может и не быть, но тогда внутри функции непонятно с чем их
    # ассоциировать.
    # // *args значит + неопределенное число аргутменов. При этом во время
    # исполнения функции вместо args формируется кортедж из всех лишних
    # переданных аргументов, и уже в функции используется
    # // **args - ознчает что на входе ожидается словарь. Либо он сам будет
    # сформирован из полученных пар ключ/значение "a"=40, "b"=30 итд.
    print(one, "!!!+-", two, *args)  # тело функции, то есть что она должна
    # делать. Например это - функция печати.
    pass  # используется тогда, когда функция пустая (не делает ничего) Если
# функция пустая и нет этого оператора, то дает ошибку. Ставят когда создают
# шаблон программы.


def summ(a: "int, >0", b: int):  # создание функции с переменными в скобках
    """ при такой записи, указанные через : значения int и 'int > 0'- это всего
    лишь один из видов документации, на работу самой функции не влияют. то есть
    в данном случае можно подать и строки. запись оставляется создателем, как
    документация, чтобы пояснить что прогрмаист имел в виду при ее создании
    """
    res = a + b     # Что делать с переменными
    return res      # что надо вернуть на выходе фукнции. Если бы она ничего не
    # возвращала, то тут стояло бы pass


ok_stat = 'ok'
test = summ(10, 20)  # Вызов функции summ с переменными 10 и 20
pr("Number is", test)  # вызов функции pr. В скобках те самые переменные.

# * lambda функции
# используется когда запись функции не имеет смысла (применяется 1 раз)
# синтаксис: lambda arguments: x % 2 == 0
# то есть lambda, затем аргументы до : затем что надо сделать или функция
# допускается только одна функция или одно выражение

# //mult = lambda x, y: x * y - Упрощенная запись функции через оператор Lambda
# формула - название переменной = Lambda значения : что с ними делать.
# Не соответствует PEP8. Работает.. Но правильне записывать так:


def mult(a, b):
    return a * b  # Вот правильная упрощенная запись вместо lambda. Но для
    # сокращения кода, можно испольщовать и так, как указано выше.


def mu(*a):  # При такой записи (*a) функция может принимать неопределнное
    # число аргументов. хоть 1 хоть 100 (список), а если **a - то словарь. Если
    # принимается словарь, то запись вида a=10, b='str' итп.
    global ok_stat  # обращение к глобальной переменной
    # nonlocal ok_stat для обращения к нелокальной переменной (используется во)
    # вложенных функциях (функция в функции)
    # Есть области пространства имен: #// local, non-local, global, built-in
    pass


print(mult(2, 5))
# endregion -------------------------------------------------------------------
