# region #* Преамбула, импорт -------------------------------------------------
import time
import functools
from abc import ABC, abstractmethod
from datetime import datetime

# В Python все является объектами. В т.ч. и классы
# Все, даже основные классы являются объектами метаклассов
# _ Все создаваемые классы Python являются наследниками класса object.
# // Самый обширный тип - type. При создании все классы принадлежат ему.
# * Специальные атрибуты и методы
""" имена начинающие и заканчивающиеся двумя подчеркиваниями '__ИмяАтр__'
являются внутренними для пайтон и задают особые свойства объекта, примеры
__doc__, __class__ и т.п.
Среди таких атрибутов есть методы, в сообществе называемые "магическими"
Они задают особое поведение объектов и позволяют переопределять поведение
встроенных функций и методов для экземпляров класса. """
# **Наиболее часто используемый __init__ # * инициазизация объекта
# ! Не следует объявлять свои атрибуты по такому шаблону!!!
# Следует избегать обилия глобальных переменных - это плохой стиль кода.
# endregion--------------------------------------------------------------------

# region #* ООП (Объектно ориентированное программирование) -------------------
# ООП - это образ мышления, а не прогрмирования.
# - создание классов и объектов, на основе классов.
# ** Введен для того, чтобы позволять общаться с компому через понятные мне
# сущности. Тип, класс, объект, атрибуты, методы класса и т.п. Объединяя
# схожие объекты в классы, классы в классы верзнего уровня и т.п.
# Через создание классов - происходит инкапсуляция ответственности
# Если мы хотим усовершенствовать объекты класса, правильнее это делать через
# усовершенстование атрибутов и методов самого класса, либ осоздание подклассов

# _ Класс - это тип объектов. В пайтоне тип и класс это одно и тоже
# _ Объект - это данные + код, то есть данные обернутые некоторым кол-м функций
# _ Метод - функция принадлежащая к конкретному классу (созданная внутри него)
# методы вызываются через "." пример: имя_объекта_класса.метод(), либо сам
# объект класса "." имя метода(). Пример: "Hello world".метод()
# _ Параметры (атрибуты) класса, - локальные переменные внутри него
# _ Аргументы, это то что передается вместо параметров при создании объектов
# В пайтоне нет нормального способа удаления объектов класса.
# // В ООП код вне функций или классов, считается дурным тоном.
# endregion--------------------------------------------------------------------

# region #* Принципы ООП ------------------------------------------------------
"""
#* KISS - keep it simple stuped. Принцип простоты. Пока программа понятна и
проста, разбивать ее на более мелкие смысла нет, более того, если нужен общий
делитель, нам не нужны классы и ООП как таковой
#* DRY - don`t reapit yourself - не повторяй сам себя. Любые данные должны быть
только в одном месте.. В остальные они должны вызываться, чтобы не искажаться
например кол-во чего то.. Если есть много мест где это отражено, вызываться во
все эти места они должны из одного источника. Если источников несколько будут
ошибки"""
"""
#* SOLID
#_ Single - Принцип единственной ответственности. Каждый класс отвечает
толькоза одну функцию. Если необходимо расширить функцонал, лучше выделить это
в отдельный класс (когда это не противоречит KISS)

#_ Open/close - Принцип открытости/закрытости. Классы должны быть открыты для
расширения но при этом закрыты для изменения. Этот принцип является важным,
потому что внесение изменений в существующие компоненты системы может
также привести к непредвиденным изменениям в работе самой этой системы.
Однако поведение существующих объектов, при необходимости, можно расширять при
помощи создания новых сущностей.

#_ Liskov Barbara - функции, которые используют базовый тип, должны иметь
возможность использовать его подтипы не зная об этом. Поведение подклассов
некоторого класса не должно противоречить поведению самого этого класса.
На этом принципе строятся многие часто используемые структуры, такие как
паттерны проектирования

#_ Interface segregation - принцип разделения интерфейса. Клиенты не должны
зависеть от методов, которые они не используют.
Не следует делать слишком сложный интерфейс какого-то объекта: у каждого
компонента должна быть возможность доступа лишь к той части функциональности,
которая необходима именно ему. Если интерфейс не может этого обеспечить,
то его следует разделить на более мелкие. Одновременно с этим, к каждой части
функциональности некоторого объекта должен быть единый интерфейс доступа. Не
следует делать большое количество дублирующихся интерфейсов.

#_ Dependency invesion - модули верхних уровней не должны зависеть от модулей
нижних уровней. Оба типа модулей должны зависеть от абстракций. При этом
абстракции не должны зависеть от деталей, это детали должны зависеть от
абстракций.
#* ассоциация, это связь между классами, что к чему может обращаться. Так,
в примере пушка, снаряд, мишень есть ассоциативная связь пушка - снаряд, также
есть ассоциация между снаряд - мишень. то есть пушка взаимодействует с мишенью
через снаряд.
При этом ассоциация мишень-снаряд может быть вынесена в отдельный класс, cheker
занимающийся отслеживанием взаимодействия снаряда и мишени (снятие хп и т.п.)
Это же касается асоциации пушки и мишени, если реализован механизм прицеливания
если за это реально отвечает пушка, то можно реализовывать в ней. Если нарушен
принцип SOLID имеет смысл вынести в отдельный класс"""
# ---------------------------------------------------
"""
#* Контрактное програмирование (Мэйер Бертран)
https://www.youtube.com/watch?v=YN2ETIhrcHU
Позволяет организовать строгую проверку типов
При проектировании определяютя формальные точные и верифицируемые спецификации
интерфейсов системы. В интерпритируемых языках, для проверки возможности
"компиляции" используют так называемую систему контрактов, которая включает:
- предусловие
- постусловие
- инварианты
именно из за контрактной системы возникают исключения. Когда не соблюдается 1-н
из указанных выше принципов, инетерпритатор кидает ошибку, прекращает программу
для python есть оператор assert (проверка значений в ходе выполнения кода)
текже есть библиотеки типа Pycontracts (установка через pip)
https://www.coursera.org/learn/oop-patterns-python/lecture/BkwQj/kontraktnoie-proghrammirovaniie
"""
hour = 20
# утверждение, что hour < 23 и > 0. Иначе - исключение (текст в " ")
assert 0 < hour < 23, "hour shold be in range 0-23"
# ----------------------------------------------------
"""
#* Принцип утиной типизации
Есть 2 подхода в контроле кода. EAPP в Python - предпочитительней.

LBYL (семь раз отмерь, один отреж). Стиль характеризующийся множеством проверок
Обычно атрибуты проверяются (контролируются) через функцию hasattr

EAFP (проще просить прощение, чем разрешение). Стиль характерен обилием блоков
try/except. Строится на предположении.. Все возможные исключения обрабатываются
"""
# endregion--------------------------------------------------------------------

# region #* Goat and Students (мфти)


class Goat:  # класс Коза (#* имена классов с Большой буквы)
    age = 0  # возраст козы. указывается умолчание
    name = ""  # имя козы, указывается просто тип
    weight = 0.0  # вес козы, по умолчанию - 0

    def show(self):
        """ метод козы. Классовые фунции называются методы. Первым параметром
        метода всегда указывается self. Является обязательным. Всегда идет 1-м
        Это ссылка на конкретный объект, для которого будет вызван этот метод.
        """
        print(self.name)  # вывод имени объекта класса через метод класса show
        """ Чтобы обратиться к аттрибуту класса, всегда первым указывается self
        просто атрибута name в данном методе не существует, он привязан именно
        к атрибуту self. Так, если внутри метода я создаю свой name, то он к
        аттрибуту класса name отношения не имеет (см пространсто имен)
        Как только функция, или, в данном случае метод, завершил выполнение,
        все созданные им локальные переменные уничтожаются (если они не были)
        специально переданы куда либо извне метода
        """
        print(self.age)
# _ созданный в данном примере класс коза, позволит создать множество коз, у
# каждой из которых будут указанные в классе атррибуты и описанные в классе
# методы


a = Goat()  # создаем объект класса коза, то есть экземпляр класса. () - это
# вызов класса.. то есть не присвоение ссылки на класс, а именно вызов. Без ()
# происходит простое присваивание переменной 'а' ссылки на клас Goat, и только
# _ через () происходит вызов конструктора объекта класса и создается объект
print(type(a))  # вызов типа к которому принадлежит объект а (здесь вывод Goat)
print(dir(a))  # запросить какие аттрибуты есть у объекта класса, вывод полный
# список, включая встроенные, и в конце, созданные через класс или конструктор
a.name = 'Тонька'
a.age = 4
a.weight = 12.5
""" Присвоение атрибутов конкретному объекту (экзепляру) класса, указание хар-к
конкретной козы. Если не указано, то используются по умолчанию. Допускаются
операторы a.age +=1 и т.п. при этом за базу берется хар-ка по умолчанию
"""

b = Goat()
b.name = 'Зорька'
b.age += 2
""" Создание второй козы, по имени Зорька, возрастом база + 2, остальные атр-ты
по умолчанию.
"""
# _ К каждому конкретному экземпляру можно приклеить доплнительные атрибут:
b.leg = 5  # указание кол-ва ног у Зорьки.. Но #* Делать так нельзя, хоть язык
# _ и позволяет, но нарушается принцип инкапсуляции.

a.show()
""" вызов метода show класса Goat для объекта (экземпляра класса) Тонька """

# При создании объектов как указано выше, могут возникать скрытые ошибки, так
# как не видно, какие из параметров в выводе реальные, а какие из умолчаний.
# чтобы этого избегать, содавать объекты надо через конструкторы с обязательным
# параметром (параметрами):
# * Если есть необходимость указать обяательные атрибуты экземпляра класса, без
# которых его создание вызовет исключение, а также для того, чтобы можно было
# создавать объект через формулировку a = Goat("Зорька", 2, 9.8) то это
# делается через конструктор класс - #*  __init__:
# * сам конструктор в каждом конкретном классе может быть только один
# те атрибуты которых нет в конструкторе, но есть во всем классе - называются
# * константы класса.
# Они вынесены из констркутора, обысчно имеют значение по умолчанию, которое
# является единым для всех объектов класса.. Пример, кол-во ног у студентов


class Student:
    LEGS = 2  # _ константа класса, общая для всех его объектов (может меняться
    # только в очень исклбчительных сулчаях, когда студент, например, калека. и
    # именно при создании объекта, отдельной строкой. Константы принято писать
    # _ большими буквами (на самом деле это только для себя, чтобы не путать)

    def __init__(self, name, age):
        """ создание конструктора обекта класса. Это не метод, потому что
        вызвать его отдельно нельзя. это именно конструктор """
        self.name = name
        self.age = age
        """ создание аттрибутов класса через конструктор. кроме указанных в ()
        выше атрибутов, можно создавать еще столько, сколько нужно. в () только
        обязательные параметры. Все остальные, просто создаются для каждого
        объкта. То есть при создании новых атрибутов их надо создавать только
        внутри конструктора.."""
        self.weight = float()  # задание типа атрибута
        self.iq = 100  # задание типа и значения по умолчанию
        """В конструкторе можно производить какие либо действия,вычисленияи т.п
        как в любом методе, хоть это и не метод например вывести инфо о
        зачислении студента"""
        print(name, "Зачислен", "Печать строки при создании объекта класса")

    def show_atribute(self):
        """ создание метода вывода всех указанных выше переменных через (f) то
        есть название атрибута и его значение
        """
        print(f'{self.name=}', f'{self.age=}', f'{self.iq=}', f'{self.LEGS=}',
              f'{self.weight=}', "печать атрибутов при вызове метода класса")


v = Student("Вася", 18)  # здесь идет создание объекта через конструктор класса
""" __init__, который принимает в себя то что внутри () параметры (Вася, 18)
Остальные, необязательны атрибуты также уже созданы и досутпны в режиме типа
или по умолчанию, или как либо иначе (через библиотеку random например)
"""  # _ Если при создании через конструктор __init__ не указать обязательные
# атрибуты - вылетит исключение!!!

v.show_atribute()  # вызов метода класса Student

# endregion -------------------------------------------------------------------

# region #* класс Car


class Car:  # Создание класса
    name = "None"  # Создание аргументов присущих классу. В качестве значения
    speed = 250  # указываются используемые по умолчанию.

    def set(self, name, speed):  # Создание функции внутри класса.
        # set имя метода установки аргументов, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше


class Premium:
    # Конструктор используемый внутри класса, при создании
    def __init__(self, name, speed):  # Создание функции внутри класса.
        # ___init___ - специальный опретатор, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше
        print(self.name, "имеет Скорость", self.speed)  # форма исполнения
        # см пример на мерседесе.
    # super(obj1, self).__init__()  # Пока не понятно. Это из шаблона

    def set(self, name, speed):  # Создание функции внутри класса.
        # Set - функция установки аргументов, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше


class Light(Car):  # Создание подкласса. Внутри скобок указываются родители.
    # Родителей может быть много, указываются через запятую. Все родительские
    # аргументы и функции доступны ниже, при создании объекта.
    wheels = 4  # дополнительные аргументы подкласса. Доступны только в нем и
    # в его дочерних подклассах.


bmv = Car()  # Создание объекта и назначение ему класса
bmv.set("BMV", 125)  # присвоение аргументов согласно порядку в функции(выше)
print(bmv.name, "едет", bmv.speed, "км в час")  # вывод полученного значения

shkoda = Light()  # Cсоздание объекта из подкласса.
shkoda.wheels = 5  # изменение значения подкласса. Если не менять, то берется
# тот который указан в подклассе, по умолчанию.
shkoda.set("Shkoda", 145)  # испольование и изменение аргументов из
# родительского класса, если не менять, то берутся по умолчанию.
print(shkoda.name, "имеет", shkoda.wheels, "колеса")

mersedes = Premium("Mersedes", 245)  # Создание объекта с помощью конструктора
# класса, в данном случае - Premium. В конструкторе прописываются все
# необходимые в том числе и действия (в данном примере - print).
mersedes.set("Mersedes-Bentz", 250)  # изменение аргументов, созданных ранее
print(mersedes.name, "едет", mersedes.speed)

# //ПРиМЕЧАНиЕ - создание и конструктором и через функцию set в одном классе,
# либо подклассе - работает, но конструктор должен идти раньше функции set.
# Если надо подкласс формировать не через конструктор, а родитель с
# конструктором, то в него надо вставить пустую функцию конструктора. Такую:
# def __init__(self):
#     pass
# endregion--------------------------------------------------------------------

# region #* Создание классов, объектов класса и атрибутов класса и его объектов
""" при создании класса внутри него создаются аттрибуты (переменные) и методы
(функции) """


class MyObj:
    """создание класса MyObj. При этом, в данном случае, сам класс MyObj
    является объектом класса __main__."""
    int_field = 8
    str_field = "Строка с текстом"
    """в классе созданы 2 аттрибута класса, int и str. При создании класса в
    нем создаются атрибуты и функции, либо присваивается pass (пустой класс)
    Атрибуты созданные без конструкторов или методов, как в данном случае,
    принадлежат самому классу, и не связаны с его экземплярами.
    Если необходимо абратиться к этому атрибуту внутри конструктора, обращение
    идет через имя класса, например как общий счетчик для всех создаваемых
    экземпляров MyObj.int_field += 1.
    Доступ к локальному атрибуту в экземпляре self.int_field += 1"""


print(MyObj.str_field)  # доступ к атрибуту класса по его имени str_field
print(MyObj.int_field)  # доступ к атрибуту класса по его имени int_field

AnotherMyObj = MyObj  # Создание переменной (ссылки) на существующий класс

type(MyObj)  # вызов класса объекта. В консоли печатает к какому классу
# приналдежит объект.

obj1 = MyObj()  # Создание объекта класса MyObj.
obj2 = MyObj()  # Создание второго объекта класса MyObj.

print(obj1.int_field)  # Через объект класса мы также можем получить доступ к
print(obj2.str_field)  # его аттрибутам.

MyObj.int_field = 10  # изменение значение аттрибута всего класса MyObj
print(MyObj.int_field)  # доступ к обновленному аттрибуту
print(obj1.int_field)  # доступ через дочерний экземпляр класса

obj1.int_field = 22  # измение аттрибута непосредственно у объекта, при этом у
# всех иных объектов класса этот атрибут не меняется. Меняется только у
# конкретного экземпляра
print(obj1.int_field)  # берет измененный аттрибут, принадлежащщий только этому
# объекту класса
print(obj2.int_field)  # поскольку своего нет, берет значение материнского


class Pers:
    """Создание класса перс (человек). Такое написание комментария является
    документацией класса (функции), которая видна в линтинге, при вызове.

    При этом при наличии документации - pass не обязательно.
    """


john = Pers()  # Создание объекта john класса Pers
john.name = "John"  # создание аргумента объекта - John.
john.age = 27  # создание аргумента возраст, со значением 27

mary = Pers()  # см пояснения по Джону, тут все аналогично для объекта Мэри
mary.name = "Mary"
mary.age = 23

print(john.name, "возраст", john.age)  # принт через вызов аттрибутов объекта
print(mary.name, "возраст", mary.age)  # и печать параметров этих аттрибутов
"""Такая запись не совсем верная, поскольку содержит почти одни и те же
значения, а значит если таких джонов млн - придется этот принт писать млн раз.
Для этого делается форма класса (ниже):"""


class Person:
    def print_info(self):
        """создание метода класса, с использованием конструктора self (атрибут)
        #! self это всегда первый параметр в функции описывающей метод
        является ссылкой на экземпляр класса"""
        print(self.name, "возраст", self.age)


derek = Person()  # создаем объект класса
derek.name = "Derek"  # присваиваем ему собственные аттрибуты
derek.age = 42

masha = Person()
"""если у Person не указать (). создасться ссылка на класс а не его обхект"""
masha.name = "Masha"
masha.age = 37

Person.print_info(derek)  # вызов метода print_info класса Person для Дерека
Person.print_info(masha)  # - тоже самое для Маши
# но также можно делать и такую запись:
derek.print_info()  # вызов метода непорсдественно объекта класса, поскольку
masha.print_info()  # и Маша и Дерек члены класса Person, а этот класс имеет
# метод print_info
""" Но это тоже не оптимальная запись.. Можно еще уростить:"""


class Persona:  # _создание класса с конструктором __init__
    """__init__ конструктор есть всегда. Если нет у самого класса, берется у
    родителя. Нет у родителя, идет дальше по иерархии наследования до object"""
    count = 0  # создание атрибута класса (общий для всех экземпляров счетчик)

    def __init__(self, name, age):
        """создаем метод, через конструктор __init__.
        Метод конструктор __init__ не должен возвращать ничего.
        #_ return всегда None """
        self.name = name
        self.age = age
        self.count += 1  # локальный счетчик экземпляра класса
        Persona.count += 1  # при создании экземпляра класса созданный в самом
        # классе общий счетчик увеличивает свое значение

    def print_info(self):  # см выше
        print(self.name, "возраст", self.age)


vasya = Persona("Vasya", 20)
dusya = Persona("Dusya", 18)
"""создание объектов класса через __init__, аттрибуты указываются по порядку,
как в конструкторе
"""
vasya.print_info()  # см выше, вызов метода через объект класса
dusya.print_info()

print(Persona.count)  # вывод состояния счетчика класса

""" #* если создавать атрибуты не через конструктор, то внесенные в последствии
аттрибуты будут присваиваться всему классу, а не конкретному объекту. То есть,
если сделать так: """


class TestClass:
    tags = []

    def __init__(self):
        self.att = 0

    def tester(self):
        self.tags = []
        tags.append(self)
# // все объявленные потом атрибуты att - будут иметь отношение только к одному
# конкретному объекту. А все tags - ко всем объектам класса. Если же tags
# объявлять внутри констурктора вот так:


class TestClass1:
    def __init__(self):
        self.att = 0
        self.tags = []
# тогда они будут иметь отношение только к конкретным экземплярам но не к класу
# в целом.

# endregion--------------------------------------------------------------------

# region #* Создание атрибутов объектов через конструкторы объектов (__xxx__)


""" Атрибуты, имена которых начинаются и заканчиваются двумя знаками
подчёркивания, являются внутренними для Python и задают особые свойства
объектов.(например документационная строка __doc__).
Другим примером может служить атрибут __class__, в котором хранится класс
данного объекта.
Среди таких атрибутов есть методы. В документации Python подобные методы
называются методами со специальными именами, однако в сообществе Python очень
распространено название «магические методы». Также встречается и название
«специальные методы». Они задают особое поведение объектов и позволяют
переопределять поведение встроенных функций и операторов для экземпляров
данного класса.
Наиболее часто используемым специальным методом является метод-конструктор
__init__.
Первый атрибут любого конструктора - self, указание на экземпляр класса. При
вызове self меняется на имя экземпляра класса."""


class Complex:  # Странный конечно пример, на методе составных чисел

    def __call__(self, func):
        """Магический метод call используется при вызове экземпляра класса, а
        не самого класса.
        Определяет поведение при вызове объекта класса, например для
        созданеия  декоратора
        Однако, если класс с переопределённым методом call является метаклассом
        то экземпляром этого класса является новый класс. А это значит, что при
        создании объекта класса, метаклассом которого является класс с
        переопределённым магическим методом call, вызывается этот самый метод
        call. Причем вызывается он раньше чем new и init."""
        pass

    def __new__(cls, *args, **kwargs):
        """стандартный конструктор создающий экземпляры (объекты) класса.
        Используется чтобы переопределить поведение при создании экземпляра
        класса, до его инициализации. В данном случае, метод __new__
        переопределяется, чтобы не было возможности создать несколько
        экземпляров этого класса. Его станартный функционал выглядит так:"""
        obj = super().__new__(cls)
        return obj
        """Для того чтобы переопределить поведение, вместо этой записи нужно"""
        if cls._instance is None:  # проверяет что экземпляр еще не создан. И,
            # если условие выполняется
            cls._instance = object.__new__(cls)
            """ создает экземпляр класса из мегакласса object, с помощью его
            встроенного метода __new__, поскольку для данного класса, __new__
            уже переопределен."""
        return cls._instance  # возвращаем созданный экземпляр

    def __init__(self, real=0.0, imreal=0.0):
        """Универсальный инициатор объектовых аттрибутов.
        Данный метод вызывается автоматически при инициации экземпляра класса
        для иниициализации изначального состояния экземпляра, и задает его
        изначальные атрибуты.
        """
        self.real = real
        self.imreal = imreal

    def __repr__(self):
        """метод конструктор возвращающий значение для разработчика.
        Репрезентэйшн. Как и __str__ переводит значения в строку. Но, в отличие
        от __str__, __repr__ выдает данные без доступа пользователя к этим
        данным, т.е. для разработчика, для внутренних нужд.
        Внешнее отличие, когда print по умолчанию (через str) - печатается
        только само значение, __repr__ выдает значение вместе с кавычками.
        print(repr("s")) - печатает значение s вместе с ""
        """
        return "Complex({!r}, {!r})".format(self.real, self.imreal)
        # возврат Комплекс от 2-х аргументов. Первый от real, второй imreal

    def __str__(self):
        """метод конструктор возвращающий значения для пользователя. Переводит
        значения в cтроку. Вшит в функцию print. Фактически содержит в себе
        то, что именно возвращается при вызове (по умолчанию ссылка на объект)
        print(имя_экземпляра_класса).
        Классическим переопределением является необходимость при вызове метода
        print(name) выести на экран несколько атрибутов.. name, age, email итп
        """
        return "{}{:+d}i".format(self.real, self.imreal)
        # {} - первое число, {:+d} - второе с обязательным знаком, и i

    def __add__(self, other):
        """метод обеспечиающий сложение. Будет вызываться для объекта, если
        после него стоит знак +
        Позволяет складывать два объекта класса (складываются тождественные
        аттрибуты"""
        return Complex(self.real + other.real, self.imreal + other.imreal)

    def __sub__(self, other):
        """метод обеспечиающий вычитание. Вызывается для объекта, если после
        него стоит знак -
        Сокращенная форма записи, делает тоже самое что __add__"""
        return self + (-other)

    def __neg__(self):
        """метод меняющий знак числа, возвращает значение числа со знаком минус
        """
        return Complex(-self.real, -self.imreal)

    def __abs__(self):
        """возвращает модуль числа (число без учета знака + или -)"""
        return (self.real ** 2 + self.imreal ** 2) ** 0.5

    def __eq__(self, other):
        """метод позволяющий сравнивать объекты, через == как is, not is и
        переопределять по какому именно параметру сравнивать"""
        return self.real() == other.real and self.imreal == other.imreal
        """ __it__ < ;  __le__ <= ; __ne__ != ; __gt__ > ; __ge__ >="""

    def __iter__(self):
        """метод создающий итерируемое значение"""
        pass

    def __next__(self):
        """метод итератора, вызывающий следующее значение итерриуемого объекта
        """
        pass

    def __del__(self):
        """деструктор. вызывается перед удалением объекта. Вызывается не при
        вызове del, а когда перед тем как отрабатывает garbage_collector"""
        pass

    def __bytes__(self):
        """вызывается функцией bytes() для создания байтовой строки"""
        pass

    def __format__(self, format_spec):
        """вызывается функцией format для получения форматированной строки
        согласно параметрам format_spec"""
        pass

    def __hash__(self):
        """вызывается функцией hash() для получения числа, -  hash значения.
        Например можно переопредить функцию хеширования при получении ключей
        в словаре"""
        pass

    def __getattr__(self, name):
        """определяет поведение, если запрошенный атрибут не найден"""
        pass

    def __getattribute__(self, name):
        """вызывается всегда когда происходит обращение к атрибуту"""
        pass

    def __setattr__(self, name, value):
        """определяет поведение при присваиваннии значения атрибуту"""
        pass

    def __delattr__(self, name):
        """определяет поведение при попытке удаления атрибута через del"""
        pass

    def __getitem__(self, index):
        """определяет поведение при доступе по индексу или ключу"""
        pass

    def __setitem__(self, index, value):
        """определяет поведение при присваивании по индексу или ключу"""
        pass

    def __enter__(self):
        """метод определяющий поведение при запуске контекстного менеджера with
        """
        pass

    def __exit__(self, *args):
        """метод определяющий поведение при выходе из контекстного менеджера"""
        pass


# endregion--------------------------------------------------------------------

# region #* Дескрипторы -------------------------------------------------------
""" https://www.coursera.org/learn/diving-in-python/lecture/3QrPI/dieskriptory
С помощью дескрипторов в Python реализована практически вся магия при
работе с объектами, классами и методами. Чтобы определить свой собственный
дескриптор, нужно определить класс, методы __get__, __set__ или __delete__.
После этого можно создать какой-то новый класс и в атрибут этого класса
записать объект типа дескриптор. Таким образом, этот атрибут будет являться
дескриптором.
У него будет переопределено поведение при доступе к атрибуту, при присваивании
значений или при удалении.
Метод __get__, определяет поведение при доступе к атрибуту.
Метод __set__ определяет поведение, если идет присваивание значений атрибуту.
Метод __delete__ определяет, что будет происходить, если атрибут удаляется.
Если просто попытаемся вывести наш атрибут, у нас вызовется метод __get__.
Если мы запишем в него какое-то значение, у нас вызывается метод __set__.
А если мы его удаляем, вызывается метод __delete__.
Таким образом, Python позволяет переопределять поведение при доступе к атрибуту
Это очень мощная концепция, мощный механизм, который позволяет незаметно от
пользователя определять различные поведения в классах.
Класс является дескриптором при переопределении любого из трех методов. Если
переопределен только метод __get__, это non-data дескриптор, если __set__
или delete — то это data дескриптор
Пояснение поведения data & non-date в примере о дескрипторах Py-2015
https://youtu.be/mTp2pLEoDaI?t=1357"""


class Descriptor:
    """Класс дескриптор, внтури можно переопределять поведение любого метода,
    например, чтобы значение value в методе __set__ умножалось на 10..,
    проверялось что оно не отрицательное, или записывало все переменные перед
    удалением в файл и т.п."""
    def __get__(self, obj, obj_type):
        """obj экземпляр класса (DescTest) у которого есть привязанный атрибут.
        Или None, если дескриптор вызван обращением к аттрибуту класса.
        obj_type - класс владеющий дескриптором (DescTest)"""
        print('get', obj, obj_type)

    def __set__(self, obj, value):
        """obj экземпляр класса (DescTest) у которого есть привязанный атрибут.
        value - новое значение аттрибута"""
        print('set', obj, value)

    def __delete__(self, obj):
        """obj экземпляр класса (DescTest) у которого есть привязанный атрибут.
        Не путать с методом __del__ - он для другого функционала"""
        print('delete')


class DescTest:
    """Создание привязанного к дескриптору атрибута. Теперь работа с этим
    атрибутом будет идти по методам описанным в дескрипторе.
    Работает так же точно у классов наследников DescTest"""
    attr = Descriptor()


desctest = DescTest()
desctest.attr  # вызывается метод __get__
desctest.attr = 10  # вызывается метод __set__
del desctest.attr  # вызывается метод __delete__
desctest.__dict__["attr"] = 42  # обход дескриптора для прямой записи данных
""" Не всегда необходимо переопределять именно __get__, __set__, и __delete__.
#_ Такого эфекта для 1-го атрибута, можно добиться через property (см раздел)
"""
"""На основе дескрипторов написано много стандартных функций и декораторов
(property, classmethod, staticmetod) и с они могут быть переопределены.
"""
"""Конструкция __slots__, которая работает тоже с помощью дескрипторов.
__slots__ позволяет определить класс, у которого есть жестко заданный набор
атрибутов. Когда создается класс, у класса создается соответствующий словарь, в
который записываются атрибуты, которые добавляются в объект. Очень часто это
бывает излишне. Может быть огромное количество, например, объектов, и нет
необходимости создавать каждый раз для каждого объекта словарь. Для этого
приходит на помощь конструкция __slots__, которая позволяет жестко задать
количество элементов, которые класс может содержать.
"""


class Slots:
    """В данном случае в этом классе должен быть только 1 атрибут anakin.
    Он создается при инициализации. Если попытатья добавить в класс, или в
    объект какой-то еще один атрибут, то ничего не получится, потому что у
    класса нет, справочника, нет dict, в который это записывается
    """
    __slots__ = ['anakin']


# endregion -------------------------------------------------------------------

# region #* Метод property()


class VerySafe:
    """ Пример применения метода property. Создание дескрипторов с произвольным
    именем (без __get__, __set__, __delete__), и тем же функционалом для одного
    объекта x"""
    def _get_attr(self):
        return self._x

    def _set_attr(self, x):
        assert x > 0, "Non negative value, please"
        self._x = x

    def _del_attr(self):
        del self._x
    # присваивание метода property необходимым атрибутам
    x = property(_get_attr, _set_attr, _del_attr)


verysafe = VerySafe()  # создание экземпляра класса
verysafe.x = 20
verysafe.x
"""Встроенный метод property() является вычисляемым объектом
Конструкция самого property, лекции 2015, урок о дескприпторах
https://youtu.be/mTp2pLEoDaI?t=2028
Property позволяет изменять поведение и выполнять какую-то вычислительную
работу при обращении к атрибуту экземпляра, либо при изменении атрибута, либо
при его удалении. Имеет три встроенных метода .setter, .getter, .deletter
"""


class Robot:
    def __init__(self, power):
        """ при инициализации экземпляра, создается приватный атрибут _power и
        вводимый при инициализации power, который присваивается property()
        """
        self._power = power

    power = property()  # присваиваение публичного power property()

    @power.setter
    def power(self, value):
        """метод использущийся при изменении атрибута power, реализован через
        приватный атрибут"""
        if value < 0:
            self._power = 0
        else:
            self._power = value

    @power.getter
    def power(self):
        """ метод для чтения атрибута power """
        return self._power

    @power.deleter
    def power(self):
        """ метод для удаления атрибута """
        print("make robot useles")
        del self._power


walle = Robot(100)  # создание экземпляра класса
walle.power = -20  # изменение его атрибута через метод property.setter
print(walle.power)  # печать текущего значения.
del walle.power  # удаление атрибута у экземпляра класса


class RobotW:
    """ более простая запись, когда нет необходимости менять или удалять атриб.
    а достаточно просто изменить вариант его вызова (getter)"""
    def __init__(self, power):
        self._power = power

    @property  # вариант изменения только чтения атрибута (без setter и del)
    def power(self):
        """ здесь могут быть любые полезные вычисления """
        return self._power


eva = RobotW(200)
print(eva.power)
# endregion -------------------------------------------------------------------

# region #* Декораторы --------------------------------------------------------
""" https://www.youtube.com/watch?v=Ss1M32pp5Ew&t=701s
Это пециальная функция, которая изменяет поведение функции или класса. Можно
сравнить с обложкой. Хотя по сути, декоратор это та же функция, предназначенная
принимать в себя другие функции.. Оборачивать собой их работу.

Decorator, один из самых простых и часто встречающихся паттернов проектирования
Декоратор отвечает за динамическое создание дополнительного поведения объекта.
Можно Декорировать функцию не принимающую аргументовю, Декорировать функцию
принимающую аргументы. + Возможна модель, когда и функция и декоратор принимают
аргументы.

Декоратор — это функция, которая принимает функцию и возвращает что либо также
похожее на функцию. Основан на функциональности замыкания.
Позволяют соблюдать принципы SOLID (разделять ответственность), KISS и т.п.

Как пример применения, можно делать декораторы через assert на предусловие
(например проверка того что все передаваемые в функцию аргументы положительные)
и постусловие - проверка соответствия результата чему либо. И затем вместо этих
проверок внутри функций, просто обрамить необходиме декораторами.
"""


def timeit(func):
    """ Создание декоратора, который принимает в себя работу другой функции и
    считает время ее исполнения, одновременно печатая результат"""
    def wrapper(*args, **kwargs):
        """передача аргументов в таком виде позволяет передать из внешней
        функции все что необходимо.
        Внутренние функции декораторов принято называть wrapper, wrapped, inner
        decorate или как то так.. Чтобы было проще понять, что это декоратор"""
        start = datetime.now()
        result = func(*args, **kwargs)
        print(datetime.now() - start)
        return result
    return wrapper


""" Необходимо считать время исполнения у множества функций, и каждую из них
пришлось бы вписывать счетчик времени, а через декоратор соблюдается чистый
код +идет разделение ответственности (функция делает свое дело, декоратор свое)
Позволяет применять одно созданную функцию к множеству других (например подсчет
врмени работы, или логирование или еще много чего) """
# //Декораторы обозначаются символом @, имя декоратора, список аргументов в ()
# Если передача аргументов не требуется, () не указываются.
@timeit
def one(n):
    """ функция, обернутая декоратом созданным чуть выше выполняет какое либо
    действие по факту, передаваясь внутрь этого декоратора как его аргумент
    (func) название аргумента значения не имеет..
    При этом аргументы переданые в функцию при вызове идут по цепочке сквозь
    функцию и декоратор благодаря *args, ** kwargs"""
    lis = [x for x in range(n) if x % 2 == 0]
    return lis


deco = one(10**2)  # вызов функции как обычно, но она обернута декоратором @ и
# работа идет через него (в данном случае считает время исполнения дочерней
# функции)
""" Варианты вызова через декоратор по принципу #* list comprihation, то есть
чтобы в коде не оборачивать каждую функцию отдельно через @timeit
Надо делать или одним или другим способом, иначе #* выполнение ЗАДВАИВАЕТСЯ """
l1 = timeit(one)  # присваивание переменной связки декоратора и функции,
# указанной в качестве аргумента для декоратора
deco = l1(10**2)  # вызов сформированной связки декоратор/функция с передачей
# внешнего аргуента, как параметра для функции wrapper

deco = timeit(one)(10**2)  # вариант вызова функции через декоратор, если бы он
# @ не был указан непосредственно перед описанной функцией. Или так:
deco = timeit(one(10**2))  # Еще вариант вызова.. не совсем верный
# endregion -------------------------------------------------------------------

# region #* Использование декораторов (шаблоны) functools
"""модуль functools - это модуль для функционального програмирования. Кроме
этого содержит в своем составе ряд декораторов.
@function.lru_cache(maxsize=...) - хранит фиксированное число последних
вызовов. Есть диагностика через оператор .cache_info()
@function.singledispatch -
а также функций:
function.partial - фиксирует часть позиционных и ключевых аргументов функции
function.reduse - изменяет логику sum на любую другую операцию, например *
"""


def timethis(func=None, *, n_iter=100):
    """Принимает функцию и количество раз, которое ее нужно вызвать"""
    if func is None:
        return lambda func: timethis(func, n_iter=n_iter)

    @functools.wraps(func)  # декоратор из модуля functools
    def inner(*args, **kwargs):
        """дополнительно вычисляет минимальное время за которое была исполнена
        функция, и выводит это минимальное вермя"""
        print(func.__name__, end=" ... ")  # печать имени функции
        acc = float("inf")  # минимально возможное число
        for i in range(n_iter):  # итерация по списку
            tick = time.perf_counter()  # замер времени
            result = func(*args, **kwargs)  # исполнение одной итерации
            acc = min(acc, time.perf_counter() - tick)  # сравнение на минимум
        print(acc)
        return result
    return inner


result = timethis(sum)(range(10 ** 3))
# //----------------------------------------------------------------


def profiled(func):
    """Профилирование для бедных. Узнать сколько раз каждая функция вызывается
    """
    @functools.wraps(func)
    def inner(*args, **kwargs):
        """поскольку inner.ncals - это атрибут функции, он, в отличие от
        переменной накапливает значение (счетчик, аккумулятор) + имеет
        возможность быть вызванным через '.' извне (см вызов)"""
        inner.ncalls += 1
        return func(*args, **kwargs)
    inner.ncalls = 0
    return inner


@profiled
def identity(x):
    return x


identity(42)
identity.ncalls  # пример вызова атрибута функции (не класса)
# //----------------------------------------------------------------


def once(func):
    """Декоратор позволяющий вызвать функцию только один раз"""
    @functools.wraps(func)
    def inner(*args, **kwargs):
        if not inner.called:  # если ни разу не вызывался
            func(*args, **kwargs)  # вызвать
            inner.called = True  # установить ключ вызова на True
    inner.called = False
    return inner


@once
def initialize_settings():
    print("Settings initialized.")


initialize_settings()
# //----------------------------------------------------------------


def memoized(func):
    """Кэширование значений, сохранение результатов выполнения функции для
    предотвращения избыточных вычислений."""
    cache = {}

    @functools.wraps(func)
    def inner(*args):
        key = args
        if key not in cache:
            cache[key] = func(*args)
        return cache[key]
    return inner


@memoized
def ackermann(m, n):
    if not m:
        return n + 1
    elif not n:
        return ackermann(m - 1, 1)
    else:
        return ackermann(m - 1, ackermann(m, n - 1))


ackermann(3, 4)
# //----------------------------------------------------------------

# endregion -------------------------------------------------------------------

# region #* декоратор staticmethod


"""Cуществуеют встроенные в язык декораторы. В данном случае, Декоратор, это
объявление чего либо, например, что данный метод статический."""


class MyObjekt:  # создаем класс
    class_attr = 8  # объявляем аттрибут и его параметры

    def __init__(self):  # создаем конструктор класса
        self.data_attr = 42  # и вкладываем туда аттрибут с параметрами

    def instance_method(self):  # функция метод, печатающая data_attr
        print(self.data_attr)

    @staticmethod
    def static_method():
        print(MyObjekt.class_attr)


"""Применение декоратора @ staticmetod.
Применяется, когда необходимо создать метод не являющийся функцией, и при этом
он не должен привязываться к конкретному экземпляру класса.
Не привязан к (self), так как может вызываться еще и самим классом.
Описывает статический метод, который будет работать как на самом классе так и
на всех его экземплярах.
Поскольку в этом методе нет доступа к данным, можем вывести только данные,
которые есть непосредственно в самом классе (выше). Привязан к самому классу
(скобки пустые. там нет self)
Если подобное (без self) сделать без декоратора, при вызове будет исключение
"""
MyObjekt.static_method()  # вызов метода класса (работа через декоратор)
objct = MyObjekt()  # создание объекта, экземпляра класса
objct.instance_method()  # вызов инстанс метода объекта
objct.static_method()  # вызов метода объекта (через декоратор) то есть
# через декоратор вызывается параметр класса, который есть в функции но не
# привязан к конкретному объекту.
# endregion ------------------------------------------------------------------

# region #* декоратор classmethod
"""#//Применяется для создания методов класса. Первый рагумент не self а cls
Методы класса такие же как обычные, только они сам класс воспринимают как
объект. Как экземпляр Метакласса. Привязаны не к обектам класса а к самим
классам.
#// Обычные методы привязаны к экземплярам класса.
#// Статические методы - привязаны к самому классу внутри него самого
#// Методы класса воспринимают класс как экземпляр метакласса.
Они не работают с экземплярами класса, не имеют доступа к атрибутам данных
экземпляров класса, так же как статический метод.
Используется в разных областях, в т.ч. для независимости иерархии наследования.
Применяются для создания фабричных методов, перегрузок конструктора и т п."""


class Rectangle:
    """создаем класс прямоугольник с 2-мя сторонами"""
    def __init__(self, side_a, side_b):
        """ метод конструктор принимаюший атирбуты данных стороны а и б """
        self.side_a = side_a
        self.side_b = side_b

    def __repr__(self):
        """ еще один метод конструктор (см в конструкторах объектов) """
        return 'Rectangle(%.1f, %.1f)' % (self.side_a, self.side_b)
        # _ хер его знает что это такое. надо разбираться


class Circle:  # создаем класс круг
    def __init__(self, radius):
        self.radius = radius

    def __repr__(self):
        return 'Circle(%.1f)' % self.radius

    @classmethod
    def from_rectangle(cls, rectangle):
        """ cls - параметр (self), указывающий не на экземпляр, а на сам класс
        cls - неопределенный, текущий класс.
        Используя метод класса, вычисляем по формуле окружность, которая
        описывает снаружи объект из вышесозданного класса прямоугольник.
        метод из прямоугольника считаем: """
        radius = (rectangle.side_a ** 2 + rectangle.side_b ** 2) ** 0.5 / 2
        # формула расчета радиуса по двум сторонам, см. математику
        return cls(radius)  # возвращаем значение радиуса принадлежащий классу


""" использование декоратора classmethod позволяет использовать метод
from_rectangle в дочерних по отношению к Circle классам. Так, если создать
дочерний класс Disc = Circle(), то при обычном методе (без применения cls)
результатом (return) вызова метода from_ractangle будет экземпляр класса
Circle, поскольку без classmethod надо было бы писать return Circle(radius),
и, тем самым return бы всегда Circle. А при использовании classmethod и cls
результатом будет вывод объекта дочернего класса. Поскольку cls это всегда
неопределенный текущий класс. Теперь если написать disc.from_ractangle будет
создан экземпляр disc"""


def main():
    """ запуск данной функции в самом низу настоящего файла"""
    rectangle = Rectangle(3, 4)  # создаем прямоугольник со сторонами 3 и 4
    print(rectangle)  # выводим созданный прямоугольник на экран

    firstCircle = Circle(1)  # создаем круг с радиусом 1
    print(firstCircle)  # выводим его на экран

    secondCircle = Circle.from_rectangle(rectangle)  # создаем второй круг,
    # с радиусом расчитанным по формуле из classmetod from_rectangle, где за
    # основу расчетов берется созданный ранее прямоугольник, что указано в ()
    print(secondCircle)  # выводим его на экран


# endregion--------------------------------------------------------------------

# region #* Замыкания - метод обхода локальности данных -----------------------
# Несмотря на все вышесказанное к локальным объектам внутри функции можно
# добраться, через ее вызов.
""" Замыкание это функция вместе с привязанной к ней совокупностью данных.
В Пайтоне проще решать указанные проблемы через использование классов. Само
замыкание пришло в Пайтон из функциональных языков. Для Пайтона это костыль.
Замыкание как и декораторы расширяют возможность функций в Python, однако
если в указанной ниже функции one def заменить на class - все станет проще и
понятней... Именно поэтому и рекомендуется испольовать ООП

В данном случае речь идет об области inner и переменной x, которая была
объявлена вне ее тела. Окружающая область видимости называется #* nclousing
охватывающая область видимости. При этом параметры объявленные в области
видимости не являются параметрами inner.
"""


def get_multi(num):
    """ Функция умножения внутреннго значения на внешнее
    Создание простого замыкания. Внутрення функция внутри функции родителя
    используется 2 уровня локальности переменных (см порядок вызова)"""
    def inner(a):
        return a * num
    return inner


multiplayer = get_multi(2)
""" присваивание переменной внешнему вызову. Теперь multiplayer указывает на
внутреннюю функцию iner, при этом в его пространстве имен уже есть переменная
num со значением полученным при вызове (2)"""
multiplayer(10)
"""фактически это вызов внутренней функции iner в которую вместо a передается
(10), а параметр num уже есть в пространстве имен, так как сощдан чуть выше"""


def one():
    """ конструкция из темы о декораторах. Создает локальный x. По идее, из
    глобальной области до него не дораться, но это не так из за замыкания"""
    x = ['one', 'two']

    def inner():
        """ внутри нее дочерняя функция, которая распечатывает созданный в
        родителе объект и его id. Это и есть замыкание"""
        print(x)
        print(id(x))
    return inner  # через этот return формируется замыкание


o = one()  # вызов созданной функции, при этом объект x из памяти не удален..
a = o.__closure__[0].cell_contents
""" через такой вот вызов (через внутренние методы) есть возможность добраться
до переменной x созданной внутри функции one. Более того, через нее теперь
можно изменить этот словарь..."""
print(a)  # печать локального словаря x из функции one
a.append('alfk')  # неявное добавление значения в локальный словарь x фун.'one'
print(a)  # печать изменного локального словаря x из функции one

# endregion -------------------------------------------------------------------

# region #* Инкапсуляция. Имена. Управление доступом к атрибутам --------------

# * инкапсуляция, принцип именования переменных
""" Свойство системы, объединяет данные и методы и скрывает детали реализации
обеспечивается контролем и методами доступа, свойствами объекта
Все аттрибуты в Python являются публичными
Один '_' в конце имени - #// избежать конфликт с зарезервированным словом
имена классов, #// СлитноКаждоеСловоСБольшойБуквы
имена модулей #// коротко, маленькими буквами
глобальные константы, константы класса #// БОЛЬШИМИ_БУКВАМИ_ЧЕРЕЗ_ПОДЧЕРКИВАНИЕ
#_ Атрибуты с _g на конце, это глобальные переменные, пример attrib_g
Атрибуты БОЛЬШИМИ_БУКВАМИ - это #_ глобальные константы, пример ATTRIBUT
#_ Аттрибыты начинающиеся с _знака подчеркивания, говорят, что он относится к
внутренней реализации класса. Но..#// Они никак не защищены.
#_ Аттрибуты начинающиеся, но не заканчивающиеся с __двух подчеркиваний,
являются приватными. К ним применяются механизм #** "name mangling".
то есть их все таки можно вызвать извне, но не простым способом а через:
_(подчеркивание) Имя класса __(двойное подчеркивание) название атрибута
#// '_ClassName__attributName'
Они также никак не защищены, но к ним можно обратиться извне, зная имя класса.
То есть инкапсуляция в Пайтон условная.. Она позволяет не перепутать.
Доступ к приватным атрибутам обеспечивается методами доступа и свойствами:
#** Атрибут self в классах - это указание на самого себя. В момент исполнения
туда подстваляется значение самого экземпляра класса
#** Атрибут cls в классах - это указание на неопределенный текущий класс. Туда
подставляется значение текущего класса.
#_ Приватные поля __attr - не наследуются
"""


class Passwrd:  # создание класса
    def __init__(self):  # конструктор экземпляра класса
        self.pwrd = None  # со значением none

    def __getattribute__(self, item):
        """специальный метод, позволяющий контролировать доступ к данным всех
        экземпляров этого класса. Содержит параметры экземпляра класса и
        строковое значение к которому получается доступ.
        До тех пор, пока в созданном экземпляре не введен атрибут pwrd с
        правильным значением, вызов атрибута secret_field дает исключение, так
        как на этом этапе такого атрибута не сузествует. (if не выполняется)
        Когда у экземпляра появился правильные pwrd, возвращает Secret Value
        """
        if item == "secret_field" and self.pwrd == "fwef9823":
            # если название и пароль который нас интересует совпали
            return "Secret Value"  # вернем значение "Secret Value"
        else:
            return object.__getattribute__(self, item)  # иначе возвращаем
            # значение, содержащееся в стандартном методе метакласса object
            # можно прописать другое поведение при неправильном пароле


pwd = Passwrd()  # создаем объект класса
pwd.pwrd = "fwef9823"  # вводим значение пароля в параметр экземпляра
print(pwd.secret_field)  # вызываем серкетное значение через __getattribute__
# если пердварительно не ввести в поле пароля пароль, вылетает исклчение, как
# если бы такого значения не существовало вовсе.

""" Используя доступ по методу доступа можно, например, сделать функцию
градусника который может получать значения в любой системе, и возвращать их так
же в любой системе... И многое многое дргуое."""


class TestClass:
    """ #* Доступ по методу доступа или по методу свойства
    Используется когда необходим контроль над данными. Чтобы можно было не
    полностью скрыть атрибут, а обеспечить какое либо взаимодействие с ним.
    Например, чтобы атрибут был доступен только для чтения, но не доступен для
    записи. Или чтобы использовать для записи только какие то конкретные
    значения (например только числа < 100).
    В результате получаем приватное поле и несколько публичных методов."""

    def __init__(self):
        self.__private_attr = 42  # создаем приватный атрибут (подчеркиванием)

# _ создание доступа по методу доступа -------------------------
    def get_privat(self):
        """создание метода который возвращает приватный аттрибут. Может только
        возвращать значения атрибута. Не сможет его изменить. В результате
        получаем read only"""
        return self.__private_attr

    def set_attr(self, value):
        """возможность для изменения приватного аттрибута по условию. Если
        значение < 100 то запишет новый атрибут, > 100 - не запишет.
        Можно расширяя через else определять другие действия (ошибки, надписи)
        Вместо if может быть вообще любой синтаксис пайтон вкллючая циклы,смену
        математ. действия и вообще все что угодно.
        """
        if value < 100:
            self.__private_attr = value

# _ создание доступа по методу свойства ------------------------
    @property  # специальный декоратор, возвращающий значение свойства
    def prop_attr(self):
        """создание через метод свойства, который возвращает приватный
        аттрибут. Тоже может только возвращать значения атрибута.
        read only """
        return self.__private_attr

    @prop_attr.setter  # декоратор setter #// имя_изменяемого_атрибута.setter
    # имя обязательно должно совпадать с имеющимся в декораторе @property.
    def prop_attr(self, value):
        """возможность для изменения приватного аттрибута по условию через
        метод свойства. #// Ключ .setter (специальный ключ типа декоратора)
        Данный ключ - часть декоратора property, и применяется только к методу
        который был под ним создан. В данном случае - prop_attr.
        """
        if value >= 100:
            self.__private_attr = value


testObj = TestClass()  # создаем объект класса
# print(testObj.__private_attr) при такой записи получаем ошибку. Если все
# же надо к нему обратиться, то можно через name_manling:
print(testObj._TestClass__private_attr)  # вот такая запись есть 'name manling'

print(testObj.get_privat())  # доступ к значению атрибута через метод доступа
testObj.set_attr(50)  # смена значение атрибута по методу доступа

testObj.prop_attr = 200  # смена значение по методу свойства (@property)

print(testObj.prop_attr)  # печать значения измененного значения
# endregion--------------------------------------------------------------------

# region #* Наследование, MRO, LEGB, доступ к атирбутам родителя, метод super()
""" Механизм языка, который позволяет строить классы на основе существующих
Позволяет строить иерархии
Класс потомок может добавлять свои методы и свойства, а также пользоваться
родительскими методами и свойствами. При совпаднии имен - переопределяет
родительский метод конкретно для себя и своих наследников
Метод ищется сначала у себя, потому у родителя, потом у всех предков...
#_ Принцип Барбары Рыльска. Потомок не может не делать того, что умеет родитель
+ еще что то.. Тому кто вызывает потомка должно быть все равно, вызвал он
потомка или родителя.
Переопределение родительского метода имеет смысл, когда это делается для
логичности использования кода (Animal - move, Fish(Animal) - move = swim)
"""
# *Наследование классов ---------------------------


class Base:
    """создание базового класса который имеет метод, печатающий
    Hellow from Base"""

    def method(self):
        print("Hellow from Base")


class Chaild(Base):
    """создаем дочерний класс Chaild, который печатает свое приветствие"""

    def ch_method(self):
        print("hellow from chaild")

    def method(self):
        """создание метода переопределяющего родительский """
        print("Hellow redifine")


ex_chaild = Chaild()  # создаем экземпляр дочернего класса
ex_chaild.method()  # обращаемся через дочерний класс к методу родителя
ex_chaild.ch_method()  # обращается к своему собственному методу


class Figure:
    def __init__(self, side=0):
        """ параметр родительского класса, который наследуюется в конструкторах
        потомков. У потомков второй параметр (side) отсутсвует, однако при
        создании экземпляров, он принимается от родительского"""
        self.side = side


class Square(Figure):
    """ дочерний класс от Figure """

    def draw(self):
        """В цикле, проходим по всем сторонам квадрата. Причем, через
        наследование конструктора (в дочернем классе сразу использутся атрибуты
        родительского. Так как в дочернем side не определен, он возьмет его от
        родителя и привяжет к self потомка"""
        for i in range(self.side):
            """ печать звездочками цикла сторон квадрата, количество * сторона
            квадрата."""
            print('* ' * self.side)


class Triangle(Figure):
    def draw(self):
        for i in range(1, self.side + 1):
            """ печать звездочками цикла сторон треугольника, кол-во звездочек,
            число цикла for"""
            print('* ' * i)


square = Square(5)
triangle = Triangle(6)
square.draw()
triangle.draw()

# *Множественное наследование -----------------------
"""Дает большую гибкость кода, но дает возможность потенциальных ошибок.
Если возникает необходимость использовать множественное наследование, то надо
ответить на вопрос, насколько правильно составлена архитектура.."""


class Horse:
    def run(self):
        print("I am runing")


class Bird:
    def fly(self):
        print("I am flying")


class Pegas(Horse, Bird):
    pass


pegasus = Pegas()
# Поскольку Pegas имеет наследование от 2-х классов, он умеет бегать и летать.
pegasus.run()
pegasus.fly()

# * Получение доступа к атрибутам родителя (суперкласса), метод super() -------

"""Если в текущем классе, метод или атрибут был переопределен, и при этом
требуется доступ к этому методу/аттрибуту родителя (суперкласса), это можно
осуществить двумя способами:
1. Путем явного обращения к аттрибуту необходимого класса
#_ ParientClass.method(self) """
""" 2. При помощи специального прокси super()
#_ super().method()... Эта запись идентична:
#_ super(Chaild_class, self).method(), где metod - метод родительского класса.
#// super делегирует вызов родителю или собрату по дереву MRO
посмотреть цепочку наследиваония по mro метод #// ClassName.mro()"""


class ParientClass:
    def method(self):
        print("Base method invoked on", type(self).__name__)


class ChaildClass(ParientClass):
    def method(self):
        print("Chaild method invoked on", type(self).__name__)
        """ Пример обращения к родительскому методу внутри потомка."""
        ParientClass.method(self)
        """ При этом, в случае обращения по методу класса, можно обращаться к
        методу любого класса, даже не родственного...Пример: """
        Base.method(self)
        """ При обращении по методу super(), обращение идет по цепочке MRO """
        super().method()  # что аналогично записи:
        super(ChaildClass, self).method()


instance = ChaildClass()
instance.method()  # вызов метода потомка у его экземпляра.
ParientClass.method(instance)  # вызов метода родителя у экземпляря потомка.
super(ChaildClass, instance).method()  # тоже самое через иерархию MRO

# _ Пример практического использования ---------------------------
# использование метода super() через конструктор


class Animal:
    def __init__(self):
        """Определение базовых атрибутов"""
        self.can_run = False
        self.can_fly = False

    def print_abbilities(self):
        """Создание базового метода вывода характеристик"""
        print(type(self).__name__)
        print("Can run:", self.can_run)
        print("Can fly:", self.can_fly)


class Horse(Animal):
    def __init__(self):
        """вызов атрибута базового класса и его переопределение через метод
        super. По умолчанию указывает на родительский класс.. Но в () можно
        указать любой другой через констркуцию (Animal, self). Используется при
        множественном наследовании"""
        super().__init__()
        self.can_run = True


class Bird(Animal):
    def __init__(self):
        super().__init__()
        self.can_fly = True


class Pegasus(Horse, Bird):
    """Создание класса с двумя родителями. Один из них бегает, второй летает,
    а потомок умеет и то и другое"""
    pass


horse = Horse()
horse.print_abbilities()
bird = Bird()
bird.print_abbilities()
pegas = Pegasus()
pegas.print_abbilities()

# *Проверка принадлежности к классам, субклассам

issubclass(Chaild, Base)  # проверяет является ли класс Chaild наследником Base
isinstance(ex_chaild, Base)  # проверяет является ли ex_chaild экземпляром
# класса Base или класса, который является наследником Base


def check_issubclass(chaild, base):
    """Проверка наследования классов как выше"""
    return base in chaild.mro()


def check_isinstance(obj, cls):
    """Проверка наследования экземпляра класса как выше"""
    return cls in type(obj).mro()

# endregion--------------------------------------------------------------------

# region #* LEGB - Правила простраства имен (области видимости)
# - Local (локальная)
# - Enclouse (обнимающая) - она же Unlocal или non-lokal
# - Global (переменные уровни модуля)
# - BuildIn (встроенные переменные языка)


""" #_ Scope - области видимости. Namespaces - пространство имен
Namespace это словарь доступных переменных и их значений. Так, если переменная
создана внутри функции(класса) она и видна только внутри этого класса.
locals() - вызов функции выводящей все локальные переменные и их значения
globals() - тоже самое для глобальных переменных

Поиск перменных осуществялется во время исполения функции/метода, а не во время
ее объявления

Есть области пространства имен: #// local, non-local, global, built-in

Если атрибут не найден в текущем классе, происходит поиск у его родителя.
#*Порядок поиска определяется линеаризацией. MRO(Metod Resolution Order)
Хранится в атрибуте класса __mro__. C3-линеаризация
#// Порядок поиска - сначала у себя. Потом у всех своих родителей, потом у
прародителей ит.д. Если у двух родителей одновременно есть этот искомый метода,
имеет значение порядок указания классов. Чем раньше указан, родитель, тем выше
его приоритет при поиске.
A -> (B, C) -> D, поиск идет сначала в D, потом в B(потому что он указан выше,
раньше. Затем в С, потом уже в А.. Ну и дальше в object)
"""
root = 'tk'
canvas = 'canvas'


def one_two():
    """ изменение глобальных переменных внутри функции. используется только в
    исключительных случаях, поскольку легко поймать ошибки
    """
    global root, canvas
    root = 'global tk'
    canvas = 'global canvas'


def make_min(*, lo, hi):
    def inner(first, *args):
        res = hi
        for arg in (first, ) + args:
            if arg < res and lo < arg < hi:
                res = arg
        return max(res, lo)
    return inner


# При первичном вызове аругементы передаются в оборачивающую функцию make_min
bounded_min = make_min(lo=0, hi=255)
# При вызове уже ее, с аргументами, они передаются как бы во внутрь, в inner
bounded_min(-5, 12, 13)

# endregion--------------------------------------------------------------------

# region #* Полиморфизм и Абстракция кода -------------------------------------
"""
# _ Полиморфизм это способность одинаковым образом обрабатывать данные разных
типов. Суть полиморфизма построена на методе наследования.
Он позволяет использовать один и тот же код для работы с различными объектами,
имеющими одинаковый интерфейс, но обладающими различной реализацией.
Если B потомок класса А, то объекты В можно использовать вместо объектов А.
В динамических языках, полиморфизм реализован именно этой динамичностью.
Утииная типизация. Если объект выглядит как утка, плавает как утка, крякает как
утка - значит это утка. Вместо утки подставь список, число... Любой тип данных
Объект подходит для реализации, если он подходит по набору методов. Класс - не
важен. Главное чтобы подходил набор методов.


# _ Абстракция кода
https://www.youtube.com/watch?v=BAAZCHEVxUY
Код может обладать разной степенью абстракции.
Уровни абстракции добавляются чтобы не нарушать принцип DRY кода, то есть когда
идет множество повторений одной и той же формулы в разных функциях, возможно
имеет смысл создать универсальную функцию, принимающую несколько значений...
пример:"""


def salt_mass(meat):  # пропорции соли к мясу, на 1000 гр. мяса 15 гр. соли
    return meat * 15 / 1000


def peper_mass(meat):  # пропорции перца к мясу, на 1000 гр. мяса 10 гр. перца
    return meat * 10 / 1000


"""Если так писать для всего списка ингридиентов, можно задолбаться... Для
упрощения, в данном случае, можно использовать словарь и одну функцию"""

ingredients = {"salt": 15, "peper": 10}


def ingredient_mass(mass, ingr):
    """ получение массы ингридиента по ключу словаря. Елси такого ингридиента
    в словаре нет, то метод get вернет '0' """
    return mass * ingredients.get(ingr, 0) / 1000


print(ingredient_mass(1800, 'salt'))
""" При таком подходе, для расширения функционала необходимо расширять лишь
словарь. Весь остальной код абстрагирован от данных и тем универсален
Более того, абстракиция помозволяет реализовывать независимый полиморфный код
"""
"""Не каждому классу нужны свои экземпляры, иногда необходим класс, просто
чтобы описать некоторый общий интерфейс, которым будут пользоваться все его
потомки. Кроме того, следуя принципу полиморфизма, мы можем общаться со всеми
потомками этого класса, используя вот этот вот интерфейс.
В таком случае, есть необходимость явно запретить создание экземпляров этого
класса. Тут и используется механизм абстрактных классов.
При объявлении класса абстрактным мы как бы говорим системе, которая выполняет
наш код: следи, чтобы экземпляров этого класса в программе не было.
Или, иначе: при составлении иерархии классов может возникнуть ситуация, когда
есть необходимость определить интерфейс некоторого класса, но реализацию этого
интерфейса надо оставить его потомкам. По аналогии с абстрактными классами,
методы, которые при этом используются, также называются абстрактными.
Так как необходимо оставить реализацию потомкам, можно не реализовывать
абстрактные методы в родительском классе, но при этом надо внимательно следить,
чтобы наследники действительно реализовали эти методы.
#_ Библиотека для абстрактных классов в Python - abc"""


class A(ABC):
    """Объявление метода А абстрактным, потомком метода ABC. Экземпляры класса
    А после этого создать невозможно, как невозможно создать экземпляры класса
    потомка до тех пор, пока в потомке не переопределен абстрактный метод test
    """
    @abstractmethod  # объявление декоратора, делающего метод абстрактным
    def test(self):
        pass


class B(A):
    """создание потомка А. До тех пор пока не создан метода test создать
    экземпляр класса B невозможно"""
    def test(self):
        print("Hellow from abstract method")


b = B()  # создание экземпляра класса потомка, только после пеопределения test
b.test()
# endregion -------------------------------------------------------------------

# region #* Паттерны проектирования -------------------------------------------
"""
Паттерн проектирования, или Design Pattern, ─ это повторяемая архитектурная
конструкция, применяемая для решения часто встречающихся задач.
В ходе работы часто приходится раз за разом решать очень похожие друг на друга
задачи. В создании игр это может быть, программирование шаблонов поведения
противников, в сетевых приложениях ─ ведение логов и отслеживание состояний
клиентских приложений.
Использование паттернов позволяет не «изобретать велосипеды», а использовать
качественные решения, проверенные временем. Применяя их, можно избежать многих
ошибок, с которыми приходится сталкиваться. Паттерны отлажены поколениями
программистов, и все ошибки, которые там были, скорее всего, уже исправлены.
Паттернов проектирования существует великое множество. """
# endregion--------------------------------------------------------------------

# region #* Singleton (+ метод __new__)


class Singleton:
    """ Создание класса синглтон. Это такой вид класса, который
    может содержать в себе только один уникальный экземпляр класса"""
    _instance = None  # указываем стандартное значение, означающее что
    # экземпляра еще нет. Он пока не создан.

    def __new__(cls):
        """стандартный конструктор создающий экземпляры (объекты) класса
        В данном случае, для класса Singlton, чтобы он выполнял свое назначение
        метод __new__ переопределяется, чтобы не было возможности создать
        несколько экзепляров этого класса"""
        if cls._instance is None:  # проверяет что экземпляр еще не создан, и,
            # если условие выполняется
            cls._instance = object.__new__(cls)  # создает экземпляр класса из
            # мегакласса object, с помощью его встроенного метода __new__,
            # поскольку для класса Singleton, __new__ уже переопределен.
        return cls._instance  # возвращаем созданный экземпляр

    def __init__(self):
        """конструктор экземпляра класса, с созданием аттрибут данных, со
        значением 'some value'"""
        self.value = "some value"


sing1 = Singleton()  # создаем 1-й объект класса
print(sing1)  # смотрим его значение (что он в себе содержит)
sing2 = Singleton()  # создаем 2-й объект класса
print(sing2)  # и удивляемся.. sting 1 и 2 ссылаются на один и тот же объект
# endregion--------------------------------------------------------------------

# if __name__ == "__main__":
#     main()
#     """ стандартный запуск модульного файла (через нижний main)
#     Такая форма предполагает, что модуль не запускается самостоятельно...Но..
#     Если все же его запустили как главный, то исполняется то что в нем, + все
#     что ниже этой записи не импортируется, но запускается если запускается
#     сам файл.
#     Часто используется в ООП, где весь код это классы и функции, и лишь одна
#     главная функция main собирает в себя весь написанный в функциях, классах
#     и объектах код. Если используется для этого, то стоит в самом конце файла
#     """
