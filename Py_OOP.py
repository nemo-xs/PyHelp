# В Python все является объектами.
# Все, даже основные классы являются объектами метаклассов
# #// Самый обширный класс __type__

# *ООП (Объектно ориентированное программирование)
# - создание классов и объектов, на основе классов.

"""docstring for бла бла бла бла
"""  # Документация (справка). Вставляется сразу после имени функции, класса.
# Закрывается тройными кавычками на новой строке.


class Car:  # Создание класса
    name = "None"  # Создание аргументов присущих классу. В качестве значения
    speed = 250  # указываются используемые по умолчанию.

    def set(self, name, speed):  # Создание функции внутри класса.
        # Set - функция установки аргументов, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше


class Premium:
    # Конструктор используемый внутри класса, при создании
    def __init__(self, name, speed):  # Создание функции внутри класса.
        # ___init___ - специальный опретатор, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше
        print(self.name, "имеет Скорость", self.speed)  # форма исполнения
        # см пример на мерседесе.
    # super(obj1, self).__init__()  # Пока не понятно. Это из шаблона

    def set(self, name, speed):  # Создание функции внутри класса.
        # Set - функция установки аргументов, self обязательный аргумент.
        # Остальные аргументы из описания класса. Ну или новые.
        self.name = name  # Присваивание аргументов из функции выше
        self.speed = speed  # Присваивание аргументов из функции выше


class Light(Car):  # Создание подкласса. Внутри скобок указываются родители.
    # Родителей может быть много, указываются через запятую. Все родительские
    # аргументы и функции доступны ниже, при создании объекта.
    wheels = 4  # дополнительные аргументы подкласса. Доступны только в нем и
    # в его дочерних подклассах.


bmv = Car()  # Создание объекта и назначение ему класса
bmv.set("BMV", 125)  # присвоение аргументов согласно порядку в функции(выше)
print(bmv.name, "едет", bmv.speed, "км в час")  # вывод полученного значения

shkoda = Light()  # Cсоздание объекта из подкласса.
shkoda.wheels = 5  # изменение значения подкласса. Если не менять, то берется
# тот который указан в подклассе, по умолчанию.
shkoda.set("Shkoda", 145)  # испольование и изменение аргументов из
# родительского класса, если не менять, то берутся по умолчанию.
print(shkoda.name, "имеет", shkoda.wheels, "колеса")

mersedes = Premium("Mersedes", 245)  # Создание объекта с помощью конструктора
# класса, в данном случае - Premium. В конструкторе прописываются все
# необходимые в том числе и действия (в данном примере - print).
mersedes.set("Mersedes-Bentz", 250)  # изменение аргументов, созданных ранее
print(mersedes.name, "едет", mersedes.speed)

# //ПРиМЕЧАНиЕ - создание и конструктором и через функцию set в одном классе,
# либо подклассе - работает, но конструктор должен идти раньше функции set.
# Если надо подкласс формировать не через конструктор, а родитель с
# конструктором, то в него надо вставить пустую функцию конструктора. Такую:
# def __init__(self):
#     pass
# ----------------------------------------------------------------------------


# * Создание классов и объектов класса -----------------------------------
class MyObj:  # создание класса MyObj. При этом, в данном случае, сам класс
    int_field = 8  # MyObj является объектом класса __main__.
    str_field = "Строка с текстом"
    # в классе созданы 2 аттрибута класса, int и str. При создании класса в нем
    # создаются атрибуты и функции, либо присваивается pass (пустой класс).


print(MyObj.str_field)  # доступ к атрибуту класса по его имени str_field
print(MyObj.int_field)  # доступ к атрибуту класса по его имени int_field

AnotherMyObj = MyObj  # Создание переменной (ссылки) на существующий класс

type(MyObj)  # вызов класса объекта. В консоли печатает к какому классу
# приналдежит объект.

obj1 = MyObj()  # Создание объекта класса MyObj.
obj2 = MyObj()  # Создание второго объекта класса MyObj.

print(obj1.int_field)  # Через объект класса мы также можем получить доступ к
print(obj2.str_field)  # его аттрибутам.

MyObj.int_field = 10  # изменение значение аттрибута всего класса MyObj
print(MyObj.int_field)  # доступ к обновленному аттрибуту
print(obj1.int_field)  # доступк через дочерний экземпляр класса

obj1.int_field = 22  # измение аттрибута непосредственно у объекта, при этом у
# всех иных объектов класса этот атрибут не меняется. Меняется только у
# конкретного экземпляра
print(obj1.int_field)  # берет измененный аттрибут, принадлежащщий только этому
# объекту класса
print(obj2.int_field)  # поскольку своего нет, берет значение материнского
# ----------------------------------------------------------------------------


class Pers:
    """Создание класса перс (человек). Такое написание комментария является
    документацией класса (функции), которая видна в линтинге, при вызове
    """
    pass  # Создаем пустой класс


john = Pers()  # Создание объекта john класса Pers
john.name = "John"  # создание аргумента объекта - John.
john.age = 27  # создание аргумента возраст, со значением 27

mary = Pers()  # см пояснения по Джону, тут все аналогично для объекта Мэри
mary.name = "Mary"
mary.age = 23

print(john.name, "возраст", john.age)  # принт через вызов аттрибутов объекта
print(mary.name, "возраст", mary.age)  # и печать параметров этих аттрибутов
# Такая запись не совсем верная, поскольку содержит почти одни и те же значения
# а значит если таких джонов млн - придется этот принт писать млн раз. Для
# этого делается форма класса (ниже):
# ---------------------------


class Person:
    def print_info(self):  # создание метода класса, с использованием
        print(self.name, "возраст", self.age)  # конструктора self (атрибут)
        # self это всегда первый атрибут в подобного вида методах.


derek = Person()
derek.name = "Derek"
derek.age = 42

masha = Person()
masha.name = "Masha"
masha.age = 37

Person.print_info(derek)  # вызов метода print_info класса Person для Дерека
Person.print_info(masha)  # - тоже самое для Маши
# но также можно делать и такую запись:
derek.print_info()  # вызов метода непорсдественно объекта класса, поскольку
masha.print_info()  # и Маша и Дерек члены класса Person, а этот класс имеет
# метод print_info
# Но это тоже не оптимальная запись.. Можно еще уростить:
# ----------------------------


class Persona:  # создание объектов на основе конструктора __init__
    def __init__(self, name, age):  # создаем метод, первый аргумент - ссылка
        self.name = name  # на сам объект, затем другие аругументы.
        self.age = age

    def print_info(self):  # см выше
        print(self.name, "возраст", self.age)


vasya = Persona("Vasya", 20)  # создание объектов класса через конструктор
dusya = Persona("Dusya", 18)  # __init__, аттр. по порядку, как в конструкторе

vasya.print_info()  # см выше, вызов метода через объект класса
dusya.print_info()
# -------------------------------------------------------------------------

# * Декораторы
# Специальная функция, которая изменяет поведение функции или класса (можно
# сравнить с фильтром).
# //обозначается: символ @, имя декоратора, список аргументов в ()
# Если передача аргументов не требуется, () не указываются.
# Для создания статических методов -#* декоратор staticmethod


class MyObjekt:  # создаем класс
    class_attr = 8  # объявляем аттрибут и его параметры

    def __init__(self):  # создаем конструктор класса
        self.data_attr = 42  # и вкладываем туда аттрибут с параметрами

    def instance_method(self):  # функция метод, печатающая data_attr
        print(self.data_attr)

    @staticmethod  # описываем статичский метод, работает на самом классе и
    def static_method():  # всех его экземплярах. Не привязан к (self), так как
        print(MyObjekt.class_attr)  # может вызываться еще и самим классом
        # поскольку мы в этом методе не имеем доступа к данным, можем вывести
        # только данные которые есть непосредственно в самом классе (выше)
        # привязан только к самому классу (скобки пустые. там нет self)


if __name__ == "__main__":  # Если модуль запущен как исполняемый файл:
    MyObjekt.static_method()  # вызов статического метода класса
    objct = MyObjekt()  # создание объекта, экземпляра класса
    objct.instance_method()  # вызов инстанс метода объекта
    objct.static_method()  # вызов статик метода объекта (через декоратор)
# то есть через статик вызывается параметр класса, который есть в функции но
# не привязан к конкретному объекту.

# Для создания методов класса -#* декоратор classmethod
# // их первый рагумент не self а cls
# Методы класса такие же как обычные, только они сам класс воспринимают как
# объект как экземпляр Метакласса. Привязаны не к обектам класса а к самим
# классам. То есть..
# // Обычные методы привязаны к экземплярам класса.
# // Статические методы - привязаны к самому классу внутри него самого
# // Методы класса воспринимают класс как экземпляр метакласса.
# Они не работают с экземплярами класса, не имеют доступа к атр. данных
# экземпляраов класса, так же как статический метод.
# используется в разных областях, для сохранения иерархии наследования.


class Rectangle:  # создаем класс прямоугольник с 2-мя сторонами
    def __init__(self, side_a, side_b):  # метод конструктор
        self.side_a = side_a  # принимает атирбуты данных стороны а и б
        self.side_b = side_b

    def __repr__(self):  # еще один метод конструктор. Существует 2 похожих..
        # // __repr__ и __str__. Оба переводят значения в троку. Разница в том,
        # что __str__ переводит в строку для пользователя, а __repr__ без
        # доступа пользователя к этим данным, т.е. для внутренних нужд.
        # в функции print вшит метод __str__
        # так,если печатать print(repr(s)) - печатает значение s вместе с ""
        # Внешнее отличие, когда print по умолчанию (через str) - печатается
        # только само значение. Если через repr - то вместе с кавычками.
        return 'Rectangle(%.1f, %.1f)' % (self.side_a, self.side_b)
        # ? хер его знает что это такое. надо разбираться


class Circle:  # создаем класс круг
    def __init__(self, radius):
        self.radius = radius

    def __repr__(self):
        return 'Circle(%.1f)' % self.radius

    @classmethod  # используя метод класса, вычисляем по формуле окружность,
    # которая описывает снаружи объект из вышесозданного класса прямоугольник
    def from_rectangle(cls, rectangle):  # метод из прямоугольника считаем:
        radius = (rectangle.side_a ** 2 + rectangle.side_b ** 2) ** 0.5 / 2
        # формула расчета радиуса по двум сторонам, см. математику
        return cls(radius)  # возвращаем значение радиуса


def main():
    rectangle = Rectangle(3, 4)  # создаем прямоугольник со сторонами 3 и 4
    print(rectangle)  # выводим созданный прямоугольник на экран

    firstCircle = Circle(1)  # создаем круг с радиусом 1
    print(firstCircle)  # выводим его на экран

    secondCircle = Circle.from_rectangle(rectangle)  # создаем второй круг,
    # с радиусом расчитанным по формуле из classmetod from_rectangle, где за
    # основу расчетов берется созданный ранее прямоугольник, что указано в ()
    print(secondCircle)  # выводим его на экран


if __name__ == "__main__":  # Если модуль запущен как исполняемый файл:
    main()  # запускаем функцию main c указанными там параметрами

# * инкапсуляция ---------------------------------------------------------
# Свойство системы, объединяет данные и методы и скрывает детали реализации
# обеспечивается контролем и методами доступа, свойствами объекта
# Все аттрибуты в Python являются публичными
# // Аттрибыты начинающиеся с _знака подчеркивания, говорят, что он относится к
# внутренней реализации класса. Но..#// Они никак не защищены.
# // Аттрибуты начинающиеся, но не заканчивающиеся с __двух подчеркиваний,
# являются приватными. К ним применяются механизм #// "name mangling".
# _(подверкивание) Имя класса __(двойное подчеркивание) название атрибута
# // как пример '_ClassName__attributName'
# Они также никак не защищены и к ним можно обратиться извне, зная имя класса.
# То есть инкапсуляция в Пайтон условная.. Она позволяет не перепутать.
# Доступ к приватным атрибутам обеспечивается методами доступа и свойствами:

# Атрибут self в классах - это указание на самого себя. В момент исполнения
# туда подстваляется значение самого экземпляра класса


class TestClass:
    def __init__(self):
        self.__private_attr = 42  # создаем приватный атрибут (подчеркиванием)

# ** создание доступа по методу доступа -------------------------
    def get_privat(self):  # создаем метод который возвращает приватный аттр.
        return self.__private_attr  # такой подход - это метод доступа

    def set_attr(self, value):  # установка значения для приватного аттр.
        if value < 100:  # в данном случае по условию.. Если меньше 100 то..
            self.__private_attr = value  # иначе - ничего.

# ** создание досутпа по методу свойства ------------------------
    @property  # декоратор, возвращающий значение свойства
    def privat_attr(self):  # создаем метод, с именем без подчеркивания
        return self.__private_attr

    @privat_attr.setter  # декоратор свойства (имя изменяемого атр.setter)
    def privat_attr(self, value):  # метод с точным именем атрибута
        if value >= 100:
            self.__private_attr = value


testObj = TestClass()  # создаем объект класса
testObj.set_attr(50)  # присваиваем значение по методу доступа (get_private)
print(testObj.get_privat())  # печать значения (изменненного строкой выше)
# // print(testObj.__private_attr) при такой записи получаем ошибку
print(testObj._TestClass__private_attr)  # вот такая запись есть 'name manling'
testObj.privat_attr = 200  # смена значение по методу свойства (@property)
print(testObj.privat_attr)  # печать значения созданного методом свойства

# * Специальные атрибуты и методы
# имена начинающие и заканчивающиеся двумя подчеркиваниями '__ИмяАтр__'
# являются внутренними для пайтон и задают особые свойства объекта, примеры
# __doc__, __class__ и т.п.
# Среди таких атрибутов есть методы, в сообществе называемые "магическими"
# Они задают очобое поведение объектов и позволяют переопределять поведение
# встроенных функций и методов для экземпляров класса.
# **Наиболее часто используемый __init__ # * инициазизация объекта
# ! Не следует объявлять свои атрибуты по такому шаблону!!!

# * Через конструкторы объектов (например __init__) создаются атрибуты объектов
# если создавать их как либо иначе, не через конструктор, то внесенные в
# последствии аттрибуты будут присваиваться всему классу, а не конкретному
# объекту. То есть, если сделать так:
"""
class TestClass:
    tags = []  --------- !!!!!!!!!!!!!!!!!!

    def __init__(self):
        self.att = 0

    def tester(self):
        self.tags = []
 """
# // все объявленные потом атрибуты att - будут иметь отношение только к одному
# конкретному объекту. А все tags - ко всем объектам класса. Если же tags
# объявлять внутри констурктора вот так:
"""
class TestClass1:
    def __init__(self):
        self.att = 0
        self.tags = []
"""
# тогда они будут иметь отношение только к конкретным экземплярам на не к класу


class Complex:  # Странный конечно пример, на методе составных чисел
    def __init__(self, real=0.0, imreal=0.0):
        self.real = real
        self.imreal = imreal

    def __repr__(self):  # возврат значений для разработчика. репрезентэйшн
        return "Complex({!r}, {!r})".format(self.real, self.imreal)
        # возврат Комплекс от 2-х аргументов. Первый от real, второй imreal

    def __str__(self):
        return "{}{:+d}i".format(self.real, self.imreal)
        # {} - первое число, {:+d} - второе с обязательным знаком, и i

    def __add__(self, other):  # __add__ - это вшитый метод сложения
        return Complex(self.real + other.real, self.imreal + other.imreal)
        # также точно строится __sub__ - вычитание

    def __neg__(self):  # метод меняющий знак числа
        return Complex(-self.real, -self.imreal)  # возвращает значение числа
        # со знаком (-) минус.

    def __next__(self):  # метод итератора, вызывающий следующее значение
        pass

    def __iter__(self):  # метод создающий итерируемое значение
        pass


c = Complex(2, 5)  # объект класса комплекс, при этом если вывести через repr -
# программа получает значение Complex(2,5), а если через print (то есть str)
# на выходе 2+5i
print(repr(c))  # печать значения
print(c)  # печать содержимого
print(Complex(2, 3) + Complex(2, -1))  # вызов через __add__ (математика).
# Действительная часть сложилась с действительной а мнимая с мнимой
print(Complex.mro())  # печать структуры пространства имен (в каком порядке)


class Singleton:  # Создание класса синглтон. Это такой вид класса, который
    # может содержать в себе только один уникальный экземпляр класса
    _instance = None  # указание на экземпляр класса, которого в момент
    # создания не существует

    def __new__(cls):  # создаем конструктор экземпляра класса, который:
        if cls._instance is None:  # проверяет что экз. еще не создан
            cls._instance = object.__new__(cls)  # создает его из мегакласса
            # объект с помощью встроенного метода __new__
        return cls._instance  # возвращаем созданный экземпляр

    def __init__(self):  # конструктор создает аттрибут данных, со значением
        self.value = "some value"  # "some value"


sing1 = Singleton()  # создаем 1-й объект класса
print(sing1)  # смотрим его значение (что он в себе содержит)
sing2 = Singleton()  # создаем 2-й объект класса
print(sing2)  # и удивляемся.. sting 1 и 2 ссылаются на один и тот же объект


# //защита данных, управление доступом к аттрибутам
class Passwrd:  # создание класса
    def __init__(self):  # конструктор экземпляра класса
        self.pwrd = None  # со значением none

    def __getattribute__(self, name):  # специальный метод содержащий параметры
        # экземпляра класса и некое строковое значение name
        if name == "secret_field" and self.pwrd == "fwef9823":
            # если название name и пароль который нас интересует
            return "Secret Value"  # вернем значение ""
        else:
            return object.__getattribute__(self, name)  # иначе возвращаем
            # значение, которое содержится в стандартном экземпляре класса


pwd = Passwrd()  # создаем объект класса
pwd.pwrd = "fwef9823"  # вводим значение пароля в параметр экземпляра
print(pwd.secret_field)  # вызываем серкетное значение через __getattribute__
# если пердварительно не ввести в поле пароля пароль, вылетает исклчение, как
# если бы такого значения не существовало вовсе.

# * Наследование и полиморфизм ------------------------------------------
# Механизм языка, который позволяет строить классы на основе существующих
# Позволяет строить иерархии
# Класс потомок может добавлять свои методы и свойства, а также пользоваться
# родительскими методами и свойствами. При совпаднии имен - переопределяет
# родительский метод конкретно для себя и своих наследников
# метод ищется сначала у себя, потому у родителя, потом у всех предков...


class Base:  # создание базового класса
    def method(self):  # который имеет метод, печатающий Hellow from Base
        print("Hellow from Base")


class Chaild(Base):  # создаем дочерний класс Chaild
    def ch_method(self):  # который печатает свое приветствие
        print("hellow from chaild")

    # def method(self):  # создание метода переопределяющего родительский
    #     print("Hellow redifine")  # если раскоментирован, печатается он


ex_chaild = Chaild()  # создаем экземпляр дочернего класса
ex_chaild.method()  # обращаемся через дочерний класс к методу родителя
ex_chaild.ch_method()  # обращается к своему собственному методу

issubclass(Chaild, Base)  # проверяет является ли класс Chaild наследником Base
isinstance(ex_chaild, Base)  # проверяет является ли ex_chaikd экземпляром
# класса Base или класса, который является наследником Base

# Есть области пространства имен: #// local, non-local, global, built-in
# * super([type[,object-or-type]]) делегирует вызов методов родителю или
# собрату класса указанного типа по дереву .mro/ пример применения в дочернем
# к классу list классе #// super(Chaild_class, self).append(x), где append это
# метод родительского класса list. Также можно просто # // super().append(x)
